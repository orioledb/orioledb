--
-- Test orioledb indexes:
-- 1) orioledb_tbl_indices correct only for non-unique secondary indices
-- 2) INSERT works only for non-unique secondary indices
-- create tables with base variations of indexes
-- ctid is primary index
CREATE SCHEMA indices;
SET SESSION search_path = 'indices';
CREATE EXTENSION orioledb;
CREATE TABLE o_test50
(
	key int8 NOT NULL,
	value int8
) USING orioledb;
SELECT orioledb_tbl_indices('o_test50'::regclass);
              orioledb_tbl_indices              
------------------------------------------------
 Index ctid_primary                            +
     Index type: primary, unique, ctid         +
     Leaf tuple size: 3, non-leaf tuple size: 1+
     Non-leaf tuple fields: ctid               +
 
(1 row)

INSERT INTO o_test50 SELECT 100 + i, 200 + i FROM generate_series(1, 100) AS i;
EXPLAIN (COSTS off) SELECT * FROM o_test50 WHERE key BETWEEN 100 and 110;
                QUERY PLAN                 
-------------------------------------------
 Seq Scan on o_test50
   Filter: ((key >= 100) AND (key <= 110))
(2 rows)

SELECT * FROM o_test50 WHERE key BETWEEN 100 and 110;
 key | value 
-----+-------
 101 |   201
 102 |   202
 103 |   203
 104 |   204
 105 |   205
 106 |   206
 107 |   207
 108 |   208
 109 |   209
 110 |   210
(10 rows)

EXPLAIN (COSTS off) SELECT * FROM o_test50 WHERE value BETWEEN 200 and 210;
                  QUERY PLAN                   
-----------------------------------------------
 Seq Scan on o_test50
   Filter: ((value >= 200) AND (value <= 210))
(2 rows)

SELECT * FROM o_test50 WHERE value BETWEEN 200 and 210;
 key | value 
-----+-------
 101 |   201
 102 |   202
 103 |   203
 104 |   204
 105 |   205
 106 |   206
 107 |   207
 108 |   208
 109 |   209
 110 |   210
(10 rows)

EXPLAIN (COSTS off) SELECT * FROM o_test50;
      QUERY PLAN      
----------------------
 Seq Scan on o_test50
(1 row)

SELECT count(*) FROM o_test50;
 count 
-------
   100
(1 row)

TRUNCATE o_test50;
-- value is primary index
CREATE TABLE o_test51
(
	key int8 NOT NULL,
	value int8 NOT NULL,
	PRIMARY KEY(value)
) USING orioledb;
SELECT orioledb_tbl_indices('o_test51'::regclass);
              orioledb_tbl_indices              
------------------------------------------------
 Index o_test51_pkey                           +
     Index type: primary, unique               +
     Leaf tuple size: 2, non-leaf tuple size: 1+
     Non-leaf tuple fields: value              +
 
(1 row)

INSERT INTO o_test51 SELECT 100 + i, 200 + i FROM generate_series(1, 100) AS i;
EXPLAIN (COSTS off) SELECT * FROM o_test51 WHERE key BETWEEN 100 and 110;
                QUERY PLAN                 
-------------------------------------------
 Seq Scan on o_test51
   Filter: ((key >= 100) AND (key <= 110))
(2 rows)

SELECT * FROM o_test51 WHERE key BETWEEN 100 and 110;
 key | value 
-----+-------
 101 |   201
 102 |   202
 103 |   203
 104 |   204
 105 |   205
 106 |   206
 107 |   207
 108 |   208
 109 |   209
 110 |   210
(10 rows)

EXPLAIN (COSTS off) SELECT * FROM o_test51 WHERE value BETWEEN 200 and 210;
                  QUERY PLAN                  
----------------------------------------------
 Custom Scan (o_scan) on o_test51
   Forward index scan of: o_test51_pkey
   Conds: ((value >= 200) AND (value <= 210))
(3 rows)

SELECT * FROM o_test51 WHERE value BETWEEN 200 and 210;
 key | value 
-----+-------
 101 |   201
 102 |   202
 103 |   203
 104 |   204
 105 |   205
 106 |   206
 107 |   207
 108 |   208
 109 |   209
 110 |   210
(10 rows)

EXPLAIN (COSTS off) SELECT * FROM o_test51;
      QUERY PLAN      
----------------------
 Seq Scan on o_test51
(1 row)

SELECT count(*) FROM o_test51;
 count 
-------
   100
(1 row)

TRUNCATE o_test51;
-- 2 fields as primary index
CREATE TABLE o_test52
(
	key int8 NOT NULL,
	value int8 NOT NULL,
	PRIMARY KEY(key, value)
) USING orioledb;
SELECT orioledb_tbl_indices('o_test52'::regclass);
              orioledb_tbl_indices              
------------------------------------------------
 Index o_test52_pkey                           +
     Index type: primary, unique               +
     Leaf tuple size: 2, non-leaf tuple size: 2+
     Non-leaf tuple fields: key, value         +
 
(1 row)

INSERT INTO o_test52 SELECT 100 + i, 200 + i FROM generate_series(1, 100) AS i;
EXPLAIN (COSTS off) SELECT * FROM o_test52 WHERE key BETWEEN 100 and 110;
                 QUERY PLAN                  
---------------------------------------------
 Custom Scan (o_scan) on o_test52
   Forward index only scan of: o_test52_pkey
   Conds: ((key >= 100) AND (key <= 110))
(3 rows)

SELECT * FROM o_test52 WHERE key BETWEEN 100 and 110;
 key | value 
-----+-------
 101 |   201
 102 |   202
 103 |   203
 104 |   204
 105 |   205
 106 |   206
 107 |   207
 108 |   208
 109 |   209
 110 |   210
(10 rows)

EXPLAIN (COSTS off) SELECT * FROM o_test52 WHERE value BETWEEN 200 and 210;
                  QUERY PLAN                  
----------------------------------------------
 Custom Scan (o_scan) on o_test52
   Forward index only scan of: o_test52_pkey
   Conds: ((value >= 200) AND (value <= 210))
(3 rows)

SELECT * FROM o_test52 WHERE value BETWEEN 200 and 210;
 key | value 
-----+-------
 101 |   201
 102 |   202
 103 |   203
 104 |   204
 105 |   205
 106 |   206
 107 |   207
 108 |   208
 109 |   209
 110 |   210
(10 rows)

EXPLAIN (COSTS off) SELECT * FROM o_test52;
      QUERY PLAN      
----------------------
 Seq Scan on o_test52
(1 row)

SELECT count(*) FROM o_test52;
 count 
-------
   100
(1 row)

TRUNCATE o_test52;
-- key is primary index
CREATE TABLE o_test53
(
	key int8 NOT NULL,
	value int8 NOT NULL,
	PRIMARY KEY(key)
) USING orioledb;
SELECT orioledb_tbl_indices('o_test53'::regclass);
              orioledb_tbl_indices              
------------------------------------------------
 Index o_test53_pkey                           +
     Index type: primary, unique               +
     Leaf tuple size: 2, non-leaf tuple size: 1+
     Non-leaf tuple fields: key                +
 
(1 row)

INSERT INTO o_test53 SELECT 100 + i, 200 + i FROM generate_series(1, 100) AS i;
EXPLAIN (COSTS off) SELECT * FROM o_test53 WHERE key BETWEEN 100 and 110;
                QUERY PLAN                
------------------------------------------
 Custom Scan (o_scan) on o_test53
   Forward index scan of: o_test53_pkey
   Conds: ((key >= 100) AND (key <= 110))
(3 rows)

SELECT * FROM o_test53 WHERE key BETWEEN 100 and 110;
 key | value 
-----+-------
 101 |   201
 102 |   202
 103 |   203
 104 |   204
 105 |   205
 106 |   206
 107 |   207
 108 |   208
 109 |   209
 110 |   210
(10 rows)

EXPLAIN (COSTS off) SELECT * FROM o_test53 WHERE value BETWEEN 200 and 210;
                  QUERY PLAN                   
-----------------------------------------------
 Seq Scan on o_test53
   Filter: ((value >= 200) AND (value <= 210))
(2 rows)

SELECT * FROM o_test53 WHERE value BETWEEN 200 and 210;
 key | value 
-----+-------
 101 |   201
 102 |   202
 103 |   203
 104 |   204
 105 |   205
 106 |   206
 107 |   207
 108 |   208
 109 |   209
 110 |   210
(10 rows)

EXPLAIN (COSTS off) SELECT * FROM o_test53;
      QUERY PLAN      
----------------------
 Seq Scan on o_test53
(1 row)

SELECT count(*) FROM o_test53;
 count 
-------
   100
(1 row)

TRUNCATE o_test53;
-- key is primary index, value is secondary
CREATE TABLE o_test54
(
	key int8 NOT NULL,
	value int8,
	PRIMARY KEY(key)
) USING orioledb;
CREATE INDEX o_test54_sec ON o_test54 (value);
SELECT orioledb_tbl_indices('o_test54'::regclass);
              orioledb_tbl_indices              
------------------------------------------------
 Index o_test54_pkey                           +
     Index type: primary, unique               +
     Leaf tuple size: 2, non-leaf tuple size: 1+
     Non-leaf tuple fields: key                +
 Index o_test54_sec                            +
     Index type: secondary                     +
     Leaf tuple size: 2, non-leaf tuple size: 2+
     Non-leaf tuple fields: value, key         +
     Leaf tuple fields: value, key             +
 
(1 row)

INSERT INTO o_test54 SELECT 100 + i, 200 + i FROM generate_series(1, 100) AS i;
ANALYZE o_test54;
SET enable_seqscan = off;
EXPLAIN (COSTS off) SELECT * FROM o_test54 WHERE key BETWEEN 100 and 110;
                QUERY PLAN                
------------------------------------------
 Custom Scan (o_scan) on o_test54
   Forward index scan of: o_test54_pkey
   Conds: ((key >= 100) AND (key <= 110))
(3 rows)

SELECT * FROM o_test54 WHERE key BETWEEN 100 and 110;
 key | value 
-----+-------
 101 |   201
 102 |   202
 103 |   203
 104 |   204
 105 |   205
 106 |   206
 107 |   207
 108 |   208
 109 |   209
 110 |   210
(10 rows)

EXPLAIN (COSTS off) SELECT * FROM o_test54 WHERE value BETWEEN 200 and 210;
                  QUERY PLAN                  
----------------------------------------------
 Custom Scan (o_scan) on o_test54
   Forward index only scan of: o_test54_sec
   Conds: ((value >= 200) AND (value <= 210))
(3 rows)

SELECT * FROM o_test54 WHERE value BETWEEN 200 and 210;
 key | value 
-----+-------
 101 |   201
 102 |   202
 103 |   203
 104 |   204
 105 |   205
 106 |   206
 107 |   207
 108 |   208
 109 |   209
 110 |   210
(10 rows)

EXPLAIN (COSTS off) SELECT value, key FROM o_test54 WHERE value BETWEEN 200 and 210;
                  QUERY PLAN                  
----------------------------------------------
 Custom Scan (o_scan) on o_test54
   Forward index only scan of: o_test54_sec
   Conds: ((value >= 200) AND (value <= 210))
(3 rows)

SELECT value, key FROM o_test54 WHERE value BETWEEN 200 and 210;
 value | key 
-------+-----
   201 | 101
   202 | 102
   203 | 103
   204 | 104
   205 | 105
   206 | 106
   207 | 107
   208 | 108
   209 | 109
   210 | 110
(10 rows)

RESET enable_seqscan;
EXPLAIN (COSTS off) SELECT * FROM o_test54;
      QUERY PLAN      
----------------------
 Seq Scan on o_test54
(1 row)

SELECT count(*) FROM o_test54;
 count 
-------
   100
(1 row)

TRUNCATE o_test54;
-- value is primary index, key is secondary
CREATE TABLE o_test55
(
	key int8 NOT NULL,
	value int8 NOT NULL,
	PRIMARY KEY(value)
) USING orioledb;
CREATE UNIQUE INDEX o_test55_uniq ON o_test55(key);
SELECT orioledb_tbl_indices('o_test55'::regclass);
              orioledb_tbl_indices              
------------------------------------------------
 Index o_test55_pkey                           +
     Index type: primary, unique               +
     Leaf tuple size: 2, non-leaf tuple size: 1+
     Non-leaf tuple fields: value              +
 Index o_test55_uniq                           +
     Index type: secondary, unique             +
     Leaf tuple size: 2, non-leaf tuple size: 2+
     Non-leaf tuple fields: key, value         +
     Leaf tuple fields: key, value             +
 
(1 row)

INSERT INTO o_test55 VALUES (1, 2);
EXPLAIN (COSTS OFF) SELECT * FROM o_test55 WHERE key = 1;
                 QUERY PLAN                  
---------------------------------------------
 Custom Scan (o_scan) on o_test55
   Forward index only scan of: o_test55_uniq
   Conds: (key = 1)
(3 rows)

SELECT * FROM o_test55 WHERE key = 1;
 key | value 
-----+-------
   1 |     2
(1 row)

-- fails, secondary unique index contains key = 1
INSERT INTO o_test55 VALUES (1, 3);
ERROR:  duplicate key value violates unique constraint "o_test55_uniq"
DETAIL:  Key (key)=('1') already exists.
-- fails, primary index contains value = 2;
INSERT INTO o_test55 VALUES (3, 2);
ERROR:  duplicate key value violates unique constraint "o_test55_pkey"
DETAIL:  Key (value)=('2') already exists.
-- success
INSERT INTO o_test55 VALUES (3, 4);
ANALYZE o_test55;
SELECT * FROM o_test55 WHERE key >= 1;
 key | value 
-----+-------
   1 |     2
   3 |     4
(2 rows)

-- key is primary index (first unique)
CREATE TABLE o_test56
(
	key int8 NOT NULL,
	value int8,
	PRIMARY KEY (key)
) USING orioledb;
CREATE UNIQUE INDEX o_test56_uniq ON o_test56(value);
SELECT orioledb_tbl_indices('o_test56'::regclass);
              orioledb_tbl_indices              
------------------------------------------------
 Index o_test56_pkey                           +
     Index type: primary, unique               +
     Leaf tuple size: 2, non-leaf tuple size: 1+
     Non-leaf tuple fields: key                +
 Index o_test56_uniq                           +
     Index type: secondary, unique             +
     Leaf tuple size: 2, non-leaf tuple size: 2+
     Non-leaf tuple fields: value, key         +
     Leaf tuple fields: value, key             +
 
(1 row)

INSERT INTO o_test56 VALUES (1, 1);
INSERT INTO o_test56 VALUES (3, 3);
EXPLAIN (COSTS OFF) SELECT * FROM o_test56 WHERE key = 1;
               QUERY PLAN               
----------------------------------------
 Custom Scan (o_scan) on o_test56
   Forward index scan of: o_test56_pkey
   Conds: (key = 1)
(3 rows)

SELECT * FROM o_test56 WHERE key = 1;
 key | value 
-----+-------
   1 |     1
(1 row)

EXPLAIN (COSTS OFF) SELECT * FROM o_test56 WHERE value = 3;
                 QUERY PLAN                  
---------------------------------------------
 Custom Scan (o_scan) on o_test56
   Forward index only scan of: o_test56_uniq
   Conds: (value = 3)
(3 rows)

SELECT * FROM o_test56 WHERE value = 3;
 key | value 
-----+-------
   3 |     3
(1 row)

-- fails, primary index contains key = 3;
UPDATE o_test56 SET key = 3 WHERE value = 1;
ERROR:  duplicate key value violates unique constraint "o_test56_pkey"
DETAIL:  Key (key)=('3') already exists.
-- fails, secondary unique index contains value = 3;
UPDATE o_test56 SET value = 3 WHERE value = 1;
ERROR:  duplicate key value violates unique constraint "o_test56_uniq"
DETAIL:  Key (value)=('3') already exists.
-- success
UPDATE o_test56 SET value = 2 WHERE value = 3;
UPDATE o_test56 SET key = 2 WHERE key = 1;
SELECT * FROM o_test56;
 key | value 
-----+-------
   2 |     1
   3 |     2
(2 rows)

SELECT * FROM o_test56 WHERE value > 0;
 key | value 
-----+-------
   2 |     1
   3 |     2
(2 rows)

-- three indices, value is primary
CREATE TABLE o_test57
(
	key int8 NOT NULL,
	value int8 NOT NULL,
	foo int8,
	PRIMARY KEY (value)
) USING orioledb;
CREATE UNIQUE INDEX o_test57_uniq ON o_test57(key);
CREATE INDEX o_test57_reg ON o_test57(foo);
SELECT orioledb_tbl_indices('o_test57'::regclass);
              orioledb_tbl_indices              
------------------------------------------------
 Index o_test57_pkey                           +
     Index type: primary, unique               +
     Leaf tuple size: 3, non-leaf tuple size: 1+
     Non-leaf tuple fields: value              +
 Index o_test57_uniq                           +
     Index type: secondary, unique             +
     Leaf tuple size: 2, non-leaf tuple size: 2+
     Non-leaf tuple fields: key, value         +
     Leaf tuple fields: key, value             +
 Index o_test57_reg                            +
     Index type: secondary                     +
     Leaf tuple size: 2, non-leaf tuple size: 2+
     Non-leaf tuple fields: foo, value         +
     Leaf tuple fields: foo, value             +
 
(1 row)

CREATE OR REPLACE FUNCTION smart_explain(sql TEXT) RETURNS SETOF TEXT AS $$
	DECLARE
		row RECORD;
		line text;
		indent integer;
		skip_indent integer;
		skip_start integer;
	BEGIN
		skip_indent := 0;
		skip_start := 0;
		FOR row IN EXECUTE sql LOOP
			line := row."QUERY PLAN";
			indent := length((regexp_match(line, '^ *'))[1]);
			IF line ~ '^ *->  Result' OR line ~ '^Result' THEN
				skip_indent := 6;
				skip_start := indent;
			ELSE
				IF indent >= skip_start THEN
					line := substr(line, skip_indent + 1);
				ELSE
					skip_indent := 0;
					skip_start := 0;
				END IF;
				RETURN NEXT line;
			END IF;
		END LOOP;
	END $$
LANGUAGE plpgsql;
-- three indices, (key, value) is primary
CREATE TABLE o_test58
(
	key int8 NOT NULL,
	value int8 NOT NULL,
	foo int8,
	bar int8,
	PRIMARY KEY(key, value)
) USING orioledb;
CREATE INDEX o_test58_reg1 ON o_test58(key);
CREATE INDEX o_test58_reg2 ON o_test58(foo);
SELECT orioledb_tbl_indices('o_test58'::regclass);
              orioledb_tbl_indices              
------------------------------------------------
 Index o_test58_pkey                           +
     Index type: primary, unique               +
     Leaf tuple size: 4, non-leaf tuple size: 2+
     Non-leaf tuple fields: key, value         +
 Index o_test58_reg1                           +
     Index type: secondary                     +
     Leaf tuple size: 2, non-leaf tuple size: 2+
     Non-leaf tuple fields: key, value         +
     Leaf tuple fields: key, value             +
 Index o_test58_reg2                           +
     Index type: secondary                     +
     Leaf tuple size: 3, non-leaf tuple size: 3+
     Non-leaf tuple fields: foo, key, value    +
     Leaf tuple fields: foo, key, value        +
 
(1 row)

INSERT INTO o_test58 SELECT 100 + i, 200 + i, 300 + i, 400 + i FROM generate_series(1, 10) AS i;
SELECT orioledb_tbl_check('o_test58'::regclass);
 orioledb_tbl_check 
--------------------
 t
(1 row)

EXPLAIN (COSTS off) SELECT * FROM o_test58;
      QUERY PLAN      
----------------------
 Seq Scan on o_test58
(1 row)

EXPLAIN (COSTS off) SELECT * FROM o_test58 WHERE foo = 301;
               QUERY PLAN               
----------------------------------------
 Custom Scan (o_scan) on o_test58
   Forward index scan of: o_test58_reg2
   Conds: (foo = 301)
(3 rows)

EXPLAIN (COSTS off) SELECT * FROM o_test58 WHERE foo > 300 and foo < 400 and
												 bar = 300;
               QUERY PLAN               
----------------------------------------
 Custom Scan (o_scan) on o_test58
   Filter: (bar = 300)
   Forward index scan of: o_test58_reg2
   Conds: ((foo > 300) AND (foo < 400))
(4 rows)

EXPLAIN (COSTS off) SELECT * FROM o_test58 WHERE bar = 200;
      QUERY PLAN       
-----------------------
 Seq Scan on o_test58
   Filter: (bar = 200)
(2 rows)

SELECT smart_explain(
'EXPLAIN (COSTS off) UPDATE o_test58 SET foo = 100 WHERE foo > 102 AND
														 foo < 400;');
                smart_explain                 
----------------------------------------------
 Update on o_test58
   ->  Custom Scan (o_scan) on o_test58
         Forward index scan of: o_test58_reg2
         Conds: ((foo > 102) AND (foo < 400))
(4 rows)

UPDATE o_test58 SET foo = 100 WHERE foo > 102;
--SELECT orioledb_tbl_structure('o_test58'::regclass);
UPDATE o_test58 SET key = 100 WHERE foo > 100;
--SELECT orioledb_tbl_structure('o_test58'::regclass);
-- three indices, (pri1, pri2) is primary, sec1 and sec2 - secondary
CREATE TABLE o_test59
(
	sec1 int8 NOT NULL,
	pri1 int8 NOT NULL,
	pri2 int8 NOT NULL,
	sec2 int8,
	foo int8,
	PRIMARY KEY(pri1, pri2)
) USING orioledb;
CREATE INDEX o_test59_reg1 ON o_test59(sec1);
CREATE INDEX o_test59_reg2 ON o_test59(sec2);
EXPLAIN (COSTS off) SELECT * FROM o_test59 WHERE sec1 = 100;
               QUERY PLAN               
----------------------------------------
 Custom Scan (o_scan) on o_test59
   Forward index scan of: o_test59_reg1
   Conds: (sec1 = 100)
(3 rows)

EXPLAIN (COSTS off) SELECT * FROM o_test59 WHERE sec1 = 100 and pri1 > 200;
               QUERY PLAN               
----------------------------------------
 Custom Scan (o_scan) on o_test59
   Filter: (pri1 > 200)
   Forward index scan of: o_test59_reg1
   Conds: (sec1 = 100)
(4 rows)

EXPLAIN (COSTS off) SELECT * FROM o_test59 WHERE sec1 = 100 and pri1 = 200;
               QUERY PLAN               
----------------------------------------
 Custom Scan (o_scan) on o_test59
   Filter: (pri1 = 200)
   Forward index scan of: o_test59_reg1
   Conds: (sec1 = 100)
(4 rows)

EXPLAIN (COSTS off) SELECT * FROM o_test59 WHERE pri1 = 100;
               QUERY PLAN               
----------------------------------------
 Custom Scan (o_scan) on o_test59
   Forward index scan of: o_test59_pkey
   Conds: (pri1 = 100)
(3 rows)

EXPLAIN (COSTS off) SELECT * FROM o_test59 WHERE sec2 = 200;
               QUERY PLAN               
----------------------------------------
 Custom Scan (o_scan) on o_test59
   Forward index scan of: o_test59_reg2
   Conds: (sec2 = 200)
(3 rows)

EXPLAIN (COSTS off) SELECT * FROM o_test59 WHERE sec2 = 200 and pri1 = 100;
               QUERY PLAN               
----------------------------------------
 Custom Scan (o_scan) on o_test59
   Filter: (pri1 = 100)
   Forward index scan of: o_test59_reg2
   Conds: (sec2 = 200)
(4 rows)

INSERT INTO o_test59 SELECT 100 + i, 200 + i, 300 + i, 400 + i, 500 + i FROM generate_series(1, 10) AS i;
--SELECT orioledb_tbl_structure('o_test59'::regclass);
-- update not index field
SELECT smart_explain(
'EXPLAIN (COSTS off) UPDATE o_test59 SET foo = 0 WHERE sec1 > 105 AND
													   sec1 < 200;');
                 smart_explain                  
------------------------------------------------
 Update on o_test59
   ->  Custom Scan (o_scan) on o_test59
         Forward index scan of: o_test59_reg1
         Conds: ((sec1 > 105) AND (sec1 < 200))
(4 rows)

UPDATE o_test59 SET foo = 0 WHERE sec1 > 105;
--SELECT orioledb_tbl_structure('o_test59'::regclass);
-- update only sec1 index field
SELECT smart_explain(
'EXPLAIN (COSTS off) UPDATE o_test59 SET sec1 = 100 WHERE sec2 > 405 and sec2 < 408;');
                 smart_explain                  
------------------------------------------------
 Update on o_test59
   ->  Custom Scan (o_scan) on o_test59
         Forward index scan of: o_test59_reg2
         Conds: ((sec2 > 405) AND (sec2 < 408))
(4 rows)

UPDATE o_test59 SET sec1 = 100 WHERE sec2 > 405 and sec2 < 408;
--SELECT orioledb_tbl_structure('o_test59'::regclass);
-- update primary index field
SELECT smart_explain(
'EXPLAIN (COSTS off) UPDATE o_test59 SET pri1 = 50 WHERE sec1 = 100;');
                smart_explain                 
----------------------------------------------
 Update on o_test59
   ->  Custom Scan (o_scan) on o_test59
         Forward index scan of: o_test59_reg1
         Conds: (sec1 = 100)
(4 rows)

UPDATE o_test59 SET pri1 = 50 WHERE sec1 = 100;
--SELECT orioledb_tbl_structure('o_test59'::regclass);
-- 1 ctid index + 2 non-unique indices
CREATE TABLE o_test61
(
	key int8 NOT NULL,
	value int8 NOT NULL
) USING orioledb;
CREATE INDEX o_test61_reg1 ON o_test61(key);
CREATE INDEX o_test61_reg2 ON o_test61(value);
SELECT orioledb_tbl_indices('o_test61'::regclass);
              orioledb_tbl_indices              
------------------------------------------------
 Index ctid_primary                            +
     Index type: primary, unique, ctid         +
     Leaf tuple size: 3, non-leaf tuple size: 1+
     Non-leaf tuple fields: ctid               +
 Index o_test61_reg1                           +
     Index type: secondary                     +
     Leaf tuple size: 2, non-leaf tuple size: 2+
     Non-leaf tuple fields: key, ctid          +
     Leaf tuple fields: key, ctid              +
 Index o_test61_reg2                           +
     Index type: secondary                     +
     Leaf tuple size: 2, non-leaf tuple size: 2+
     Non-leaf tuple fields: value, ctid        +
     Leaf tuple fields: value, ctid            +
 
(1 row)

INSERT INTO o_test61 SELECT 100 + i, 200 + i FROM generate_series(1, 100) AS i;
ANALYZE o_test61;
SET enable_seqscan = off;
EXPLAIN (COSTS off) SELECT * FROM o_test61 WHERE key BETWEEN 100 and 110;
                QUERY PLAN                
------------------------------------------
 Custom Scan (o_scan) on o_test61
   Forward index scan of: o_test61_reg1
   Conds: ((key >= 100) AND (key <= 110))
(3 rows)

SELECT * FROM o_test61 WHERE key BETWEEN 100 and 110;
 key | value 
-----+-------
 101 |   201
 102 |   202
 103 |   203
 104 |   204
 105 |   205
 106 |   206
 107 |   207
 108 |   208
 109 |   209
 110 |   210
(10 rows)

EXPLAIN (COSTS off) SELECT * FROM o_test61 WHERE value BETWEEN 250 and 260;
                  QUERY PLAN                  
----------------------------------------------
 Custom Scan (o_scan) on o_test61
   Forward index scan of: o_test61_reg2
   Conds: ((value >= 250) AND (value <= 260))
(3 rows)

SELECT * FROM o_test61 WHERE value BETWEEN 250 and 260;
 key | value 
-----+-------
 150 |   250
 151 |   251
 152 |   252
 153 |   253
 154 |   254
 155 |   255
 156 |   256
 157 |   257
 158 |   258
 159 |   259
 160 |   260
(11 rows)

RESET enable_seqscan;
EXPLAIN (COSTS off) SELECT count(*) FROM o_test61;
         QUERY PLAN         
----------------------------
 Aggregate
   ->  Seq Scan on o_test61
(2 rows)

SELECT count(*) FROM o_test61;
 count 
-------
   100
(1 row)

-- primary key - first field
-- secondary key - second field DESC
CREATE TABLE o_test65
(
	val text NOT NULL,
	id int8 NOT NULL,
	PRIMARY KEY(val)
) USING orioledb;
CREATE INDEX o_test65_reg1 ON o_test65(id DESC);
INSERT INTO o_test65 SELECT i+1, i FROM generate_series(1, 60) AS i;
SELECT count(*) FROM o_test65;
 count 
-------
    60
(1 row)

SELECT id, val FROM o_test65;
 id | val 
----+-----
  9 | 10
 10 | 11
 11 | 12
 12 | 13
 13 | 14
 14 | 15
 15 | 16
 16 | 17
 17 | 18
 18 | 19
  1 | 2
 19 | 20
 20 | 21
 21 | 22
 22 | 23
 23 | 24
 24 | 25
 25 | 26
 26 | 27
 27 | 28
 28 | 29
  2 | 3
 29 | 30
 30 | 31
 31 | 32
 32 | 33
 33 | 34
 34 | 35
 35 | 36
 36 | 37
 37 | 38
 38 | 39
  3 | 4
 39 | 40
 40 | 41
 41 | 42
 42 | 43
 43 | 44
 44 | 45
 45 | 46
 46 | 47
 47 | 48
 48 | 49
  4 | 5
 49 | 50
 50 | 51
 51 | 52
 52 | 53
 53 | 54
 54 | 55
 55 | 56
 56 | 57
 57 | 58
 58 | 59
  5 | 6
 59 | 60
 60 | 61
  6 | 7
  7 | 8
  8 | 9
(60 rows)

EXPLAIN (COSTS off) SELECT val, id FROM o_test65 ORDER BY id;
                  QUERY PLAN                  
----------------------------------------------
 Custom Scan (o_scan) on o_test65
   Backward index only scan of: o_test65_reg1
(2 rows)

SELECT val, id FROM o_test65 ORDER BY id;
 val | id 
-----+----
 2   |  1
 3   |  2
 4   |  3
 5   |  4
 6   |  5
 7   |  6
 8   |  7
 9   |  8
 10  |  9
 11  | 10
 12  | 11
 13  | 12
 14  | 13
 15  | 14
 16  | 15
 17  | 16
 18  | 17
 19  | 18
 20  | 19
 21  | 20
 22  | 21
 23  | 22
 24  | 23
 25  | 24
 26  | 25
 27  | 26
 28  | 27
 29  | 28
 30  | 29
 31  | 30
 32  | 31
 33  | 32
 34  | 33
 35  | 34
 36  | 35
 37  | 36
 38  | 37
 39  | 38
 40  | 39
 41  | 40
 42  | 41
 43  | 42
 44  | 43
 45  | 44
 46  | 45
 47  | 46
 48  | 47
 49  | 48
 50  | 49
 51  | 50
 52  | 51
 53  | 52
 54  | 53
 55  | 54
 56  | 55
 57  | 56
 58  | 57
 59  | 58
 60  | 59
 61  | 60
(60 rows)

EXPLAIN (COSTS off) SELECT id, val FROM o_test65 ORDER BY id;
                  QUERY PLAN                  
----------------------------------------------
 Custom Scan (o_scan) on o_test65
   Backward index only scan of: o_test65_reg1
(2 rows)

SELECT id, val FROM o_test65 ORDER BY id;
 id | val 
----+-----
  1 | 2
  2 | 3
  3 | 4
  4 | 5
  5 | 6
  6 | 7
  7 | 8
  8 | 9
  9 | 10
 10 | 11
 11 | 12
 12 | 13
 13 | 14
 14 | 15
 15 | 16
 16 | 17
 17 | 18
 18 | 19
 19 | 20
 20 | 21
 21 | 22
 22 | 23
 23 | 24
 24 | 25
 25 | 26
 26 | 27
 27 | 28
 28 | 29
 29 | 30
 30 | 31
 31 | 32
 32 | 33
 33 | 34
 34 | 35
 35 | 36
 36 | 37
 37 | 38
 38 | 39
 39 | 40
 40 | 41
 41 | 42
 42 | 43
 43 | 44
 44 | 45
 45 | 46
 46 | 47
 47 | 48
 48 | 49
 49 | 50
 50 | 51
 51 | 52
 52 | 53
 53 | 54
 54 | 55
 55 | 56
 56 | 57
 57 | 58
 58 | 59
 59 | 60
 60 | 61
(60 rows)

EXPLAIN (COSTS off) SELECT id, val FROM o_test65 ORDER BY id DESC;
                 QUERY PLAN                  
---------------------------------------------
 Custom Scan (o_scan) on o_test65
   Forward index only scan of: o_test65_reg1
(2 rows)

SELECT id, val FROM o_test65 ORDER BY id DESC;
 id | val 
----+-----
 60 | 61
 59 | 60
 58 | 59
 57 | 58
 56 | 57
 55 | 56
 54 | 55
 53 | 54
 52 | 53
 51 | 52
 50 | 51
 49 | 50
 48 | 49
 47 | 48
 46 | 47
 45 | 46
 44 | 45
 43 | 44
 42 | 43
 41 | 42
 40 | 41
 39 | 40
 38 | 39
 37 | 38
 36 | 37
 35 | 36
 34 | 35
 33 | 34
 32 | 33
 31 | 32
 30 | 31
 29 | 30
 28 | 29
 27 | 28
 26 | 27
 25 | 26
 24 | 25
 23 | 24
 22 | 23
 21 | 22
 20 | 21
 19 | 20
 18 | 19
 17 | 18
 16 | 17
 15 | 16
 14 | 15
 13 | 14
 12 | 13
 11 | 12
 10 | 11
  9 | 10
  8 | 9
  7 | 8
  6 | 7
  5 | 6
  4 | 5
  3 | 4
  2 | 3
  1 | 2
(60 rows)

EXPLAIN (COSTS off) SELECT id, val FROM o_test65 WHERE id = 30;
                 QUERY PLAN                  
---------------------------------------------
 Custom Scan (o_scan) on o_test65
   Forward index only scan of: o_test65_reg1
   Conds: (id = 30)
(3 rows)

SELECT id, val FROM o_test65 WHERE id = 30;
 id | val 
----+-----
 30 | 31
(1 row)

EXPLAIN (COSTS off) SELECT id, val FROM o_test65 WHERE id <= 30 AND id >= 1;
                 QUERY PLAN                  
---------------------------------------------
 Custom Scan (o_scan) on o_test65
   Forward index only scan of: o_test65_reg1
   Conds: ((id <= 30) AND (id >= 1))
(3 rows)

SELECT id, val FROM o_test65 WHERE id <= 30 AND id >= 1;
 id | val 
----+-----
 30 | 31
 29 | 30
 28 | 29
 27 | 28
 26 | 27
 25 | 26
 24 | 25
 23 | 24
 22 | 23
 21 | 22
 20 | 21
 19 | 20
 18 | 19
 17 | 18
 16 | 17
 15 | 16
 14 | 15
 13 | 14
 12 | 13
 11 | 12
 10 | 11
  9 | 10
  8 | 9
  7 | 8
  6 | 7
  5 | 6
  4 | 5
  3 | 4
  2 | 3
  1 | 2
(30 rows)

EXPLAIN (COSTS off) SELECT id, val FROM o_test65 WHERE id >= 30 AND id < 100;
                 QUERY PLAN                  
---------------------------------------------
 Custom Scan (o_scan) on o_test65
   Forward index only scan of: o_test65_reg1
   Conds: ((id >= 30) AND (id < 100))
(3 rows)

SELECT id, val FROM o_test65 WHERE id >= 30 AND id < 100;
 id | val 
----+-----
 60 | 61
 59 | 60
 58 | 59
 57 | 58
 56 | 57
 55 | 56
 54 | 55
 53 | 54
 52 | 53
 51 | 52
 50 | 51
 49 | 50
 48 | 49
 47 | 48
 46 | 47
 45 | 46
 44 | 45
 43 | 44
 42 | 43
 41 | 42
 40 | 41
 39 | 40
 38 | 39
 37 | 38
 36 | 37
 35 | 36
 34 | 35
 33 | 34
 32 | 33
 31 | 32
 30 | 31
(31 rows)

EXPLAIN (COSTS off) SELECT id, val FROM o_test65 WHERE id <= 30 AND id > 15;
                 QUERY PLAN                  
---------------------------------------------
 Custom Scan (o_scan) on o_test65
   Forward index only scan of: o_test65_reg1
   Conds: ((id <= 30) AND (id > 15))
(3 rows)

SELECT id, val FROM o_test65 WHERE id <= 30 AND id > 15;
 id | val 
----+-----
 30 | 31
 29 | 30
 28 | 29
 27 | 28
 26 | 27
 25 | 26
 24 | 25
 23 | 24
 22 | 23
 21 | 22
 20 | 21
 19 | 20
 18 | 19
 17 | 18
 16 | 17
(15 rows)

EXPLAIN (COSTS off) SELECT id, val FROM o_test65 WHERE id >= 30 AND id < 45;
                 QUERY PLAN                  
---------------------------------------------
 Custom Scan (o_scan) on o_test65
   Forward index only scan of: o_test65_reg1
   Conds: ((id >= 30) AND (id < 45))
(3 rows)

SELECT id, val FROM o_test65 WHERE id >= 30 AND id < 45;
 id | val 
----+-----
 44 | 45
 43 | 44
 42 | 43
 41 | 42
 40 | 41
 39 | 40
 38 | 39
 37 | 38
 36 | 37
 35 | 36
 34 | 35
 33 | 34
 32 | 33
 31 | 32
 30 | 31
(15 rows)

EXPLAIN (COSTS off) SELECT id, val FROM o_test65 WHERE id <= 30 OR id > 45;
             QUERY PLAN              
-------------------------------------
 Seq Scan on o_test65
   Filter: ((id <= 30) OR (id > 45))
(2 rows)

SELECT id, val FROM o_test65 WHERE id <= 30 OR id > 45;
 id | val 
----+-----
  9 | 10
 10 | 11
 11 | 12
 12 | 13
 13 | 14
 14 | 15
 15 | 16
 16 | 17
 17 | 18
 18 | 19
  1 | 2
 19 | 20
 20 | 21
 21 | 22
 22 | 23
 23 | 24
 24 | 25
 25 | 26
 26 | 27
 27 | 28
 28 | 29
  2 | 3
 29 | 30
 30 | 31
  3 | 4
 46 | 47
 47 | 48
 48 | 49
  4 | 5
 49 | 50
 50 | 51
 51 | 52
 52 | 53
 53 | 54
 54 | 55
 55 | 56
 56 | 57
 57 | 58
 58 | 59
  5 | 6
 59 | 60
 60 | 61
  6 | 7
  7 | 8
  8 | 9
(45 rows)

EXPLAIN (COSTS off) SELECT id, val FROM o_test65 WHERE id >= 30 OR id < 15;
             QUERY PLAN              
-------------------------------------
 Seq Scan on o_test65
   Filter: ((id >= 30) OR (id < 15))
(2 rows)

SELECT id, val FROM o_test65 WHERE id >= 30 OR id < 15;
 id | val 
----+-----
  9 | 10
 10 | 11
 11 | 12
 12 | 13
 13 | 14
 14 | 15
  1 | 2
  2 | 3
 30 | 31
 31 | 32
 32 | 33
 33 | 34
 34 | 35
 35 | 36
 36 | 37
 37 | 38
 38 | 39
  3 | 4
 39 | 40
 40 | 41
 41 | 42
 42 | 43
 43 | 44
 44 | 45
 45 | 46
 46 | 47
 47 | 48
 48 | 49
  4 | 5
 49 | 50
 50 | 51
 51 | 52
 52 | 53
 53 | 54
 54 | 55
 55 | 56
 56 | 57
 57 | 58
 58 | 59
  5 | 6
 59 | 60
 60 | 61
  6 | 7
  7 | 8
  8 | 9
(45 rows)

-- 2 fields secondary index
CREATE TABLE test66
(
	idi int4 NOT NULL,
	idv varchar NOT NULL,
	PRIMARY KEY (idi, idv)
);
INSERT INTO test66
	SELECT i, j::text||k
	FROM generate_series(1,3) as i,
	     generate_series(1,3) as j,
	     generate_series(1,3) as k
	WHERE (j+k)%4 <> 0;
CREATE TABLE o_test66
(
	idi int4 NOT NULL,
	idp int4 NOT NULL,
	idv varchar NOT NULL,
	PRIMARY KEY (idp)
) USING orioledb;
CREATE INDEX o_test66_reg1 ON o_test66(idi, idv);
INSERT INTO o_test66
	SELECT i, i * 100 + j * 10 + k, j::text||k
	FROM generate_series(1,3) as i,
	     generate_series(1,3) as j,
	     generate_series(1,3) as k;
ANALYZE o_test66;
SELECT count(*) FROM o_test66;
 count 
-------
    27
(1 row)

SELECT idi, idv FROM o_test66;
 idi | idv 
-----+-----
   1 | 11
   1 | 12
   1 | 13
   1 | 21
   1 | 22
   1 | 23
   1 | 31
   1 | 32
   1 | 33
   2 | 11
   2 | 12
   2 | 13
   2 | 21
   2 | 22
   2 | 23
   2 | 31
   2 | 32
   2 | 33
   3 | 11
   3 | 12
   3 | 13
   3 | 21
   3 | 22
   3 | 23
   3 | 31
   3 | 32
   3 | 33
(27 rows)

SET enable_seqscan = off;
EXPLAIN (COSTS off) SELECT idi, idv FROM o_test66 ORDER BY idi;
                 QUERY PLAN                  
---------------------------------------------
 Custom Scan (o_scan) on o_test66
   Forward index only scan of: o_test66_reg1
(2 rows)

SELECT idi, idv FROM o_test66 ORDER BY idi;
 idi | idv 
-----+-----
   1 | 11
   1 | 12
   1 | 13
   1 | 21
   1 | 22
   1 | 23
   1 | 31
   1 | 32
   1 | 33
   2 | 11
   2 | 12
   2 | 13
   2 | 21
   2 | 22
   2 | 23
   2 | 31
   2 | 32
   2 | 33
   3 | 11
   3 | 12
   3 | 13
   3 | 21
   3 | 22
   3 | 23
   3 | 31
   3 | 32
   3 | 33
(27 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test66 ORDER BY idi DESC;
                  QUERY PLAN                  
----------------------------------------------
 Custom Scan (o_scan) on o_test66
   Backward index only scan of: o_test66_reg1
(2 rows)

SELECT idi, idv FROM o_test66 ORDER BY idi DESC;
 idi | idv 
-----+-----
   3 | 33
   3 | 32
   3 | 31
   3 | 23
   3 | 22
   3 | 21
   3 | 13
   3 | 12
   3 | 11
   2 | 33
   2 | 32
   2 | 31
   2 | 23
   2 | 22
   2 | 21
   2 | 13
   2 | 12
   2 | 11
   1 | 33
   1 | 32
   1 | 31
   1 | 23
   1 | 22
   1 | 21
   1 | 13
   1 | 12
   1 | 11
(27 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test66 ORDER BY idi, idv;
                 QUERY PLAN                  
---------------------------------------------
 Custom Scan (o_scan) on o_test66
   Forward index only scan of: o_test66_reg1
(2 rows)

SELECT idi, idv FROM o_test66 ORDER BY idi, idv;
 idi | idv 
-----+-----
   1 | 11
   1 | 12
   1 | 13
   1 | 21
   1 | 22
   1 | 23
   1 | 31
   1 | 32
   1 | 33
   2 | 11
   2 | 12
   2 | 13
   2 | 21
   2 | 22
   2 | 23
   2 | 31
   2 | 32
   2 | 33
   3 | 11
   3 | 12
   3 | 13
   3 | 21
   3 | 22
   3 | 23
   3 | 31
   3 | 32
   3 | 33
(27 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test66 ORDER BY idi DESC, idv;
                     QUERY PLAN                     
----------------------------------------------------
 Sort
   Sort Key: idi DESC, idv
   ->  Custom Scan (o_scan) on o_test66
         Backward index only scan of: o_test66_reg1
(4 rows)

SELECT idi, idv FROM o_test66 ORDER BY idi DESC, idv;
 idi | idv 
-----+-----
   3 | 11
   3 | 12
   3 | 13
   3 | 21
   3 | 22
   3 | 23
   3 | 31
   3 | 32
   3 | 33
   2 | 11
   2 | 12
   2 | 13
   2 | 21
   2 | 22
   2 | 23
   2 | 31
   2 | 32
   2 | 33
   1 | 11
   1 | 12
   1 | 13
   1 | 21
   1 | 22
   1 | 23
   1 | 31
   1 | 32
   1 | 33
(27 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test66 ORDER BY idi, idv DESC;
                    QUERY PLAN                     
---------------------------------------------------
 Sort
   Sort Key: idi, idv DESC
   ->  Custom Scan (o_scan) on o_test66
         Forward index only scan of: o_test66_reg1
(4 rows)

SELECT idi, idv FROM o_test66 ORDER BY idi, idv DESC;
 idi | idv 
-----+-----
   1 | 33
   1 | 32
   1 | 31
   1 | 23
   1 | 22
   1 | 21
   1 | 13
   1 | 12
   1 | 11
   2 | 33
   2 | 32
   2 | 31
   2 | 23
   2 | 22
   2 | 21
   2 | 13
   2 | 12
   2 | 11
   3 | 33
   3 | 32
   3 | 31
   3 | 23
   3 | 22
   3 | 21
   3 | 13
   3 | 12
   3 | 11
(27 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test66 ORDER BY idi DESC, idv DESC;
                  QUERY PLAN                  
----------------------------------------------
 Custom Scan (o_scan) on o_test66
   Backward index only scan of: o_test66_reg1
(2 rows)

SELECT idi, idv FROM o_test66 ORDER BY idi DESC, idv DESC;
 idi | idv 
-----+-----
   3 | 33
   3 | 32
   3 | 31
   3 | 23
   3 | 22
   3 | 21
   3 | 13
   3 | 12
   3 | 11
   2 | 33
   2 | 32
   2 | 31
   2 | 23
   2 | 22
   2 | 21
   2 | 13
   2 | 12
   2 | 11
   1 | 33
   1 | 32
   1 | 31
   1 | 23
   1 | 22
   1 | 21
   1 | 13
   1 | 12
   1 | 11
(27 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test66 WHERE idi = 2;
                 QUERY PLAN                  
---------------------------------------------
 Custom Scan (o_scan) on o_test66
   Forward index only scan of: o_test66_reg1
   Conds: (idi = 2)
(3 rows)

SELECT idi, idv FROM o_test66 WHERE idi = 2;
 idi | idv 
-----+-----
   2 | 11
   2 | 12
   2 | 13
   2 | 21
   2 | 22
   2 | 23
   2 | 31
   2 | 32
   2 | 33
(9 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test66 WHERE idv = '22';
                 QUERY PLAN                  
---------------------------------------------
 Custom Scan (o_scan) on o_test66
   Forward index only scan of: o_test66_reg1
   Conds: (idv = '22'::text)
(3 rows)

SELECT idi, idv FROM o_test66 WHERE idv = '22';
 idi | idv 
-----+-----
   1 | 22
   2 | 22
   3 | 22
(3 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test66 WHERE idi = 2 AND idv = '22';
                 QUERY PLAN                  
---------------------------------------------
 Custom Scan (o_scan) on o_test66
   Forward index only scan of: o_test66_reg1
   Conds: ((idi = 2) AND (idv = '22'::text))
(3 rows)

SELECT idi, idv FROM o_test66 WHERE idi = 2 AND idv = '22';
 idi | idv 
-----+-----
   2 | 22
(1 row)

-- Test Result node processing
EXPLAIN (COSTS off) SELECT idi, idv FROM o_test66 WHERE idi = 2 AND idi = 1;
                    QUERY PLAN                     
---------------------------------------------------
 Result
   One-Time Filter: false
   ->  Custom Scan (o_scan) on o_test66
         Forward index only scan of: o_test66_reg1
         Conds: (idi = 2)
(5 rows)

SELECT idi, idv FROM o_test66 WHERE idi = 2 AND idi = 1;
 idi | idv 
-----+-----
(0 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test66 WHERE idi = 2 AND idv > '22';
                 QUERY PLAN                  
---------------------------------------------
 Custom Scan (o_scan) on o_test66
   Forward index only scan of: o_test66_reg1
   Conds: ((idi = 2) AND (idv > '22'::text))
(3 rows)

SELECT idi, idv FROM o_test66 WHERE idi = 2 AND idv > '22';
 idi | idv 
-----+-----
   2 | 23
   2 | 31
   2 | 32
   2 | 33
(4 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test66 WHERE idi = 2 AND idv < '22';
                 QUERY PLAN                  
---------------------------------------------
 Custom Scan (o_scan) on o_test66
   Forward index only scan of: o_test66_reg1
   Conds: ((idi = 2) AND (idv < '22'::text))
(3 rows)

SELECT idi, idv FROM o_test66 WHERE idi = 2 AND idv < '22';
 idi | idv 
-----+-----
   2 | 11
   2 | 12
   2 | 13
   2 | 21
(4 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test66 WHERE idi = 2 AND idv >= '22';
                  QUERY PLAN                  
----------------------------------------------
 Custom Scan (o_scan) on o_test66
   Forward index only scan of: o_test66_reg1
   Conds: ((idi = 2) AND (idv >= '22'::text))
(3 rows)

SELECT idi, idv FROM o_test66 WHERE idi = 2 AND idv >= '22';
 idi | idv 
-----+-----
   2 | 22
   2 | 23
   2 | 31
   2 | 32
   2 | 33
(5 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test66 WHERE idi = 2 AND idv <= '22';
                  QUERY PLAN                  
----------------------------------------------
 Custom Scan (o_scan) on o_test66
   Forward index only scan of: o_test66_reg1
   Conds: ((idi = 2) AND (idv <= '22'::text))
(3 rows)

SELECT idi, idv FROM o_test66 WHERE idi = 2 AND idv <= '22';
 idi | idv 
-----+-----
   2 | 11
   2 | 12
   2 | 13
   2 | 21
   2 | 22
(5 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test66 WHERE idi = 2 AND idv >= '12' AND idv <= '22';
                              QUERY PLAN                              
----------------------------------------------------------------------
 Custom Scan (o_scan) on o_test66
   Forward index only scan of: o_test66_reg1
   Conds: ((idi = 2) AND (idv >= '12'::text) AND (idv <= '22'::text))
(3 rows)

SELECT idi, idv FROM o_test66 WHERE idi = 2 AND idv >= '12' AND idv <= '22';
 idi | idv 
-----+-----
   2 | 12
   2 | 13
   2 | 21
   2 | 22
(4 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test66 WHERE idi = 2 AND idv > '12' AND idv <= '22';
                             QUERY PLAN                              
---------------------------------------------------------------------
 Custom Scan (o_scan) on o_test66
   Forward index only scan of: o_test66_reg1
   Conds: ((idi = 2) AND (idv > '12'::text) AND (idv <= '22'::text))
(3 rows)

SELECT idi, idv FROM o_test66 WHERE idi = 2 AND idv > '12' AND idv <= '22';
 idi | idv 
-----+-----
   2 | 13
   2 | 21
   2 | 22
(3 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test66 WHERE idi = 2 AND idv >= '12' AND idv < '22';
                             QUERY PLAN                              
---------------------------------------------------------------------
 Custom Scan (o_scan) on o_test66
   Forward index only scan of: o_test66_reg1
   Conds: ((idi = 2) AND (idv >= '12'::text) AND (idv < '22'::text))
(3 rows)

SELECT idi, idv FROM o_test66 WHERE idi = 2 AND idv >= '12' AND idv < '22';
 idi | idv 
-----+-----
   2 | 12
   2 | 13
   2 | 21
(3 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test66 WHERE idi = 2 AND idv > '12' AND idv < '22';
                             QUERY PLAN                             
--------------------------------------------------------------------
 Custom Scan (o_scan) on o_test66
   Forward index only scan of: o_test66_reg1
   Conds: ((idi = 2) AND (idv > '12'::text) AND (idv < '22'::text))
(3 rows)

SELECT idi, idv FROM o_test66 WHERE idi = 2 AND idv > '12' AND idv < '22';
 idi | idv 
-----+-----
   2 | 13
   2 | 21
(2 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test66 WHERE idi = 2 AND (idv <= '12' OR idv >= '22');
                               QUERY PLAN                               
------------------------------------------------------------------------
 Custom Scan (o_scan) on o_test66
   Filter: (((idv)::text <= '12'::text) OR ((idv)::text >= '22'::text))
   Forward index only scan of: o_test66_reg1
   Conds: (idi = 2)
(4 rows)

SELECT idi, idv FROM o_test66 WHERE idi = 2 AND (idv <= '12' OR idv >= '22');
 idi | idv 
-----+-----
   2 | 11
   2 | 12
   2 | 22
   2 | 23
   2 | 31
   2 | 32
   2 | 33
(7 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test66 WHERE idi = 2 AND (idv < '12' OR idv >= '22');
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Custom Scan (o_scan) on o_test66
   Filter: (((idv)::text < '12'::text) OR ((idv)::text >= '22'::text))
   Forward index only scan of: o_test66_reg1
   Conds: (idi = 2)
(4 rows)

SELECT idi, idv FROM o_test66 WHERE idi = 2 AND (idv < '12' OR idv >= '22');
 idi | idv 
-----+-----
   2 | 11
   2 | 22
   2 | 23
   2 | 31
   2 | 32
   2 | 33
(6 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test66 WHERE idi = 2 AND (idv <= '12' OR idv > '22');
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Custom Scan (o_scan) on o_test66
   Filter: (((idv)::text <= '12'::text) OR ((idv)::text > '22'::text))
   Forward index only scan of: o_test66_reg1
   Conds: (idi = 2)
(4 rows)

SELECT idi, idv FROM o_test66 WHERE idi = 2 AND (idv <= '12' OR idv > '22');
 idi | idv 
-----+-----
   2 | 11
   2 | 12
   2 | 23
   2 | 31
   2 | 32
   2 | 33
(6 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test66 WHERE idi = 2 AND (idv < '12' OR idv > '22');
                              QUERY PLAN                              
----------------------------------------------------------------------
 Custom Scan (o_scan) on o_test66
   Filter: (((idv)::text < '12'::text) OR ((idv)::text > '22'::text))
   Forward index only scan of: o_test66_reg1
   Conds: (idi = 2)
(4 rows)

SELECT idi, idv FROM o_test66 WHERE idi = 2 AND (idv < '12' OR idv > '22');
 idi | idv 
-----+-----
   2 | 11
   2 | 23
   2 | 31
   2 | 32
   2 | 33
(5 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test66 WHERE idi = 2 AND (idv < '12' AND idv > '22');
                             QUERY PLAN                             
--------------------------------------------------------------------
 Custom Scan (o_scan) on o_test66
   Forward index only scan of: o_test66_reg1
   Conds: ((idi = 2) AND (idv < '12'::text) AND (idv > '22'::text))
(3 rows)

SELECT idi, idv FROM o_test66 WHERE idi = 2 AND (idv < '12' AND idv > '22');
 idi | idv 
-----+-----
(0 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test66 WHERE idi = 2 AND idv IN ('12', '22');
                        QUERY PLAN                        
----------------------------------------------------------
 Custom Scan (o_scan) on o_test66
   Forward index only scan of: o_test66_reg1
   Conds: ((idi = 2) AND (idv = ANY ('{12,22}'::text[])))
(3 rows)

SELECT idi, idv FROM o_test66 WHERE idi = 2 AND idv IN ('12', '22');
 idi | idv 
-----+-----
   2 | 12
   2 | 22
(2 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test66 WHERE idi IN (2, 4) AND idv IN ('12', '22');
                    QUERY PLAN                     
---------------------------------------------------
 Custom Scan (o_scan) on o_test66
   Filter: ((idv)::text = ANY ('{12,22}'::text[]))
   Forward index only scan of: o_test66_reg1
   Conds: (idi = ANY ('{2,4}'::integer[]))
(4 rows)

SELECT idi, idv FROM o_test66 WHERE idi IN (2, 4) AND idv IN ('12', '22');
 idi | idv 
-----+-----
   2 | 12
   2 | 22
(2 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test66 WHERE (idi = 2 AND idv = '12') OR (idi = 4 AND idv = '2_3');
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Custom Scan (o_scan) on o_test66
   Filter: (((idi = 2) AND ((idv)::text = '12'::text)) OR ((idi = 4) AND ((idv)::text = '2_3'::text)))
   Forward index only scan of: o_test66_reg1
(3 rows)

SELECT idi, idv FROM o_test66 WHERE (idi = 2 AND idv = '12') OR (idi = 4 AND idv = '2_3');
 idi | idv 
-----+-----
   2 | 12
(1 row)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test66 WHERE idi > 1 AND
														idi < 100 AND
														idv < '22';
                         QUERY PLAN                          
-------------------------------------------------------------
 Custom Scan (o_scan) on o_test66
   Forward index only scan of: o_test66_reg1
   Conds: ((idi > 1) AND (idi < 100) AND (idv < '22'::text))
(3 rows)

SELECT idi, idv FROM o_test66 WHERE idi > 1 AND
									idi < 100 AND
									idv < '22';
 idi | idv 
-----+-----
   2 | 11
   2 | 12
   2 | 13
   2 | 21
   3 | 11
   3 | 12
   3 | 13
   3 | 21
(8 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test66 WHERE idi > 1 AND
									idi < 100 AND
									idv > '22';
                         QUERY PLAN                          
-------------------------------------------------------------
 Custom Scan (o_scan) on o_test66
   Forward index only scan of: o_test66_reg1
   Conds: ((idi > 1) AND (idi < 100) AND (idv > '22'::text))
(3 rows)

SELECT idi, idv FROM o_test66 WHERE idi > 1 AND
									idi < 100 AND
									idv > '22';
 idi | idv 
-----+-----
   2 | 23
   2 | 31
   2 | 32
   2 | 33
   3 | 23
   3 | 31
   3 | 32
   3 | 33
(8 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test66 WHERE idi > 1 AND idv = '22';
                 QUERY PLAN                  
---------------------------------------------
 Custom Scan (o_scan) on o_test66
   Forward index only scan of: o_test66_reg1
   Conds: ((idi > 1) AND (idv = '22'::text))
(3 rows)

SELECT idi, idv FROM o_test66 WHERE idi > 1 AND idv = '22';
 idi | idv 
-----+-----
   2 | 22
   3 | 22
(2 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test66 WHERE idi < 3 AND
									idi > 0 AND
									idv < '22';
                        QUERY PLAN                         
-----------------------------------------------------------
 Custom Scan (o_scan) on o_test66
   Forward index only scan of: o_test66_reg1
   Conds: ((idi < 3) AND (idi > 0) AND (idv < '22'::text))
(3 rows)

SELECT idi, idv FROM o_test66 WHERE idi < 3 AND
									idi > 0 AND
									idv < '22';
 idi | idv 
-----+-----
   1 | 11
   1 | 12
   1 | 13
   1 | 21
   2 | 11
   2 | 12
   2 | 13
   2 | 21
(8 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test66 WHERE idi < 3 AND
									idi > 0 AND
									idv > '22';
                        QUERY PLAN                         
-----------------------------------------------------------
 Custom Scan (o_scan) on o_test66
   Forward index only scan of: o_test66_reg1
   Conds: ((idi < 3) AND (idi > 0) AND (idv > '22'::text))
(3 rows)

SELECT idi, idv FROM o_test66 WHERE idi < 3  AND
									idi > 0 AND
									idv > '22';
 idi | idv 
-----+-----
   1 | 23
   1 | 31
   1 | 32
   1 | 33
   2 | 23
   2 | 31
   2 | 32
   2 | 33
(8 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test66 WHERE idi < 3 AND idv = '22';
                 QUERY PLAN                  
---------------------------------------------
 Custom Scan (o_scan) on o_test66
   Forward index only scan of: o_test66_reg1
   Conds: ((idi < 3) AND (idv = '22'::text))
(3 rows)

SELECT idi, idv FROM o_test66 WHERE idi < 3 AND idv = '22';
 idi | idv 
-----+-----
   1 | 22
   2 | 22
(2 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test66 WHERE idi > 1 AND idv IN ('12', '22');
                    QUERY PLAN                     
---------------------------------------------------
 Custom Scan (o_scan) on o_test66
   Filter: ((idv)::text = ANY ('{12,22}'::text[]))
   Forward index only scan of: o_test66_reg1
   Conds: (idi > 1)
(4 rows)

SELECT idi, idv FROM o_test66 WHERE idi > 1 AND idv IN ('12', '22');
 idi | idv 
-----+-----
   2 | 12
   2 | 22
   3 | 12
   3 | 22
(4 rows)

RESET enable_seqscan;
EXPLAIN (COSTS off) SELECT * FROM test66 JOIN o_test66 USING(idi, idv);
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Hash Join
   Hash Cond: ((test66.idi = o_test66.idi) AND ((test66.idv)::text = (o_test66.idv)::text))
   ->  Seq Scan on test66
   ->  Hash
         ->  Seq Scan on o_test66
(5 rows)

SELECT * FROM test66 JOIN o_test66 USING(idi, idv);
 idi | idv | idp 
-----+-----+-----
   1 | 11  | 111
   1 | 12  | 112
   1 | 21  | 121
   1 | 23  | 123
   1 | 32  | 132
   1 | 33  | 133
   2 | 11  | 211
   2 | 12  | 212
   2 | 21  | 221
   2 | 23  | 223
   2 | 32  | 232
   2 | 33  | 233
   3 | 11  | 311
   3 | 12  | 312
   3 | 21  | 321
   3 | 23  | 323
   3 | 32  | 332
   3 | 33  | 333
(18 rows)

set enable_nestloop=off;
EXPLAIN (COSTS off) SELECT * FROM test66 JOIN o_test66 USING(idi, idv);
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Hash Join
   Hash Cond: ((test66.idi = o_test66.idi) AND ((test66.idv)::text = (o_test66.idv)::text))
   ->  Seq Scan on test66
   ->  Hash
         ->  Seq Scan on o_test66
(5 rows)

SELECT * FROM test66 JOIN o_test66 USING(idi, idv);
 idi | idv | idp 
-----+-----+-----
   1 | 11  | 111
   1 | 12  | 112
   1 | 21  | 121
   1 | 23  | 123
   1 | 32  | 132
   1 | 33  | 133
   2 | 11  | 211
   2 | 12  | 212
   2 | 21  | 221
   2 | 23  | 223
   2 | 32  | 232
   2 | 33  | 233
   3 | 11  | 311
   3 | 12  | 312
   3 | 21  | 321
   3 | 23  | 323
   3 | 32  | 332
   3 | 33  | 333
(18 rows)

set enable_hashjoin=off;
EXPLAIN (COSTS off) SELECT * FROM test66 JOIN o_test66 USING(idi, idv);
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Merge Join
   Merge Cond: ((test66.idi = o_test66.idi) AND ((test66.idv)::text = (o_test66.idv)::text))
   ->  Index Only Scan using test66_pkey on test66
   ->  Sort
         Sort Key: o_test66.idi, o_test66.idv
         ->  Seq Scan on o_test66
(6 rows)

SELECT * FROM test66 JOIN o_test66 USING(idi, idv);
 idi | idv | idp 
-----+-----+-----
   1 | 11  | 111
   1 | 12  | 112
   1 | 21  | 121
   1 | 23  | 123
   1 | 32  | 132
   1 | 33  | 133
   2 | 11  | 211
   2 | 12  | 212
   2 | 21  | 221
   2 | 23  | 223
   2 | 32  | 232
   2 | 33  | 233
   3 | 11  | 311
   3 | 12  | 312
   3 | 21  | 321
   3 | 23  | 323
   3 | 32  | 332
   3 | 33  | 333
(18 rows)

set enable_nestloop=on;
set enable_hashjoin=on;
-- 2 field secondary index with second field desc
CREATE TABLE o_test67
(
	idi int4 NOT NULL,
	idp int4 NOT NULL,
	idv varchar NOT NULL,
	PRIMARY KEY (idp)
) USING orioledb;
CREATE INDEX o_test67_reg1 ON o_test67(idi, idv DESC);
INSERT INTO o_test67
	SELECT i, i * 100 + j * 10 + k, j::text||k
	FROM generate_series(1,3) as i,
	     generate_series(1,3) as j,
	     generate_series(1,3) as k;
ANALYZE o_test67;
SELECT count(*) FROM o_test67;
 count 
-------
    27
(1 row)

SELECT idi, idv FROM o_test67;
 idi | idv 
-----+-----
   1 | 11
   1 | 12
   1 | 13
   1 | 21
   1 | 22
   1 | 23
   1 | 31
   1 | 32
   1 | 33
   2 | 11
   2 | 12
   2 | 13
   2 | 21
   2 | 22
   2 | 23
   2 | 31
   2 | 32
   2 | 33
   3 | 11
   3 | 12
   3 | 13
   3 | 21
   3 | 22
   3 | 23
   3 | 31
   3 | 32
   3 | 33
(27 rows)

SET enable_seqscan = off;
EXPLAIN (COSTS off) SELECT idi, idv FROM o_test67 ORDER BY idi;
                 QUERY PLAN                  
---------------------------------------------
 Custom Scan (o_scan) on o_test67
   Forward index only scan of: o_test67_reg1
(2 rows)

SELECT idi, idv FROM o_test67 ORDER BY idi;
 idi | idv 
-----+-----
   1 | 33
   1 | 32
   1 | 31
   1 | 23
   1 | 22
   1 | 21
   1 | 13
   1 | 12
   1 | 11
   2 | 33
   2 | 32
   2 | 31
   2 | 23
   2 | 22
   2 | 21
   2 | 13
   2 | 12
   2 | 11
   3 | 33
   3 | 32
   3 | 31
   3 | 23
   3 | 22
   3 | 21
   3 | 13
   3 | 12
   3 | 11
(27 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test67 ORDER BY idi DESC;
                  QUERY PLAN                  
----------------------------------------------
 Custom Scan (o_scan) on o_test67
   Backward index only scan of: o_test67_reg1
(2 rows)

SELECT idi, idv FROM o_test67 ORDER BY idi DESC;
 idi | idv 
-----+-----
   3 | 11
   3 | 12
   3 | 13
   3 | 21
   3 | 22
   3 | 23
   3 | 31
   3 | 32
   3 | 33
   2 | 11
   2 | 12
   2 | 13
   2 | 21
   2 | 22
   2 | 23
   2 | 31
   2 | 32
   2 | 33
   1 | 11
   1 | 12
   1 | 13
   1 | 21
   1 | 22
   1 | 23
   1 | 31
   1 | 32
   1 | 33
(27 rows)

RESET enable_seqscan;
EXPLAIN (COSTS off) SELECT idi, idv FROM o_test67 ORDER BY idi, idv;
         QUERY PLAN         
----------------------------
 Sort
   Sort Key: idi, idv
   ->  Seq Scan on o_test67
(3 rows)

SELECT idi, idv FROM o_test67 ORDER BY idi, idv;
 idi | idv 
-----+-----
   1 | 11
   1 | 12
   1 | 13
   1 | 21
   1 | 22
   1 | 23
   1 | 31
   1 | 32
   1 | 33
   2 | 11
   2 | 12
   2 | 13
   2 | 21
   2 | 22
   2 | 23
   2 | 31
   2 | 32
   2 | 33
   3 | 11
   3 | 12
   3 | 13
   3 | 21
   3 | 22
   3 | 23
   3 | 31
   3 | 32
   3 | 33
(27 rows)

SET enable_seqscan = off;
EXPLAIN (COSTS off) SELECT idi, idv FROM o_test67 ORDER BY idi DESC, idv;
                  QUERY PLAN                  
----------------------------------------------
 Custom Scan (o_scan) on o_test67
   Backward index only scan of: o_test67_reg1
(2 rows)

SELECT idi, idv FROM o_test67 ORDER BY idi DESC, idv;
 idi | idv 
-----+-----
   3 | 11
   3 | 12
   3 | 13
   3 | 21
   3 | 22
   3 | 23
   3 | 31
   3 | 32
   3 | 33
   2 | 11
   2 | 12
   2 | 13
   2 | 21
   2 | 22
   2 | 23
   2 | 31
   2 | 32
   2 | 33
   1 | 11
   1 | 12
   1 | 13
   1 | 21
   1 | 22
   1 | 23
   1 | 31
   1 | 32
   1 | 33
(27 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test67 ORDER BY idi, idv DESC;
                 QUERY PLAN                  
---------------------------------------------
 Custom Scan (o_scan) on o_test67
   Forward index only scan of: o_test67_reg1
(2 rows)

SELECT idi, idv FROM o_test67 ORDER BY idi, idv DESC;
 idi | idv 
-----+-----
   1 | 33
   1 | 32
   1 | 31
   1 | 23
   1 | 22
   1 | 21
   1 | 13
   1 | 12
   1 | 11
   2 | 33
   2 | 32
   2 | 31
   2 | 23
   2 | 22
   2 | 21
   2 | 13
   2 | 12
   2 | 11
   3 | 33
   3 | 32
   3 | 31
   3 | 23
   3 | 22
   3 | 21
   3 | 13
   3 | 12
   3 | 11
(27 rows)

RESET enable_seqscan;
EXPLAIN (COSTS off) SELECT idi, idv FROM o_test67 ORDER BY idi DESC, idv DESC;
           QUERY PLAN           
--------------------------------
 Sort
   Sort Key: idi DESC, idv DESC
   ->  Seq Scan on o_test67
(3 rows)

SELECT idi, idv FROM o_test67 ORDER BY idi DESC, idv DESC;
 idi | idv 
-----+-----
   3 | 33
   3 | 32
   3 | 31
   3 | 23
   3 | 22
   3 | 21
   3 | 13
   3 | 12
   3 | 11
   2 | 33
   2 | 32
   2 | 31
   2 | 23
   2 | 22
   2 | 21
   2 | 13
   2 | 12
   2 | 11
   1 | 33
   1 | 32
   1 | 31
   1 | 23
   1 | 22
   1 | 21
   1 | 13
   1 | 12
   1 | 11
(27 rows)

SET enable_seqscan = off;
EXPLAIN (COSTS off) SELECT idi, idv FROM o_test67 WHERE idi = 2;
                 QUERY PLAN                  
---------------------------------------------
 Custom Scan (o_scan) on o_test67
   Forward index only scan of: o_test67_reg1
   Conds: (idi = 2)
(3 rows)

SELECT idi, idv FROM o_test67 WHERE idi = 2;
 idi | idv 
-----+-----
   2 | 33
   2 | 32
   2 | 31
   2 | 23
   2 | 22
   2 | 21
   2 | 13
   2 | 12
   2 | 11
(9 rows)

RESET enable_seqscan;
EXPLAIN (COSTS off) SELECT idi, idv FROM o_test67 WHERE idv = '22';
              QUERY PLAN              
--------------------------------------
 Seq Scan on o_test67
   Filter: ((idv)::text = '22'::text)
(2 rows)

SELECT idi, idv FROM o_test67 WHERE idv = '22';
 idi | idv 
-----+-----
   1 | 22
   2 | 22
   3 | 22
(3 rows)

SET enable_seqscan = off;
EXPLAIN (COSTS off) SELECT idi, idv FROM o_test67 WHERE idi = 2 AND idv = '22';
                 QUERY PLAN                  
---------------------------------------------
 Custom Scan (o_scan) on o_test67
   Forward index only scan of: o_test67_reg1
   Conds: ((idi = 2) AND (idv = '22'::text))
(3 rows)

SELECT idi, idv FROM o_test67 WHERE idi = 2 AND idv = '22';
 idi | idv 
-----+-----
   2 | 22
(1 row)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test67 WHERE idi = 2 AND idv > '22';
                 QUERY PLAN                  
---------------------------------------------
 Custom Scan (o_scan) on o_test67
   Forward index only scan of: o_test67_reg1
   Conds: ((idi = 2) AND (idv > '22'::text))
(3 rows)

SELECT idi, idv FROM o_test67 WHERE idi = 2 AND idv > '22';
 idi | idv 
-----+-----
   2 | 33
   2 | 32
   2 | 31
   2 | 23
(4 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test67 WHERE idi = 2 AND idv < '22';
                 QUERY PLAN                  
---------------------------------------------
 Custom Scan (o_scan) on o_test67
   Forward index only scan of: o_test67_reg1
   Conds: ((idi = 2) AND (idv < '22'::text))
(3 rows)

SELECT idi, idv FROM o_test67 WHERE idi = 2 AND idv < '22';
 idi | idv 
-----+-----
   2 | 21
   2 | 13
   2 | 12
   2 | 11
(4 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test67 WHERE idi = 2 AND idv >= '22';
                  QUERY PLAN                  
----------------------------------------------
 Custom Scan (o_scan) on o_test67
   Forward index only scan of: o_test67_reg1
   Conds: ((idi = 2) AND (idv >= '22'::text))
(3 rows)

SELECT idi, idv FROM o_test67 WHERE idi = 2 AND idv >= '22';
 idi | idv 
-----+-----
   2 | 33
   2 | 32
   2 | 31
   2 | 23
   2 | 22
(5 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test67 WHERE idi = 2 AND idv <= '22';
                  QUERY PLAN                  
----------------------------------------------
 Custom Scan (o_scan) on o_test67
   Forward index only scan of: o_test67_reg1
   Conds: ((idi = 2) AND (idv <= '22'::text))
(3 rows)

SELECT idi, idv FROM o_test67 WHERE idi = 2 AND idv <= '22';
 idi | idv 
-----+-----
   2 | 22
   2 | 21
   2 | 13
   2 | 12
   2 | 11
(5 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test67 WHERE idi = 2 AND idv >= '12' AND idv <= '22';
                              QUERY PLAN                              
----------------------------------------------------------------------
 Custom Scan (o_scan) on o_test67
   Forward index only scan of: o_test67_reg1
   Conds: ((idi = 2) AND (idv >= '12'::text) AND (idv <= '22'::text))
(3 rows)

SELECT idi, idv FROM o_test67 WHERE idi = 2 AND idv >= '12' AND idv <= '22';
 idi | idv 
-----+-----
   2 | 22
   2 | 21
   2 | 13
   2 | 12
(4 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test67 WHERE idi = 2 AND idv > '12' AND idv <= '22';
                             QUERY PLAN                              
---------------------------------------------------------------------
 Custom Scan (o_scan) on o_test67
   Forward index only scan of: o_test67_reg1
   Conds: ((idi = 2) AND (idv > '12'::text) AND (idv <= '22'::text))
(3 rows)

SELECT idi, idv FROM o_test67 WHERE idi = 2 AND idv > '12' AND idv <= '22';
 idi | idv 
-----+-----
   2 | 22
   2 | 21
   2 | 13
(3 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test67 WHERE idi = 2 AND idv >= '12' AND idv < '22';
                             QUERY PLAN                              
---------------------------------------------------------------------
 Custom Scan (o_scan) on o_test67
   Forward index only scan of: o_test67_reg1
   Conds: ((idi = 2) AND (idv >= '12'::text) AND (idv < '22'::text))
(3 rows)

SELECT idi, idv FROM o_test67 WHERE idi = 2 AND idv >= '12' AND idv < '22';
 idi | idv 
-----+-----
   2 | 21
   2 | 13
   2 | 12
(3 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test67 WHERE idi = 2 AND idv > '12' AND idv < '22';
                             QUERY PLAN                             
--------------------------------------------------------------------
 Custom Scan (o_scan) on o_test67
   Forward index only scan of: o_test67_reg1
   Conds: ((idi = 2) AND (idv > '12'::text) AND (idv < '22'::text))
(3 rows)

SELECT idi, idv FROM o_test67 WHERE idi = 2 AND idv > '12' AND idv < '22';
 idi | idv 
-----+-----
   2 | 21
   2 | 13
(2 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test67 WHERE idi = 2 AND (idv <= '12' OR idv >= '22');
                               QUERY PLAN                               
------------------------------------------------------------------------
 Custom Scan (o_scan) on o_test67
   Filter: (((idv)::text <= '12'::text) OR ((idv)::text >= '22'::text))
   Forward index only scan of: o_test67_reg1
   Conds: (idi = 2)
(4 rows)

SELECT idi, idv FROM o_test67 WHERE idi = 2 AND (idv <= '12' OR idv >= '22');
 idi | idv 
-----+-----
   2 | 33
   2 | 32
   2 | 31
   2 | 23
   2 | 22
   2 | 12
   2 | 11
(7 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test67 WHERE idi = 2 AND (idv < '12' OR idv >= '22');
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Custom Scan (o_scan) on o_test67
   Filter: (((idv)::text < '12'::text) OR ((idv)::text >= '22'::text))
   Forward index only scan of: o_test67_reg1
   Conds: (idi = 2)
(4 rows)

SELECT idi, idv FROM o_test67 WHERE idi = 2 AND (idv < '12' OR idv >= '22');
 idi | idv 
-----+-----
   2 | 33
   2 | 32
   2 | 31
   2 | 23
   2 | 22
   2 | 11
(6 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test67 WHERE idi = 2 AND (idv <= '12' OR idv > '22');
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Custom Scan (o_scan) on o_test67
   Filter: (((idv)::text <= '12'::text) OR ((idv)::text > '22'::text))
   Forward index only scan of: o_test67_reg1
   Conds: (idi = 2)
(4 rows)

SELECT idi, idv FROM o_test67 WHERE idi = 2 AND (idv <= '12' OR idv > '22');
 idi | idv 
-----+-----
   2 | 33
   2 | 32
   2 | 31
   2 | 23
   2 | 12
   2 | 11
(6 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test67 WHERE idi = 2 AND (idv < '12' OR idv > '22');
                              QUERY PLAN                              
----------------------------------------------------------------------
 Custom Scan (o_scan) on o_test67
   Filter: (((idv)::text < '12'::text) OR ((idv)::text > '22'::text))
   Forward index only scan of: o_test67_reg1
   Conds: (idi = 2)
(4 rows)

SELECT idi, idv FROM o_test67 WHERE idi = 2 AND (idv < '12' OR idv > '22');
 idi | idv 
-----+-----
   2 | 33
   2 | 32
   2 | 31
   2 | 23
   2 | 11
(5 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test67 WHERE idi = 2 AND (idv < '12' AND idv > '22');
                             QUERY PLAN                             
--------------------------------------------------------------------
 Custom Scan (o_scan) on o_test67
   Forward index only scan of: o_test67_reg1
   Conds: ((idi = 2) AND (idv < '12'::text) AND (idv > '22'::text))
(3 rows)

SELECT idi, idv FROM o_test67 WHERE idi = 2 AND (idv < '12' AND idv > '22');
 idi | idv 
-----+-----
(0 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test67 WHERE idi = 2 AND idv IN ('12', '22');
                        QUERY PLAN                        
----------------------------------------------------------
 Custom Scan (o_scan) on o_test67
   Forward index only scan of: o_test67_reg1
   Conds: ((idi = 2) AND (idv = ANY ('{12,22}'::text[])))
(3 rows)

SELECT idi, idv FROM o_test67 WHERE idi = 2 AND idv IN ('12', '22');
 idi | idv 
-----+-----
   2 | 22
   2 | 12
(2 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test67 WHERE idi IN (2, 4) AND idv IN ('12', '22');
                    QUERY PLAN                     
---------------------------------------------------
 Custom Scan (o_scan) on o_test67
   Filter: ((idv)::text = ANY ('{12,22}'::text[]))
   Forward index only scan of: o_test67_reg1
   Conds: (idi = ANY ('{2,4}'::integer[]))
(4 rows)

SELECT idi, idv FROM o_test67 WHERE idi IN (2, 4) AND idv IN ('12', '22');
 idi | idv 
-----+-----
   2 | 22
   2 | 12
(2 rows)

RESET enable_seqscan;
EXPLAIN (COSTS off) SELECT idi, idv FROM o_test67 WHERE (idi = 2 AND idv = '12') OR (idi = 4 AND idv = '2_3');
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Seq Scan on o_test67
   Filter: (((idi = 2) AND ((idv)::text = '12'::text)) OR ((idi = 4) AND ((idv)::text = '2_3'::text)))
(2 rows)

SELECT idi, idv FROM o_test67 WHERE (idi = 2 AND idv = '12') OR (idi = 4 AND idv = '2_3');
 idi | idv 
-----+-----
   2 | 12
(1 row)

SET enable_seqscan = off;
EXPLAIN (COSTS off) SELECT idi, idv FROM o_test67 WHERE idi > 1 AND
														idi < 100 AND
														idv < '22';
                         QUERY PLAN                          
-------------------------------------------------------------
 Custom Scan (o_scan) on o_test67
   Forward index only scan of: o_test67_reg1
   Conds: ((idi > 1) AND (idi < 100) AND (idv < '22'::text))
(3 rows)

SELECT idi, idv FROM o_test67 WHERE idi > 1 AND idi < 100 AND idv < '22';
 idi | idv 
-----+-----
   2 | 21
   2 | 13
   2 | 12
   2 | 11
   3 | 21
   3 | 13
   3 | 12
   3 | 11
(8 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test67 WHERE idi > 1 AND
														idi < 100 AND
														idv > '22';
                         QUERY PLAN                          
-------------------------------------------------------------
 Custom Scan (o_scan) on o_test67
   Forward index only scan of: o_test67_reg1
   Conds: ((idi > 1) AND (idi < 100) AND (idv > '22'::text))
(3 rows)

SELECT idi, idv FROM o_test67 WHERE idi > 1 AND idi < 100 AND idv > '22';
 idi | idv 
-----+-----
   2 | 33
   2 | 32
   2 | 31
   2 | 23
   3 | 33
   3 | 32
   3 | 31
   3 | 23
(8 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test67 WHERE idi > 1 AND idv = '22';
                 QUERY PLAN                  
---------------------------------------------
 Custom Scan (o_scan) on o_test67
   Forward index only scan of: o_test67_reg1
   Conds: ((idi > 1) AND (idv = '22'::text))
(3 rows)

SELECT idi, idv FROM o_test67 WHERE idi > 1 AND idv = '22';
 idi | idv 
-----+-----
   2 | 22
   3 | 22
(2 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test67 WHERE idi < 3 AND
														idi > 0 AND
														idv < '22';
                        QUERY PLAN                         
-----------------------------------------------------------
 Custom Scan (o_scan) on o_test67
   Forward index only scan of: o_test67_reg1
   Conds: ((idi < 3) AND (idi > 0) AND (idv < '22'::text))
(3 rows)

SELECT idi, idv FROM o_test67 WHERE idi < 3 AND idi > 0 AND idv < '22';
 idi | idv 
-----+-----
   1 | 21
   1 | 13
   1 | 12
   1 | 11
   2 | 21
   2 | 13
   2 | 12
   2 | 11
(8 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test67 WHERE idi < 3 AND
														idi > 0 AND
														idv > '22';
                        QUERY PLAN                         
-----------------------------------------------------------
 Custom Scan (o_scan) on o_test67
   Forward index only scan of: o_test67_reg1
   Conds: ((idi < 3) AND (idi > 0) AND (idv > '22'::text))
(3 rows)

SELECT idi, idv FROM o_test67 WHERE idi < 3 AND idi > 0 AND idv > '22';
 idi | idv 
-----+-----
   1 | 33
   1 | 32
   1 | 31
   1 | 23
   2 | 33
   2 | 32
   2 | 31
   2 | 23
(8 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test67 WHERE idi < 3 AND idv = '22';
                 QUERY PLAN                  
---------------------------------------------
 Custom Scan (o_scan) on o_test67
   Forward index only scan of: o_test67_reg1
   Conds: ((idi < 3) AND (idv = '22'::text))
(3 rows)

SELECT idi, idv FROM o_test67 WHERE idi < 3 AND idv = '22';
 idi | idv 
-----+-----
   1 | 22
   2 | 22
(2 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test67 WHERE idi > 1 AND idv IN ('12', '22');
                    QUERY PLAN                     
---------------------------------------------------
 Custom Scan (o_scan) on o_test67
   Filter: ((idv)::text = ANY ('{12,22}'::text[]))
   Forward index only scan of: o_test67_reg1
   Conds: (idi > 1)
(4 rows)

SELECT idi, idv FROM o_test67 WHERE idi > 1 AND idv IN ('12', '22');
 idi | idv 
-----+-----
   2 | 22
   2 | 12
   3 | 22
   3 | 12
(4 rows)

RESET enable_seqscan;
EXPLAIN (COSTS off) SELECT * FROM test66 JOIN o_test67 USING(idi, idv);
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Hash Join
   Hash Cond: ((test66.idi = o_test67.idi) AND ((test66.idv)::text = (o_test67.idv)::text))
   ->  Seq Scan on test66
   ->  Hash
         ->  Seq Scan on o_test67
(5 rows)

SELECT * FROM test66 JOIN o_test67 USING(idi, idv);
 idi | idv | idp 
-----+-----+-----
   1 | 11  | 111
   1 | 12  | 112
   1 | 21  | 121
   1 | 23  | 123
   1 | 32  | 132
   1 | 33  | 133
   2 | 11  | 211
   2 | 12  | 212
   2 | 21  | 221
   2 | 23  | 223
   2 | 32  | 232
   2 | 33  | 233
   3 | 11  | 311
   3 | 12  | 312
   3 | 21  | 321
   3 | 23  | 323
   3 | 32  | 332
   3 | 33  | 333
(18 rows)

set enable_nestloop=off;
EXPLAIN (COSTS off) SELECT * FROM test66 JOIN o_test67 USING(idi, idv);
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Hash Join
   Hash Cond: ((test66.idi = o_test67.idi) AND ((test66.idv)::text = (o_test67.idv)::text))
   ->  Seq Scan on test66
   ->  Hash
         ->  Seq Scan on o_test67
(5 rows)

SELECT * FROM test66 JOIN o_test67 USING(idi, idv);
 idi | idv | idp 
-----+-----+-----
   1 | 11  | 111
   1 | 12  | 112
   1 | 21  | 121
   1 | 23  | 123
   1 | 32  | 132
   1 | 33  | 133
   2 | 11  | 211
   2 | 12  | 212
   2 | 21  | 221
   2 | 23  | 223
   2 | 32  | 232
   2 | 33  | 233
   3 | 11  | 311
   3 | 12  | 312
   3 | 21  | 321
   3 | 23  | 323
   3 | 32  | 332
   3 | 33  | 333
(18 rows)

set enable_hashjoin=off;
EXPLAIN (COSTS off) SELECT * FROM test66 JOIN o_test67 USING(idi, idv);
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Merge Join
   Merge Cond: ((test66.idi = o_test67.idi) AND ((test66.idv)::text = (o_test67.idv)::text))
   ->  Index Only Scan using test66_pkey on test66
   ->  Sort
         Sort Key: o_test67.idi, o_test67.idv
         ->  Seq Scan on o_test67
(6 rows)

SELECT * FROM test66 JOIN o_test67 USING(idi, idv);
 idi | idv | idp 
-----+-----+-----
   1 | 11  | 111
   1 | 12  | 112
   1 | 21  | 121
   1 | 23  | 123
   1 | 32  | 132
   1 | 33  | 133
   2 | 11  | 211
   2 | 12  | 212
   2 | 21  | 221
   2 | 23  | 223
   2 | 32  | 232
   2 | 33  | 233
   3 | 11  | 311
   3 | 12  | 312
   3 | 21  | 321
   3 | 23  | 323
   3 | 32  | 332
   3 | 33  | 333
(18 rows)

set enable_nestloop=on;
set enable_hashjoin=on;
-- 2 field secondary index with different field order and first field desc
CREATE TABLE o_test68
(
	idv varchar NOT NULL,
	idp int4 NOT NULL,
	idi int4 NOT NULL,
	PRIMARY KEY(idp)
) USING orioledb;
CREATE INDEX o_test68_reg1 ON o_test68(idi DESC, idv);
INSERT INTO o_test68
	SELECT j::text||k, i * 100 + j * 10 + k, i
	FROM generate_series(1,3) as i,
	     generate_series(1,3) as j,
	     generate_series(1,3) as k;
ANALYZE o_test68;
SELECT count(*) FROM o_test68;
 count 
-------
    27
(1 row)

SELECT idi, idv FROM o_test68;
 idi | idv 
-----+-----
   1 | 11
   1 | 12
   1 | 13
   1 | 21
   1 | 22
   1 | 23
   1 | 31
   1 | 32
   1 | 33
   2 | 11
   2 | 12
   2 | 13
   2 | 21
   2 | 22
   2 | 23
   2 | 31
   2 | 32
   2 | 33
   3 | 11
   3 | 12
   3 | 13
   3 | 21
   3 | 22
   3 | 23
   3 | 31
   3 | 32
   3 | 33
(27 rows)

SET enable_seqscan = off;
EXPLAIN (COSTS off) SELECT idi, idv FROM o_test68 ORDER BY idi;
                  QUERY PLAN                  
----------------------------------------------
 Custom Scan (o_scan) on o_test68
   Backward index only scan of: o_test68_reg1
(2 rows)

SELECT idi, idv FROM o_test68 ORDER BY idi;
 idi | idv 
-----+-----
   1 | 33
   1 | 32
   1 | 31
   1 | 23
   1 | 22
   1 | 21
   1 | 13
   1 | 12
   1 | 11
   2 | 33
   2 | 32
   2 | 31
   2 | 23
   2 | 22
   2 | 21
   2 | 13
   2 | 12
   2 | 11
   3 | 33
   3 | 32
   3 | 31
   3 | 23
   3 | 22
   3 | 21
   3 | 13
   3 | 12
   3 | 11
(27 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test68 ORDER BY idi DESC;
                 QUERY PLAN                  
---------------------------------------------
 Custom Scan (o_scan) on o_test68
   Forward index only scan of: o_test68_reg1
(2 rows)

SELECT idi, idv FROM o_test68 ORDER BY idi DESC;
 idi | idv 
-----+-----
   3 | 11
   3 | 12
   3 | 13
   3 | 21
   3 | 22
   3 | 23
   3 | 31
   3 | 32
   3 | 33
   2 | 11
   2 | 12
   2 | 13
   2 | 21
   2 | 22
   2 | 23
   2 | 31
   2 | 32
   2 | 33
   1 | 11
   1 | 12
   1 | 13
   1 | 21
   1 | 22
   1 | 23
   1 | 31
   1 | 32
   1 | 33
(27 rows)

RESET enable_seqscan;
SET enable_seqscan = off;
EXPLAIN (COSTS off) SELECT idi, idv FROM o_test68 ORDER BY idi, idv;
                     QUERY PLAN                     
----------------------------------------------------
 Sort
   Sort Key: idi, idv
   ->  Custom Scan (o_scan) on o_test68
         Backward index only scan of: o_test68_reg1
(4 rows)

SELECT idi, idv FROM o_test68 ORDER BY idi, idv;
 idi | idv 
-----+-----
   1 | 11
   1 | 12
   1 | 13
   1 | 21
   1 | 22
   1 | 23
   1 | 31
   1 | 32
   1 | 33
   2 | 11
   2 | 12
   2 | 13
   2 | 21
   2 | 22
   2 | 23
   2 | 31
   2 | 32
   2 | 33
   3 | 11
   3 | 12
   3 | 13
   3 | 21
   3 | 22
   3 | 23
   3 | 31
   3 | 32
   3 | 33
(27 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test68 ORDER BY idi DESC, idv;
                 QUERY PLAN                  
---------------------------------------------
 Custom Scan (o_scan) on o_test68
   Forward index only scan of: o_test68_reg1
(2 rows)

SELECT idi, idv FROM o_test68 ORDER BY idi DESC, idv;
 idi | idv 
-----+-----
   3 | 11
   3 | 12
   3 | 13
   3 | 21
   3 | 22
   3 | 23
   3 | 31
   3 | 32
   3 | 33
   2 | 11
   2 | 12
   2 | 13
   2 | 21
   2 | 22
   2 | 23
   2 | 31
   2 | 32
   2 | 33
   1 | 11
   1 | 12
   1 | 13
   1 | 21
   1 | 22
   1 | 23
   1 | 31
   1 | 32
   1 | 33
(27 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test68 ORDER BY idi, idv DESC;
                  QUERY PLAN                  
----------------------------------------------
 Custom Scan (o_scan) on o_test68
   Backward index only scan of: o_test68_reg1
(2 rows)

SELECT idi, idv FROM o_test68 ORDER BY idi, idv DESC;
 idi | idv 
-----+-----
   1 | 33
   1 | 32
   1 | 31
   1 | 23
   1 | 22
   1 | 21
   1 | 13
   1 | 12
   1 | 11
   2 | 33
   2 | 32
   2 | 31
   2 | 23
   2 | 22
   2 | 21
   2 | 13
   2 | 12
   2 | 11
   3 | 33
   3 | 32
   3 | 31
   3 | 23
   3 | 22
   3 | 21
   3 | 13
   3 | 12
   3 | 11
(27 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test68 ORDER BY idi DESC, idv DESC;
                    QUERY PLAN                     
---------------------------------------------------
 Sort
   Sort Key: idi DESC, idv DESC
   ->  Custom Scan (o_scan) on o_test68
         Forward index only scan of: o_test68_reg1
(4 rows)

SELECT idi, idv FROM o_test68 ORDER BY idi DESC, idv DESC;
 idi | idv 
-----+-----
   3 | 33
   3 | 32
   3 | 31
   3 | 23
   3 | 22
   3 | 21
   3 | 13
   3 | 12
   3 | 11
   2 | 33
   2 | 32
   2 | 31
   2 | 23
   2 | 22
   2 | 21
   2 | 13
   2 | 12
   2 | 11
   1 | 33
   1 | 32
   1 | 31
   1 | 23
   1 | 22
   1 | 21
   1 | 13
   1 | 12
   1 | 11
(27 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test68 WHERE idi = 2;
                 QUERY PLAN                  
---------------------------------------------
 Custom Scan (o_scan) on o_test68
   Forward index only scan of: o_test68_reg1
   Conds: (idi = 2)
(3 rows)

SELECT idi, idv FROM o_test68 WHERE idi = 2;
 idi | idv 
-----+-----
   2 | 11
   2 | 12
   2 | 13
   2 | 21
   2 | 22
   2 | 23
   2 | 31
   2 | 32
   2 | 33
(9 rows)

RESET enable_seqscan;
EXPLAIN (COSTS off) SELECT idi, idv FROM o_test68 WHERE idv = '22';
              QUERY PLAN              
--------------------------------------
 Seq Scan on o_test68
   Filter: ((idv)::text = '22'::text)
(2 rows)

SELECT idi, idv FROM o_test68 WHERE idv = '22';
 idi | idv 
-----+-----
   1 | 22
   2 | 22
   3 | 22
(3 rows)

SET enable_seqscan = off;
EXPLAIN (COSTS off) SELECT idi, idv FROM o_test68 WHERE idi = 2 AND idv = '22';
                 QUERY PLAN                  
---------------------------------------------
 Custom Scan (o_scan) on o_test68
   Forward index only scan of: o_test68_reg1
   Conds: ((idi = 2) AND (idv = '22'::text))
(3 rows)

SELECT idi, idv FROM o_test68 WHERE idi = 2 AND idv = '22';
 idi | idv 
-----+-----
   2 | 22
(1 row)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test68 WHERE idi = 2 AND idv > '22';
                 QUERY PLAN                  
---------------------------------------------
 Custom Scan (o_scan) on o_test68
   Forward index only scan of: o_test68_reg1
   Conds: ((idi = 2) AND (idv > '22'::text))
(3 rows)

SELECT idi, idv FROM o_test68 WHERE idi = 2 AND idv > '22';
 idi | idv 
-----+-----
   2 | 23
   2 | 31
   2 | 32
   2 | 33
(4 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test68 WHERE idi = 2 AND idv < '22';
                 QUERY PLAN                  
---------------------------------------------
 Custom Scan (o_scan) on o_test68
   Forward index only scan of: o_test68_reg1
   Conds: ((idi = 2) AND (idv < '22'::text))
(3 rows)

SELECT idi, idv FROM o_test68 WHERE idi = 2 AND idv < '22';
 idi | idv 
-----+-----
   2 | 11
   2 | 12
   2 | 13
   2 | 21
(4 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test68 WHERE idi = 2 AND idv >= '22';
                  QUERY PLAN                  
----------------------------------------------
 Custom Scan (o_scan) on o_test68
   Forward index only scan of: o_test68_reg1
   Conds: ((idi = 2) AND (idv >= '22'::text))
(3 rows)

SELECT idi, idv FROM o_test68 WHERE idi = 2 AND idv >= '22';
 idi | idv 
-----+-----
   2 | 22
   2 | 23
   2 | 31
   2 | 32
   2 | 33
(5 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test68 WHERE idi = 2 AND idv <= '22';
                  QUERY PLAN                  
----------------------------------------------
 Custom Scan (o_scan) on o_test68
   Forward index only scan of: o_test68_reg1
   Conds: ((idi = 2) AND (idv <= '22'::text))
(3 rows)

SELECT idi, idv FROM o_test68 WHERE idi = 2 AND idv <= '22';
 idi | idv 
-----+-----
   2 | 11
   2 | 12
   2 | 13
   2 | 21
   2 | 22
(5 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test68 WHERE idi = 2 AND idv >= '12' AND idv <= '22';
                              QUERY PLAN                              
----------------------------------------------------------------------
 Custom Scan (o_scan) on o_test68
   Forward index only scan of: o_test68_reg1
   Conds: ((idi = 2) AND (idv >= '12'::text) AND (idv <= '22'::text))
(3 rows)

SELECT idi, idv FROM o_test68 WHERE idi = 2 AND idv >= '12' AND idv <= '22';
 idi | idv 
-----+-----
   2 | 12
   2 | 13
   2 | 21
   2 | 22
(4 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test68 WHERE idi = 2 AND idv > '12' AND idv <= '22';
                             QUERY PLAN                              
---------------------------------------------------------------------
 Custom Scan (o_scan) on o_test68
   Forward index only scan of: o_test68_reg1
   Conds: ((idi = 2) AND (idv > '12'::text) AND (idv <= '22'::text))
(3 rows)

SELECT idi, idv FROM o_test68 WHERE idi = 2 AND idv > '12' AND idv <= '22';
 idi | idv 
-----+-----
   2 | 13
   2 | 21
   2 | 22
(3 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test68 WHERE idi = 2 AND idv >= '12' AND idv < '22';
                             QUERY PLAN                              
---------------------------------------------------------------------
 Custom Scan (o_scan) on o_test68
   Forward index only scan of: o_test68_reg1
   Conds: ((idi = 2) AND (idv >= '12'::text) AND (idv < '22'::text))
(3 rows)

SELECT idi, idv FROM o_test68 WHERE idi = 2 AND idv >= '12' AND idv < '22';
 idi | idv 
-----+-----
   2 | 12
   2 | 13
   2 | 21
(3 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test68 WHERE idi = 2 AND idv > '12' AND idv < '22';
                             QUERY PLAN                             
--------------------------------------------------------------------
 Custom Scan (o_scan) on o_test68
   Forward index only scan of: o_test68_reg1
   Conds: ((idi = 2) AND (idv > '12'::text) AND (idv < '22'::text))
(3 rows)

SELECT idi, idv FROM o_test68 WHERE idi = 2 AND idv > '12' AND idv < '22';
 idi | idv 
-----+-----
   2 | 13
   2 | 21
(2 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test68 WHERE idi = 2 AND (idv <= '12' OR idv >= '22');
                               QUERY PLAN                               
------------------------------------------------------------------------
 Custom Scan (o_scan) on o_test68
   Filter: (((idv)::text <= '12'::text) OR ((idv)::text >= '22'::text))
   Forward index only scan of: o_test68_reg1
   Conds: (idi = 2)
(4 rows)

SELECT idi, idv FROM o_test68 WHERE idi = 2 AND (idv <= '12' OR idv >= '22');
 idi | idv 
-----+-----
   2 | 11
   2 | 12
   2 | 22
   2 | 23
   2 | 31
   2 | 32
   2 | 33
(7 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test68 WHERE idi = 2 AND (idv < '12' OR idv >= '22');
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Custom Scan (o_scan) on o_test68
   Filter: (((idv)::text < '12'::text) OR ((idv)::text >= '22'::text))
   Forward index only scan of: o_test68_reg1
   Conds: (idi = 2)
(4 rows)

SELECT idi, idv FROM o_test68 WHERE idi = 2 AND (idv < '12' OR idv >= '22');
 idi | idv 
-----+-----
   2 | 11
   2 | 22
   2 | 23
   2 | 31
   2 | 32
   2 | 33
(6 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test68 WHERE idi = 2 AND (idv <= '12' OR idv > '22');
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Custom Scan (o_scan) on o_test68
   Filter: (((idv)::text <= '12'::text) OR ((idv)::text > '22'::text))
   Forward index only scan of: o_test68_reg1
   Conds: (idi = 2)
(4 rows)

SELECT idi, idv FROM o_test68 WHERE idi = 2 AND (idv <= '12' OR idv > '22');
 idi | idv 
-----+-----
   2 | 11
   2 | 12
   2 | 23
   2 | 31
   2 | 32
   2 | 33
(6 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test68 WHERE idi = 2 AND (idv < '12' OR idv > '22');
                              QUERY PLAN                              
----------------------------------------------------------------------
 Custom Scan (o_scan) on o_test68
   Filter: (((idv)::text < '12'::text) OR ((idv)::text > '22'::text))
   Forward index only scan of: o_test68_reg1
   Conds: (idi = 2)
(4 rows)

SELECT idi, idv FROM o_test68 WHERE idi = 2 AND (idv < '12' OR idv > '22');
 idi | idv 
-----+-----
   2 | 11
   2 | 23
   2 | 31
   2 | 32
   2 | 33
(5 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test68 WHERE idi = 2 AND (idv < '12' AND idv > '22');
                             QUERY PLAN                             
--------------------------------------------------------------------
 Custom Scan (o_scan) on o_test68
   Forward index only scan of: o_test68_reg1
   Conds: ((idi = 2) AND (idv < '12'::text) AND (idv > '22'::text))
(3 rows)

SELECT idi, idv FROM o_test68 WHERE idi = 2 AND (idv < '12' AND idv > '22');
 idi | idv 
-----+-----
(0 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test68 WHERE idi = 2 AND idv IN ('12', '22');
                        QUERY PLAN                        
----------------------------------------------------------
 Custom Scan (o_scan) on o_test68
   Forward index only scan of: o_test68_reg1
   Conds: ((idi = 2) AND (idv = ANY ('{12,22}'::text[])))
(3 rows)

SELECT idi, idv FROM o_test68 WHERE idi = 2 AND idv IN ('12', '22');
 idi | idv 
-----+-----
   2 | 12
   2 | 22
(2 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test68 WHERE idi IN (2, 4) AND idv IN ('12', '22');
                    QUERY PLAN                     
---------------------------------------------------
 Custom Scan (o_scan) on o_test68
   Filter: ((idv)::text = ANY ('{12,22}'::text[]))
   Forward index only scan of: o_test68_reg1
   Conds: (idi = ANY ('{2,4}'::integer[]))
(4 rows)

SELECT idi, idv FROM o_test68 WHERE idi IN (2, 4) AND idv IN ('12', '22');
 idi | idv 
-----+-----
   2 | 12
   2 | 22
(2 rows)

RESET enable_seqscan;
EXPLAIN (COSTS off) SELECT idi, idv FROM o_test68 WHERE (idi = 2 AND idv = '12') OR (idi = 4 AND idv = '2_3');
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Seq Scan on o_test68
   Filter: (((idi = 2) AND ((idv)::text = '12'::text)) OR ((idi = 4) AND ((idv)::text = '2_3'::text)))
(2 rows)

SELECT idi, idv FROM o_test68 WHERE (idi = 2 AND idv = '12') OR (idi = 4 AND idv = '2_3');
 idi | idv 
-----+-----
   2 | 12
(1 row)

SET enable_seqscan = off;
EXPLAIN (COSTS off) SELECT idi, idv FROM o_test68 WHERE idi > 1 AND
														idi < 100 AND
														idv < '22';
                         QUERY PLAN                          
-------------------------------------------------------------
 Custom Scan (o_scan) on o_test68
   Forward index only scan of: o_test68_reg1
   Conds: ((idi > 1) AND (idi < 100) AND (idv < '22'::text))
(3 rows)

SELECT idi, idv FROM o_test68 WHERE idi > 1 AND idi < 100 AND idv < '22';
 idi | idv 
-----+-----
   3 | 11
   3 | 12
   3 | 13
   3 | 21
   2 | 11
   2 | 12
   2 | 13
   2 | 21
(8 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test68 WHERE idi > 1 AND
														idi < 100 AND
														idv > '22';
                         QUERY PLAN                          
-------------------------------------------------------------
 Custom Scan (o_scan) on o_test68
   Forward index only scan of: o_test68_reg1
   Conds: ((idi > 1) AND (idi < 100) AND (idv > '22'::text))
(3 rows)

SELECT idi, idv FROM o_test68 WHERE idi > 1 AND idi < 100 AND idv > '22';
 idi | idv 
-----+-----
   3 | 23
   3 | 31
   3 | 32
   3 | 33
   2 | 23
   2 | 31
   2 | 32
   2 | 33
(8 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test68 WHERE idi > 1 AND idv = '22';
                 QUERY PLAN                  
---------------------------------------------
 Custom Scan (o_scan) on o_test68
   Forward index only scan of: o_test68_reg1
   Conds: ((idi > 1) AND (idv = '22'::text))
(3 rows)

SELECT idi, idv FROM o_test68 WHERE idi > 1 AND idv = '22';
 idi | idv 
-----+-----
   3 | 22
   2 | 22
(2 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test68 WHERE idi < 3 AND
														idi > 0 AND
														idv < '22';
                        QUERY PLAN                         
-----------------------------------------------------------
 Custom Scan (o_scan) on o_test68
   Forward index only scan of: o_test68_reg1
   Conds: ((idi < 3) AND (idi > 0) AND (idv < '22'::text))
(3 rows)

SELECT idi, idv FROM o_test68 WHERE idi < 3 AND idi > 0 AND idv < '22';
 idi | idv 
-----+-----
   2 | 11
   2 | 12
   2 | 13
   2 | 21
   1 | 11
   1 | 12
   1 | 13
   1 | 21
(8 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test68 WHERE idi < 3 AND
														idi > 0 AND
														idv > '22';
                        QUERY PLAN                         
-----------------------------------------------------------
 Custom Scan (o_scan) on o_test68
   Forward index only scan of: o_test68_reg1
   Conds: ((idi < 3) AND (idi > 0) AND (idv > '22'::text))
(3 rows)

SELECT idi, idv FROM o_test68 WHERE idi < 3 AND idi > 0 AND idv > '22';
 idi | idv 
-----+-----
   2 | 23
   2 | 31
   2 | 32
   2 | 33
   1 | 23
   1 | 31
   1 | 32
   1 | 33
(8 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test68 WHERE idi < 3 AND idv = '22';
                 QUERY PLAN                  
---------------------------------------------
 Custom Scan (o_scan) on o_test68
   Forward index only scan of: o_test68_reg1
   Conds: ((idi < 3) AND (idv = '22'::text))
(3 rows)

SELECT idi, idv FROM o_test68 WHERE idi < 3 AND idv = '22';
 idi | idv 
-----+-----
   2 | 22
   1 | 22
(2 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test68 WHERE idi > 1 AND idv IN ('12', '22');
                    QUERY PLAN                     
---------------------------------------------------
 Custom Scan (o_scan) on o_test68
   Filter: ((idv)::text = ANY ('{12,22}'::text[]))
   Forward index only scan of: o_test68_reg1
   Conds: (idi > 1)
(4 rows)

SELECT idi, idv FROM o_test68 WHERE idi > 1 AND idv IN ('12', '22');
 idi | idv 
-----+-----
   3 | 12
   3 | 22
   2 | 12
   2 | 22
(4 rows)

RESET enable_seqscan;
EXPLAIN (COSTS off) SELECT * FROM test66 JOIN o_test68 USING(idi, idv);
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Hash Join
   Hash Cond: ((test66.idi = o_test68.idi) AND ((test66.idv)::text = (o_test68.idv)::text))
   ->  Seq Scan on test66
   ->  Hash
         ->  Seq Scan on o_test68
(5 rows)

SELECT * FROM test66 JOIN o_test68 USING(idi, idv);
 idi | idv | idp 
-----+-----+-----
   1 | 11  | 111
   1 | 12  | 112
   1 | 21  | 121
   1 | 23  | 123
   1 | 32  | 132
   1 | 33  | 133
   2 | 11  | 211
   2 | 12  | 212
   2 | 21  | 221
   2 | 23  | 223
   2 | 32  | 232
   2 | 33  | 233
   3 | 11  | 311
   3 | 12  | 312
   3 | 21  | 321
   3 | 23  | 323
   3 | 32  | 332
   3 | 33  | 333
(18 rows)

set enable_nestloop=off;
EXPLAIN (COSTS off) SELECT * FROM test66 JOIN o_test68 USING(idi, idv);
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Hash Join
   Hash Cond: ((test66.idi = o_test68.idi) AND ((test66.idv)::text = (o_test68.idv)::text))
   ->  Seq Scan on test66
   ->  Hash
         ->  Seq Scan on o_test68
(5 rows)

SELECT * FROM test66 JOIN o_test68 USING(idi, idv);
 idi | idv | idp 
-----+-----+-----
   1 | 11  | 111
   1 | 12  | 112
   1 | 21  | 121
   1 | 23  | 123
   1 | 32  | 132
   1 | 33  | 133
   2 | 11  | 211
   2 | 12  | 212
   2 | 21  | 221
   2 | 23  | 223
   2 | 32  | 232
   2 | 33  | 233
   3 | 11  | 311
   3 | 12  | 312
   3 | 21  | 321
   3 | 23  | 323
   3 | 32  | 332
   3 | 33  | 333
(18 rows)

set enable_hashjoin=off;
EXPLAIN (COSTS off) SELECT * FROM test66 JOIN o_test68 USING(idi, idv);
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Merge Join
   Merge Cond: ((test66.idi = o_test68.idi) AND ((test66.idv)::text = (o_test68.idv)::text))
   ->  Index Only Scan using test66_pkey on test66
   ->  Sort
         Sort Key: o_test68.idi, o_test68.idv
         ->  Seq Scan on o_test68
(6 rows)

SELECT * FROM test66 JOIN o_test68 USING(idi, idv);
 idi | idv | idp 
-----+-----+-----
   1 | 11  | 111
   1 | 12  | 112
   1 | 21  | 121
   1 | 23  | 123
   1 | 32  | 132
   1 | 33  | 133
   2 | 11  | 211
   2 | 12  | 212
   2 | 21  | 221
   2 | 23  | 223
   2 | 32  | 232
   2 | 33  | 233
   3 | 11  | 311
   3 | 12  | 312
   3 | 21  | 321
   3 | 23  | 323
   3 | 32  | 332
   3 | 33  | 333
(18 rows)

set enable_nestloop=on;
set enable_hashjoin=on;
-- 2 field sk with text field first
CREATE TABLE o_test69
(
	idv varchar NOT NULL,
	idi int4 NOT NULL,
	idp int4 NOT NULL,
	PRIMARY KEY(idp)
) USING orioledb;
CREATE INDEX o_test69_reg1 ON o_test69(idv, idi);
INSERT INTO o_test69
	SELECT j::text||k, i, 100 * i + 10 * j + k
	FROM generate_series(1,3) as i,
	     generate_series(1,3) as j,
	     generate_series(1,3) as k;
ANALYZE o_test69;
SELECT count(*) FROM o_test69;
 count 
-------
    27
(1 row)

SELECT idi, idv FROM o_test69;
 idi | idv 
-----+-----
   1 | 11
   1 | 12
   1 | 13
   1 | 21
   1 | 22
   1 | 23
   1 | 31
   1 | 32
   1 | 33
   2 | 11
   2 | 12
   2 | 13
   2 | 21
   2 | 22
   2 | 23
   2 | 31
   2 | 32
   2 | 33
   3 | 11
   3 | 12
   3 | 13
   3 | 21
   3 | 22
   3 | 23
   3 | 31
   3 | 32
   3 | 33
(27 rows)

SET enable_seqscan = off;
EXPLAIN (COSTS off) SELECT idi, idv FROM o_test69 ORDER BY idv;
                 QUERY PLAN                  
---------------------------------------------
 Custom Scan (o_scan) on o_test69
   Forward index only scan of: o_test69_reg1
(2 rows)

SELECT idi, idv FROM o_test69 ORDER BY idv;
 idi | idv 
-----+-----
   1 | 11
   2 | 11
   3 | 11
   1 | 12
   2 | 12
   3 | 12
   1 | 13
   2 | 13
   3 | 13
   1 | 21
   2 | 21
   3 | 21
   1 | 22
   2 | 22
   3 | 22
   1 | 23
   2 | 23
   3 | 23
   1 | 31
   2 | 31
   3 | 31
   1 | 32
   2 | 32
   3 | 32
   1 | 33
   2 | 33
   3 | 33
(27 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test69 ORDER BY idv DESC;
                  QUERY PLAN                  
----------------------------------------------
 Custom Scan (o_scan) on o_test69
   Backward index only scan of: o_test69_reg1
(2 rows)

SELECT idi, idv FROM o_test69 ORDER BY idv DESC;
 idi | idv 
-----+-----
   3 | 33
   2 | 33
   1 | 33
   3 | 32
   2 | 32
   1 | 32
   3 | 31
   2 | 31
   1 | 31
   3 | 23
   2 | 23
   1 | 23
   3 | 22
   2 | 22
   1 | 22
   3 | 21
   2 | 21
   1 | 21
   3 | 13
   2 | 13
   1 | 13
   3 | 12
   2 | 12
   1 | 12
   3 | 11
   2 | 11
   1 | 11
(27 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test69 ORDER BY idv, idi;
                 QUERY PLAN                  
---------------------------------------------
 Custom Scan (o_scan) on o_test69
   Forward index only scan of: o_test69_reg1
(2 rows)

SELECT idi, idv FROM o_test69 ORDER BY idv, idi;
 idi | idv 
-----+-----
   1 | 11
   2 | 11
   3 | 11
   1 | 12
   2 | 12
   3 | 12
   1 | 13
   2 | 13
   3 | 13
   1 | 21
   2 | 21
   3 | 21
   1 | 22
   2 | 22
   3 | 22
   1 | 23
   2 | 23
   3 | 23
   1 | 31
   2 | 31
   3 | 31
   1 | 32
   2 | 32
   3 | 32
   1 | 33
   2 | 33
   3 | 33
(27 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test69 ORDER BY idv DESC, idi;
                     QUERY PLAN                     
----------------------------------------------------
 Sort
   Sort Key: idv DESC, idi
   ->  Custom Scan (o_scan) on o_test69
         Backward index only scan of: o_test69_reg1
(4 rows)

SELECT idi, idv FROM o_test69 ORDER BY idv DESC, idi;
 idi | idv 
-----+-----
   1 | 33
   2 | 33
   3 | 33
   1 | 32
   2 | 32
   3 | 32
   1 | 31
   2 | 31
   3 | 31
   1 | 23
   2 | 23
   3 | 23
   1 | 22
   2 | 22
   3 | 22
   1 | 21
   2 | 21
   3 | 21
   1 | 13
   2 | 13
   3 | 13
   1 | 12
   2 | 12
   3 | 12
   1 | 11
   2 | 11
   3 | 11
(27 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test69 ORDER BY idv, idi DESC;
                    QUERY PLAN                     
---------------------------------------------------
 Sort
   Sort Key: idv, idi DESC
   ->  Custom Scan (o_scan) on o_test69
         Forward index only scan of: o_test69_reg1
(4 rows)

SELECT idi, idv FROM o_test69 ORDER BY idv, idi DESC;
 idi | idv 
-----+-----
   3 | 11
   2 | 11
   1 | 11
   3 | 12
   2 | 12
   1 | 12
   3 | 13
   2 | 13
   1 | 13
   3 | 21
   2 | 21
   1 | 21
   3 | 22
   2 | 22
   1 | 22
   3 | 23
   2 | 23
   1 | 23
   3 | 31
   2 | 31
   1 | 31
   3 | 32
   2 | 32
   1 | 32
   3 | 33
   2 | 33
   1 | 33
(27 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test69 ORDER BY idv DESC, idi DESC;
                  QUERY PLAN                  
----------------------------------------------
 Custom Scan (o_scan) on o_test69
   Backward index only scan of: o_test69_reg1
(2 rows)

SELECT idi, idv FROM o_test69 ORDER BY idv DESC, idi DESC;
 idi | idv 
-----+-----
   3 | 33
   2 | 33
   1 | 33
   3 | 32
   2 | 32
   1 | 32
   3 | 31
   2 | 31
   1 | 31
   3 | 23
   2 | 23
   1 | 23
   3 | 22
   2 | 22
   1 | 22
   3 | 21
   2 | 21
   1 | 21
   3 | 13
   2 | 13
   1 | 13
   3 | 12
   2 | 12
   1 | 12
   3 | 11
   2 | 11
   1 | 11
(27 rows)

RESET enable_seqscan;
EXPLAIN (COSTS off) SELECT idi, idv FROM o_test69 WHERE idi = 2;
      QUERY PLAN      
----------------------
 Seq Scan on o_test69
   Filter: (idi = 2)
(2 rows)

SELECT idi, idv FROM o_test69 WHERE idi = 2;
 idi | idv 
-----+-----
   2 | 11
   2 | 12
   2 | 13
   2 | 21
   2 | 22
   2 | 23
   2 | 31
   2 | 32
   2 | 33
(9 rows)

SET enable_seqscan = off;
EXPLAIN (COSTS off) SELECT idi, idv FROM o_test69 WHERE idv = '22';
                 QUERY PLAN                  
---------------------------------------------
 Custom Scan (o_scan) on o_test69
   Forward index only scan of: o_test69_reg1
   Conds: (idv = '22'::text)
(3 rows)

SELECT idi, idv FROM o_test69 WHERE idv = '22';
 idi | idv 
-----+-----
   1 | 22
   2 | 22
   3 | 22
(3 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test69 WHERE idi = 2 AND idv = '22';
                 QUERY PLAN                  
---------------------------------------------
 Custom Scan (o_scan) on o_test69
   Forward index only scan of: o_test69_reg1
   Conds: ((idv = '22'::text) AND (idi = 2))
(3 rows)

SELECT idi, idv FROM o_test69 WHERE idi = 2 AND idv = '22';
 idi | idv 
-----+-----
   2 | 22
(1 row)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test69 WHERE idi = 2 AND idv > '22';
                 QUERY PLAN                  
---------------------------------------------
 Custom Scan (o_scan) on o_test69
   Forward index only scan of: o_test69_reg1
   Conds: ((idv > '22'::text) AND (idi = 2))
(3 rows)

SELECT idi, idv FROM o_test69 WHERE idi = 2 AND idv > '22';
 idi | idv 
-----+-----
   2 | 23
   2 | 31
   2 | 32
   2 | 33
(4 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test69 WHERE idi = 2 AND idv < '22';
                 QUERY PLAN                  
---------------------------------------------
 Custom Scan (o_scan) on o_test69
   Forward index only scan of: o_test69_reg1
   Conds: ((idv < '22'::text) AND (idi = 2))
(3 rows)

SELECT idi, idv FROM o_test69 WHERE idi = 2 AND idv < '22';
 idi | idv 
-----+-----
   2 | 11
   2 | 12
   2 | 13
   2 | 21
(4 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test69 WHERE idi = 2 AND idv >= '22';
                  QUERY PLAN                  
----------------------------------------------
 Custom Scan (o_scan) on o_test69
   Forward index only scan of: o_test69_reg1
   Conds: ((idv >= '22'::text) AND (idi = 2))
(3 rows)

SELECT idi, idv FROM o_test69 WHERE idi = 2 AND idv >= '22';
 idi | idv 
-----+-----
   2 | 22
   2 | 23
   2 | 31
   2 | 32
   2 | 33
(5 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test69 WHERE idi = 2 AND idv <= '22';
                  QUERY PLAN                  
----------------------------------------------
 Custom Scan (o_scan) on o_test69
   Forward index only scan of: o_test69_reg1
   Conds: ((idv <= '22'::text) AND (idi = 2))
(3 rows)

SELECT idi, idv FROM o_test69 WHERE idi = 2 AND idv <= '22';
 idi | idv 
-----+-----
   2 | 11
   2 | 12
   2 | 13
   2 | 21
   2 | 22
(5 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test69 WHERE idi = 2 AND idv >= '12' AND idv <= '22';
                              QUERY PLAN                              
----------------------------------------------------------------------
 Custom Scan (o_scan) on o_test69
   Forward index only scan of: o_test69_reg1
   Conds: ((idv >= '12'::text) AND (idv <= '22'::text) AND (idi = 2))
(3 rows)

SELECT idi, idv FROM o_test69 WHERE idi = 2 AND idv >= '12' AND idv <= '22';
 idi | idv 
-----+-----
   2 | 12
   2 | 13
   2 | 21
   2 | 22
(4 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test69 WHERE idi = 2 AND idv > '12' AND idv <= '22';
                             QUERY PLAN                              
---------------------------------------------------------------------
 Custom Scan (o_scan) on o_test69
   Forward index only scan of: o_test69_reg1
   Conds: ((idv > '12'::text) AND (idv <= '22'::text) AND (idi = 2))
(3 rows)

SELECT idi, idv FROM o_test69 WHERE idi = 2 AND idv > '12' AND idv <= '22';
 idi | idv 
-----+-----
   2 | 13
   2 | 21
   2 | 22
(3 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test69 WHERE idi = 2 AND idv >= '12' AND idv < '22';
                             QUERY PLAN                              
---------------------------------------------------------------------
 Custom Scan (o_scan) on o_test69
   Forward index only scan of: o_test69_reg1
   Conds: ((idv >= '12'::text) AND (idv < '22'::text) AND (idi = 2))
(3 rows)

SELECT idi, idv FROM o_test69 WHERE idi = 2 AND idv >= '12' AND idv < '22';
 idi | idv 
-----+-----
   2 | 12
   2 | 13
   2 | 21
(3 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test69 WHERE idi = 2 AND idv > '12' AND idv < '22';
                             QUERY PLAN                             
--------------------------------------------------------------------
 Custom Scan (o_scan) on o_test69
   Forward index only scan of: o_test69_reg1
   Conds: ((idv > '12'::text) AND (idv < '22'::text) AND (idi = 2))
(3 rows)

SELECT idi, idv FROM o_test69 WHERE idi = 2 AND idv > '12' AND idv < '22';
 idi | idv 
-----+-----
   2 | 13
   2 | 21
(2 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test69 WHERE idi = 2 AND (idv <= '12' OR idv >= '22') ORDER BY idv;
                               QUERY PLAN                               
------------------------------------------------------------------------
 Custom Scan (o_scan) on o_test69
   Filter: (((idv)::text <= '12'::text) OR ((idv)::text >= '22'::text))
   Forward index only scan of: o_test69_reg1
   Conds: (idi = 2)
(4 rows)

SELECT idi, idv FROM o_test69 WHERE idi = 2 AND (idv <= '12' OR idv >= '22') ORDER BY idv;
 idi | idv 
-----+-----
   2 | 11
   2 | 12
   2 | 22
   2 | 23
   2 | 31
   2 | 32
   2 | 33
(7 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test69 WHERE idi = 2 AND (idv < '12' OR idv >= '22') ORDER BY idv;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Custom Scan (o_scan) on o_test69
   Filter: (((idv)::text < '12'::text) OR ((idv)::text >= '22'::text))
   Forward index only scan of: o_test69_reg1
   Conds: (idi = 2)
(4 rows)

SELECT idi, idv FROM o_test69 WHERE idi = 2 AND (idv < '12' OR idv >= '22') ORDER BY idv;
 idi | idv 
-----+-----
   2 | 11
   2 | 22
   2 | 23
   2 | 31
   2 | 32
   2 | 33
(6 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test69 WHERE idi = 2 AND (idv <= '12' OR idv > '22') ORDER BY idv;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Custom Scan (o_scan) on o_test69
   Filter: (((idv)::text <= '12'::text) OR ((idv)::text > '22'::text))
   Forward index only scan of: o_test69_reg1
   Conds: (idi = 2)
(4 rows)

SELECT idi, idv FROM o_test69 WHERE idi = 2 AND (idv <= '12' OR idv > '22') ORDER BY idv;
 idi | idv 
-----+-----
   2 | 11
   2 | 12
   2 | 23
   2 | 31
   2 | 32
   2 | 33
(6 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test69 WHERE idi = 2 AND (idv < '12' OR idv > '22') ORDER BY idv;
                              QUERY PLAN                              
----------------------------------------------------------------------
 Custom Scan (o_scan) on o_test69
   Filter: (((idv)::text < '12'::text) OR ((idv)::text > '22'::text))
   Forward index only scan of: o_test69_reg1
   Conds: (idi = 2)
(4 rows)

SELECT idi, idv FROM o_test69 WHERE idi = 2 AND (idv < '12' OR idv > '22') ORDER BY idv;
 idi | idv 
-----+-----
   2 | 11
   2 | 23
   2 | 31
   2 | 32
   2 | 33
(5 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test69 WHERE idi = 2 AND (idv < '12' AND idv > '22') ORDER BY idv;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Custom Scan (o_scan) on o_test69
   Forward index only scan of: o_test69_reg1
   Conds: ((idv < '12'::text) AND (idv > '22'::text) AND (idi = 2))
(3 rows)

SELECT idi, idv FROM o_test69 WHERE idi = 2 AND (idv < '12' AND idv > '22') ORDER BY idv;
 idi | idv 
-----+-----
(0 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test69 WHERE idi = 2 AND idv IN ('12', '22');
                        QUERY PLAN                        
----------------------------------------------------------
 Custom Scan (o_scan) on o_test69
   Forward index only scan of: o_test69_reg1
   Conds: ((idv = ANY ('{12,22}'::text[])) AND (idi = 2))
(3 rows)

SELECT idi, idv FROM o_test69 WHERE idi = 2 AND idv IN ('12', '22');
 idi | idv 
-----+-----
   2 | 12
   2 | 22
(2 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test69 WHERE idi IN (2, 4) AND idv IN ('12', '22');
                 QUERY PLAN                  
---------------------------------------------
 Custom Scan (o_scan) on o_test69
   Filter: (idi = ANY ('{2,4}'::integer[]))
   Forward index only scan of: o_test69_reg1
   Conds: (idv = ANY ('{12,22}'::text[]))
(4 rows)

SELECT idi, idv FROM o_test69 WHERE idi IN (2, 4) AND idv IN ('12', '22');
 idi | idv 
-----+-----
   2 | 12
   2 | 22
(2 rows)

RESET enable_seqscan;
EXPLAIN (COSTS off) SELECT idi, idv FROM o_test69 WHERE (idi = 2 AND idv = '12') OR (idi = 4 AND idv = '2_3');
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Seq Scan on o_test69
   Filter: (((idi = 2) AND ((idv)::text = '12'::text)) OR ((idi = 4) AND ((idv)::text = '2_3'::text)))
(2 rows)

SELECT idi, idv FROM o_test69 WHERE (idi = 2 AND idv = '12') OR (idi = 4 AND idv = '2_3');
 idi | idv 
-----+-----
   2 | 12
(1 row)

SET enable_seqscan = off;
EXPLAIN (COSTS off) SELECT idi, idv FROM o_test69 WHERE idi > 1 AND
														idi < 100 AND
														idv < '22';
                         QUERY PLAN                          
-------------------------------------------------------------
 Custom Scan (o_scan) on o_test69
   Forward index only scan of: o_test69_reg1
   Conds: ((idv < '22'::text) AND (idi > 1) AND (idi < 100))
(3 rows)

SELECT idi, idv FROM o_test69 WHERE idi > 1 AND idv < '22';
 idi | idv 
-----+-----
   2 | 11
   3 | 11
   2 | 12
   3 | 12
   2 | 13
   3 | 13
   2 | 21
   3 | 21
(8 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test69 WHERE idi > 1 AND
														idi < 100 AND
														idv > '22';
                         QUERY PLAN                          
-------------------------------------------------------------
 Custom Scan (o_scan) on o_test69
   Forward index only scan of: o_test69_reg1
   Conds: ((idv > '22'::text) AND (idi > 1) AND (idi < 100))
(3 rows)

SELECT idi, idv FROM o_test69 WHERE idi > 1 AND idi < 100 AND idv > '22';
 idi | idv 
-----+-----
   2 | 23
   3 | 23
   2 | 31
   3 | 31
   2 | 32
   3 | 32
   2 | 33
   3 | 33
(8 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test69 WHERE idi > 1 AND idv = '22';
                 QUERY PLAN                  
---------------------------------------------
 Custom Scan (o_scan) on o_test69
   Forward index only scan of: o_test69_reg1
   Conds: ((idv = '22'::text) AND (idi > 1))
(3 rows)

SELECT idi, idv FROM o_test69 WHERE idi > 1 AND idi < 100 AND idv = '22';
 idi | idv 
-----+-----
   2 | 22
   3 | 22
(2 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test69 WHERE idi < 3 AND
														idi > 0 AND
														idv < '22';
                        QUERY PLAN                         
-----------------------------------------------------------
 Custom Scan (o_scan) on o_test69
   Forward index only scan of: o_test69_reg1
   Conds: ((idv < '22'::text) AND (idi < 3) AND (idi > 0))
(3 rows)

SELECT idi, idv FROM o_test69 WHERE idi < 3 AND idi > 0 AND idv < '22';
 idi | idv 
-----+-----
   1 | 11
   2 | 11
   1 | 12
   2 | 12
   1 | 13
   2 | 13
   1 | 21
   2 | 21
(8 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test69 WHERE idi < 3 AND
														idi > 0 AND
														idv > '22';
                        QUERY PLAN                         
-----------------------------------------------------------
 Custom Scan (o_scan) on o_test69
   Forward index only scan of: o_test69_reg1
   Conds: ((idv > '22'::text) AND (idi < 3) AND (idi > 0))
(3 rows)

SELECT idi, idv FROM o_test69 WHERE idi < 3 AND idi > 0 AND idv > '22';
 idi | idv 
-----+-----
   1 | 23
   2 | 23
   1 | 31
   2 | 31
   1 | 32
   2 | 32
   1 | 33
   2 | 33
(8 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test69 WHERE idi < 3 AND idv = '22';
                 QUERY PLAN                  
---------------------------------------------
 Custom Scan (o_scan) on o_test69
   Forward index only scan of: o_test69_reg1
   Conds: ((idv = '22'::text) AND (idi < 3))
(3 rows)

SELECT idi, idv FROM o_test69 WHERE idi < 3 AND idv = '22';
 idi | idv 
-----+-----
   1 | 22
   2 | 22
(2 rows)

EXPLAIN (COSTS off) SELECT idi, idv FROM o_test69 WHERE idi > 1 AND idv IN ('12', '22');
                        QUERY PLAN                        
----------------------------------------------------------
 Custom Scan (o_scan) on o_test69
   Forward index only scan of: o_test69_reg1
   Conds: ((idv = ANY ('{12,22}'::text[])) AND (idi > 1))
(3 rows)

SELECT idi, idv FROM o_test69 WHERE idi > 1 AND idv IN ('12', '22');
 idi | idv 
-----+-----
   2 | 12
   3 | 12
   2 | 22
   3 | 22
(4 rows)

RESET enable_seqscan;
EXPLAIN (COSTS off) SELECT * FROM test66 JOIN o_test69 USING(idi, idv);
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Hash Join
   Hash Cond: ((test66.idi = o_test69.idi) AND ((test66.idv)::text = (o_test69.idv)::text))
   ->  Seq Scan on test66
   ->  Hash
         ->  Seq Scan on o_test69
(5 rows)

SELECT * FROM test66 JOIN o_test69 USING(idi, idv);
 idi | idv | idp 
-----+-----+-----
   1 | 11  | 111
   1 | 12  | 112
   1 | 21  | 121
   1 | 23  | 123
   1 | 32  | 132
   1 | 33  | 133
   2 | 11  | 211
   2 | 12  | 212
   2 | 21  | 221
   2 | 23  | 223
   2 | 32  | 232
   2 | 33  | 233
   3 | 11  | 311
   3 | 12  | 312
   3 | 21  | 321
   3 | 23  | 323
   3 | 32  | 332
   3 | 33  | 333
(18 rows)

set enable_nestloop=off;
EXPLAIN (COSTS off) SELECT * FROM test66 JOIN o_test69 USING(idi, idv);
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Hash Join
   Hash Cond: ((test66.idi = o_test69.idi) AND ((test66.idv)::text = (o_test69.idv)::text))
   ->  Seq Scan on test66
   ->  Hash
         ->  Seq Scan on o_test69
(5 rows)

SELECT * FROM test66 JOIN o_test69 USING(idi, idv);
 idi | idv | idp 
-----+-----+-----
   1 | 11  | 111
   1 | 12  | 112
   1 | 21  | 121
   1 | 23  | 123
   1 | 32  | 132
   1 | 33  | 133
   2 | 11  | 211
   2 | 12  | 212
   2 | 21  | 221
   2 | 23  | 223
   2 | 32  | 232
   2 | 33  | 233
   3 | 11  | 311
   3 | 12  | 312
   3 | 21  | 321
   3 | 23  | 323
   3 | 32  | 332
   3 | 33  | 333
(18 rows)

set enable_hashjoin=off;
EXPLAIN (COSTS off) SELECT * FROM test66 JOIN o_test69 USING(idi, idv);
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Merge Join
   Merge Cond: ((test66.idi = o_test69.idi) AND ((test66.idv)::text = (o_test69.idv)::text))
   ->  Index Only Scan using test66_pkey on test66
   ->  Sort
         Sort Key: o_test69.idi, o_test69.idv
         ->  Seq Scan on o_test69
(6 rows)

SELECT * FROM test66 JOIN o_test69 USING(idi, idv);
 idi | idv | idp 
-----+-----+-----
   1 | 11  | 111
   1 | 12  | 112
   1 | 21  | 121
   1 | 23  | 123
   1 | 32  | 132
   1 | 33  | 133
   2 | 11  | 211
   2 | 12  | 212
   2 | 21  | 221
   2 | 23  | 223
   2 | 32  | 232
   2 | 33  | 233
   3 | 11  | 311
   3 | 12  | 312
   3 | 21  | 321
   3 | 23  | 323
   3 | 32  | 332
   3 | 33  | 333
(18 rows)

set enable_nestloop=on;
set enable_hashjoin=on;
CREATE TABLE o_test70
(
	key int8 not null,
	value int8,
	PRIMARY KEY(key)
) USING orioledb;
CREATE INDEX o_test70_reg ON o_test70(value);
-- Test page split
INSERT INTO o_test70 SELECT i, i + 1 FROM generate_series(1, 1000, 4) AS i;
INSERT INTO o_test70 SELECT i, i + 1 FROM generate_series(1000, 1, -4) AS i;
INSERT INTO o_test70 SELECT i, i + 1 FROM generate_series(999, 1, -4) AS i;
INSERT INTO o_test70 SELECT i, i + 1 FROM generate_series(998, 1, -4) AS i;
SELECT (SELECT array_agg(key) FROM o_test70) =
       (SELECT array_agg(i)::int8[] FROM generate_series(1, 1000) as i);
 ?column? 
----------
 t
(1 row)

SELECT (SELECT array_agg(value) FROM o_test70) =
       (SELECT array_agg(i+1)::int8[] FROM generate_series(1, 1000) as i);
 ?column? 
----------
 t
(1 row)

SELECT count(*)
	FROM o_test70,
	     (SELECT array_agg(i) as keys FROM generate_series(1, 1000) as i) t
	WHERE key = ANY (keys);
 count 
-------
  1000
(1 row)

TRUNCATE o_test70;
-- Test rollback for upsert
INSERT INTO o_test70 SELECT i, i + 1 FROM generate_series(1, 20, 1) AS i;
SELECT value FROM o_test70 WHERE key = 1;
 value 
-------
     2
(1 row)

--SELECT orioledb_tbl_structure('o_test70'::regclass);
BEGIN;
UPDATE o_test70 SET value = value + 2 WHERE key = 1;
--SELECT orioledb_tbl_structure('o_test70'::regclass);
ROLLBACK;
--SELECT orioledb_tbl_structure('o_test70'::regclass);
SELECT value FROM o_test70 WHERE key = 1;
 value 
-------
     2
(1 row)

BEGIN;
UPDATE o_test70 SET value = value + 2 WHERE key = 1;
UPDATE o_test70 SET value = value + 2 WHERE key = 1;
--SELECT orioledb_tbl_structure('o_test70'::regclass);
ROLLBACK;
--SELECT orioledb_tbl_structure('o_test70'::regclass);
SELECT value FROM o_test70 WHERE key = 1;
 value 
-------
     2
(1 row)

-- Test for key update
UPDATE o_test70 SET key = 1001 WHERE key = 1;
SELECT key, value FROM o_test70 WHERE key = 1 OR key = 1001;
 key  | value 
------+-------
 1001 |     2
(1 row)

--SELECT orioledb_tbl_structure('o_test70'::regclass);
-- Test split bug
TRUNCATE o_test70;
INSERT INTO o_test70 SELECT i, i + 1 FROM generate_series(1, 100, 4) AS i;
DELETE FROM o_test70 WHERE key % 4 = 1;
INSERT INTO o_test70 SELECT i, i + 1 FROM generate_series(2, 100, 4) AS i;
SELECT sum(key), sum(value), count(*) FROM o_test70;
 sum  | sum  | count 
------+------+-------
 1250 | 1275 |    25
(1 row)

--SELECT orioledb_tbl_structure('o_test70'::regclass);
TRUNCATE o_test70;
CREATE TABLE o_test71
(
	idf varchar NOT NULL,
	ids int4 NOT NULL,
	idt int4 NOT NULL,
	PRIMARY KEY (ids, idt)
) USING orioledb;
CREATE UNIQUE INDEX o_test71_uniq ON o_test71 (idf, idt);
SELECT orioledb_tbl_indices('o_test71'::regclass);
              orioledb_tbl_indices              
------------------------------------------------
 Index o_test71_pkey                           +
     Index type: primary, unique               +
     Leaf tuple size: 3, non-leaf tuple size: 2+
     Non-leaf tuple fields: ids, idt           +
 Index o_test71_uniq                           +
     Index type: secondary, unique             +
     Leaf tuple size: 3, non-leaf tuple size: 3+
     Non-leaf tuple fields: idf, idt, ids      +
     Leaf tuple fields: idf, idt, ids          +
 
(1 row)

INSERT INTO o_test71 VALUES (1, 2, 3);
SELECT * FROM o_test71 WHERE idf = '1';
 idf | ids | idt 
-----+-----+-----
 1   |   2 |   3
(1 row)

UPDATE o_test71 SET ids = 4 WHERE idf = '1';
SELECT * FROM o_test71;
 idf | ids | idt 
-----+-----+-----
 1   |   4 |   3
(1 row)

SELECT * FROM o_test71 WHERE idf >= '1';
 idf | ids | idt 
-----+-----+-----
 1   |   4 |   3
(1 row)

-- compressed index
CREATE TABLE o_test72
(
	key int8 NOT NULL,
	value int8 NOT NULL
) USING orioledb;
CREATE UNIQUE INDEX o_test72_uniq ON o_test72(value) WITH (compress);
SELECT orioledb_tbl_indices('o_test72'::regclass);
                orioledb_tbl_indices                 
-----------------------------------------------------
 Index ctid_primary                                 +
     Index type: primary, unique, ctid              +
     Leaf tuple size: 3, non-leaf tuple size: 1     +
     Non-leaf tuple fields: ctid                    +
 Index o_test72_uniq                                +
     Index type: secondary, unique, compression = 10+
     Leaf tuple size: 2, non-leaf tuple size: 2     +
     Non-leaf tuple fields: value, ctid             +
     Leaf tuple fields: value, ctid                 +
 
(1 row)

TRUNCATE o_test72;
-- compressed index with invalid compression lvl
CREATE TABLE o_test73
(
	key int8 NOT NULL,
	value int8 NOT NULL
) USING orioledb;
CREATE UNIQUE INDEX o_test73_uniq ON o_test73(value) WITH (compress = -50);
ERROR:  Index compression level must be between -1 and 22
CREATE UNIQUE INDEX o_test73_uniq ON o_test73(value) WITH (compress = 500);
ERROR:  Index compression level must be between -1 and 22
-- compressed index with valid compression lvl
CREATE UNIQUE INDEX o_test73_uniq ON o_test73(value) WITH (compress = 11);
SELECT orioledb_tbl_indices('o_test73'::regclass);
                orioledb_tbl_indices                 
-----------------------------------------------------
 Index ctid_primary                                 +
     Index type: primary, unique, ctid              +
     Leaf tuple size: 3, non-leaf tuple size: 1     +
     Non-leaf tuple fields: ctid                    +
 Index o_test73_uniq                                +
     Index type: secondary, unique, compression = 11+
     Leaf tuple size: 2, non-leaf tuple size: 2     +
     Non-leaf tuple fields: value, ctid             +
     Leaf tuple fields: value, ctid                 +
 
(1 row)

TRUNCATE o_test73;
-- invalid toast compression
CREATE TABLE o_test74
(
	key int8 NOT NULL,
	value text NOT NULL,
	PRIMARY KEY(key)
) USING orioledb WITH (toast_compress = -10);
ERROR:  TOAST compression level must be between -1 and 22
CREATE TABLE o_test74
(
	key int8 NOT NULL,
	value text NOT NULL,
	PRIMARY KEY(key)
) USING orioledb WITH (toast_compress = 1000);
ERROR:  TOAST compression level must be between -1 and 22
-- valid default toast compression
CREATE TABLE o_test74
(
	key int8 NOT NULL,
	value text NOT NULL,
	PRIMARY KEY(key)
) USING orioledb WITH (toast_compress);
SELECT orioledb_tbl_indices('o_test74'::regclass);
              orioledb_tbl_indices              
------------------------------------------------
 Index o_test74_pkey                           +
     Index type: primary, unique               +
     Leaf tuple size: 2, non-leaf tuple size: 1+
     Non-leaf tuple fields: key                +
 
(1 row)

-- a valid toast compression
CREATE TABLE o_test75
(
	key int8 NOT NULL,
	value text NOT NULL,
	PRIMARY KEY(key)
) USING orioledb WITH (toast_compress = 11);
SELECT orioledb_tbl_indices('o_test75'::regclass);
              orioledb_tbl_indices              
------------------------------------------------
 Index o_test75_pkey                           +
     Index type: primary, unique               +
     Leaf tuple size: 2, non-leaf tuple size: 1+
     Non-leaf tuple fields: key                +
 
(1 row)

-- a valid default compression
CREATE TABLE o_test76
(
	key int8 NOT NULL,
	value text NOT NULL,
	PRIMARY KEY(key)
) USING orioledb WITH (compress = 9);
CREATE UNIQUE INDEX o_test76_uniq ON o_test76 (key) WITH (compress);
SELECT orioledb_tbl_indices('o_test76'::regclass);
                orioledb_tbl_indices                 
-----------------------------------------------------
 Index o_test76_pkey                                +
     Index type: primary, unique, compression = 9   +
     Leaf tuple size: 2, non-leaf tuple size: 1     +
     Non-leaf tuple fields: key                     +
 Index o_test76_uniq                                +
     Index type: secondary, unique, compression = 10+
     Leaf tuple size: 1, non-leaf tuple size: 1     +
     Non-leaf tuple fields: key                     +
     Leaf tuple fields: key                         +
 
(1 row)

-- a valid default compression
CREATE TABLE o_test77
(
	key int8 NOT NULL,
	value text NOT NULL
) USING orioledb WITH (compress = 9);
CREATE INDEX o_test77_reg1 ON o_test77 (key);
CREATE INDEX o_test77_reg2 ON o_test77 (key);
SELECT orioledb_tbl_indices('o_test77'::regclass);
                  orioledb_tbl_indices                  
--------------------------------------------------------
 Index ctid_primary                                    +
     Index type: primary, unique, compression = 9, ctid+
     Leaf tuple size: 3, non-leaf tuple size: 1        +
     Non-leaf tuple fields: ctid                       +
 Index o_test77_reg1                                   +
     Index type: secondary, compression = 9            +
     Leaf tuple size: 2, non-leaf tuple size: 2        +
     Non-leaf tuple fields: key, ctid                  +
     Leaf tuple fields: key, ctid                      +
 Index o_test77_reg2                                   +
     Index type: secondary, compression = 9            +
     Leaf tuple size: 2, non-leaf tuple size: 2        +
     Non-leaf tuple fields: key, ctid                  +
     Leaf tuple fields: key, ctid                      +
 
(1 row)

-- valid ctid compression
CREATE TABLE o_test78
(
	key int8 NOT NULL,
	value text NOT NULL
) USING orioledb WITH (primary_compress = 12);
CREATE INDEX o_test78_reg ON o_test78 (key);
SELECT orioledb_tbl_indices('o_test78'::regclass);
                  orioledb_tbl_indices                   
---------------------------------------------------------
 Index ctid_primary                                     +
     Index type: primary, unique, compression = 12, ctid+
     Leaf tuple size: 3, non-leaf tuple size: 1         +
     Non-leaf tuple fields: ctid                        +
 Index o_test78_reg                                     +
     Index type: secondary                              +
     Leaf tuple size: 2, non-leaf tuple size: 2         +
     Non-leaf tuple fields: key, ctid                   +
     Leaf tuple fields: key, ctid                       +
 
(1 row)

-- valid ctid compression
CREATE TABLE o_test79
(
	key int8 NOT NULL,
	value text NOT NULL
) USING orioledb WITH (primary_compress = 7);
SELECT orioledb_tbl_indices('o_test79'::regclass);
                  orioledb_tbl_indices                  
--------------------------------------------------------
 Index ctid_primary                                    +
     Index type: primary, unique, compression = 7, ctid+
     Leaf tuple size: 3, non-leaf tuple size: 1        +
     Non-leaf tuple fields: ctid                       +
 
(1 row)

--- array index
CREATE TABLE o_test80
(
	arr integer[] NOT NULL,
	PRIMARY KEY (arr)
) USING orioledb;
BEGIN;
INSERT INTO o_test80 VALUES ('{1, 2}');
COMMIT;
INSERT INTO o_test80 VALUES ('{2, 3, 4}');
SELECT * FROM o_test80;
   arr   
---------
 {1,2}
 {2,3,4}
(2 rows)

DROP TABLE o_test80;
-- disable compression value
CREATE TABLE o_test81
(
	key int8 NOT NULL,
	value text NOT NULL
) USING orioledb WITH (primary_compress = -1);
SELECT orioledb_tbl_indices('o_test81'::regclass);
              orioledb_tbl_indices              
------------------------------------------------
 Index ctid_primary                            +
     Index type: primary, unique, ctid         +
     Leaf tuple size: 3, non-leaf tuple size: 1+
     Non-leaf tuple fields: ctid               +
 
(1 row)

DROP TABLE o_test81;
CREATE TABLE o_test81
(
	key int8 NOT NULL,
	value text NOT NULL
) USING orioledb WITH (compress = -1);
SELECT orioledb_tbl_indices('o_test81'::regclass);
              orioledb_tbl_indices              
------------------------------------------------
 Index ctid_primary                            +
     Index type: primary, unique, ctid         +
     Leaf tuple size: 3, non-leaf tuple size: 1+
     Non-leaf tuple fields: ctid               +
 
(1 row)

DROP TABLE o_test81;
CREATE TABLE o_test81
(
	key int8 NOT NULL,
	value text NOT NULL,
	PRIMARY KEY (key)
) USING orioledb WITH (toast_compress = -1);
SELECT orioledb_tbl_indices('o_test81'::regclass);
              orioledb_tbl_indices              
------------------------------------------------
 Index o_test81_pkey                           +
     Index type: primary, unique               +
     Leaf tuple size: 2, non-leaf tuple size: 1+
     Non-leaf tuple fields: key                +
 
(1 row)

DROP TABLE o_test81;
CREATE TABLE o_test81
(
	key int8 NOT NULL,
	value int8 NOT NULL,
	PRIMARY KEY (value)
) USING orioledb WITH (compress = -1);
SELECT orioledb_tbl_indices('o_test81'::regclass);
              orioledb_tbl_indices              
------------------------------------------------
 Index o_test81_pkey                           +
     Index type: primary, unique               +
     Leaf tuple size: 2, non-leaf tuple size: 1+
     Non-leaf tuple fields: value              +
 
(1 row)

DROP TABLE o_test81;
CREATE TABLE o_test81
(
	key int8 NOT NULL,
	value int8 NOT NULL,
	PRIMARY KEY(value)
) USING orioledb WITH (compress = -1);
SELECT orioledb_tbl_indices('o_test81'::regclass);
              orioledb_tbl_indices              
------------------------------------------------
 Index o_test81_pkey                           +
     Index type: primary, unique               +
     Leaf tuple size: 2, non-leaf tuple size: 1+
     Non-leaf tuple fields: value              +
 
(1 row)

DROP TABLE o_test81;
SET orioledb.default_compress = 5;
SET orioledb.default_primary_compress = 6;
SET orioledb.default_toast_compress = 7;
CREATE TABLE o_test81
(
	key int8 NOT NULL,
	value int8 NOT NULL,
	PRIMARY KEY (value)
) USING orioledb WITH (compress = -1);
SELECT orioledb_table_description('o_test81'::regclass);
               orioledb_table_description                
---------------------------------------------------------
 Compress = -1, Primary compress = 6, TOAST compress = 7+
  Column |   Type | Collation | Nullable | Droped       +
     key | bigint |    (null) |    false |  false       +
   value | bigint |    (null) |    false |  false       +
 
(1 row)

SELECT orioledb_tbl_indices('o_test81'::regclass);
               orioledb_tbl_indices               
--------------------------------------------------
 Index o_test81_pkey                             +
     Index type: primary, unique, compression = 6+
     Leaf tuple size: 2, non-leaf tuple size: 1  +
     Non-leaf tuple fields: value                +
 
(1 row)

DROP TABLE o_test81;
RESET orioledb.default_compress;
RESET orioledb.default_primary_compress;
RESET orioledb.default_toast_compress;
-- Index rename
CREATE TABLE o_test82
(
	key bigint NOT NULL,
	val int,
	val2 int NOT NULL,
	PRIMARY KEY (key)
) USING orioledb;
CREATE INDEX o_test82_idx1 ON o_test82 (val);
INSERT INTO o_test82 SELECT 1000 + i, 3000 + i, 3000 + i FROM generate_series(1, 500) AS i;
CREATE INDEX o_test82_idx2 ON o_test82 (val2);
SELECT orioledb_tbl_indices('o_test82'::regclass);
              orioledb_tbl_indices              
------------------------------------------------
 Index o_test82_pkey                           +
     Index type: primary, unique               +
     Leaf tuple size: 3, non-leaf tuple size: 1+
     Non-leaf tuple fields: key                +
 Index o_test82_idx1                           +
     Index type: secondary                     +
     Leaf tuple size: 2, non-leaf tuple size: 2+
     Non-leaf tuple fields: val, key           +
     Leaf tuple fields: val, key               +
 Index o_test82_idx2                           +
     Index type: secondary                     +
     Leaf tuple size: 2, non-leaf tuple size: 2+
     Non-leaf tuple fields: val2, key          +
     Leaf tuple fields: val2, key              +
 
(1 row)

SET enable_seqscan = off;
SET enable_bitmapscan = off;
SELECT smart_explain(
'EXPLAIN (COSTS off) WITH o_test82_all AS (
    SELECT * FROM o_test82
		WHERE val2 > 0 AND val > 0
		ORDER BY val2
) SELECT COUNT(*) FROM o_test82_all;');
                smart_explain                 
----------------------------------------------
 Aggregate
   ->  Custom Scan (o_scan) on o_test82
         Filter: (val > 0)
         Forward index scan of: o_test82_idx2
         Conds: (val2 > 0)
(5 rows)

WITH o_test82_all AS (
    SELECT * FROM o_test82
		WHERE val2 > 0 AND val > 0
		ORDER BY val2
) SELECT COUNT(*) FROM o_test82_all;
 count 
-------
   500
(1 row)

BEGIN;
ALTER INDEX o_test82_idx2 RENAME TO o_test82_idx2_renamed;
ROLLBACK;
SELECT orioledb_tbl_indices('o_test82'::regclass);
              orioledb_tbl_indices              
------------------------------------------------
 Index o_test82_pkey                           +
     Index type: primary, unique               +
     Leaf tuple size: 3, non-leaf tuple size: 1+
     Non-leaf tuple fields: key                +
 Index o_test82_idx1                           +
     Index type: secondary                     +
     Leaf tuple size: 2, non-leaf tuple size: 2+
     Non-leaf tuple fields: val, key           +
     Leaf tuple fields: val, key               +
 Index o_test82_idx2                           +
     Index type: secondary                     +
     Leaf tuple size: 2, non-leaf tuple size: 2+
     Non-leaf tuple fields: val2, key          +
     Leaf tuple fields: val2, key              +
 
(1 row)

SELECT smart_explain(
'EXPLAIN (COSTS off) WITH o_test82_all AS (
    SELECT * FROM o_test82
		WHERE val2 > 0 AND val > 0
		ORDER BY val2
) SELECT COUNT(*) FROM o_test82_all;');
                smart_explain                 
----------------------------------------------
 Aggregate
   ->  Custom Scan (o_scan) on o_test82
         Filter: (val > 0)
         Forward index scan of: o_test82_idx2
         Conds: (val2 > 0)
(5 rows)

WITH o_test82_all AS (
    SELECT * FROM o_test82
		WHERE val2 > 0 AND val > 0
		ORDER BY val2
) SELECT COUNT(*) FROM o_test82_all;
 count 
-------
   500
(1 row)

ALTER INDEX o_test82_idx2 RENAME TO o_test82_idx2_renamed;
SELECT orioledb_tbl_indices('o_test82'::regclass);
              orioledb_tbl_indices              
------------------------------------------------
 Index o_test82_pkey                           +
     Index type: primary, unique               +
     Leaf tuple size: 3, non-leaf tuple size: 1+
     Non-leaf tuple fields: key                +
 Index o_test82_idx1                           +
     Index type: secondary                     +
     Leaf tuple size: 2, non-leaf tuple size: 2+
     Non-leaf tuple fields: val, key           +
     Leaf tuple fields: val, key               +
 Index o_test82_idx2_renamed                   +
     Index type: secondary                     +
     Leaf tuple size: 2, non-leaf tuple size: 2+
     Non-leaf tuple fields: val2, key          +
     Leaf tuple fields: val2, key              +
 
(1 row)

SELECT smart_explain(
'EXPLAIN (COSTS off) WITH o_test82_all AS (
    SELECT * FROM o_test82
		WHERE val2 > 0 AND val > 0
		ORDER BY val2
) SELECT COUNT(*) FROM o_test82_all;');
                    smart_explain                     
------------------------------------------------------
 Aggregate
   ->  Custom Scan (o_scan) on o_test82
         Filter: (val > 0)
         Forward index scan of: o_test82_idx2_renamed
         Conds: (val2 > 0)
(5 rows)

WITH o_test82_all AS (
    SELECT * FROM o_test82
		WHERE val2 > 0 AND val > 0
		ORDER BY val2
) SELECT COUNT(*) FROM o_test82_all;
 count 
-------
   500
(1 row)

RESET enable_seqscan;
RESET enable_bitmapscan;
DROP INDEX o_test82_idx2; -- fail
ERROR:  index "o_test82_idx2" does not exist
DROP INDEX o_test82_idx2_renamed; -- success
SELECT orioledb_tbl_indices('o_test82'::regclass);
              orioledb_tbl_indices              
------------------------------------------------
 Index o_test82_pkey                           +
     Index type: primary, unique               +
     Leaf tuple size: 3, non-leaf tuple size: 1+
     Non-leaf tuple fields: key                +
 Index o_test82_idx1                           +
     Index type: secondary                     +
     Leaf tuple size: 2, non-leaf tuple size: 2+
     Non-leaf tuple fields: val, key           +
     Leaf tuple fields: val, key               +
 
(1 row)

-- Column rename
CREATE TABLE o_test83
(
	key bigint NOT NULL,
	val int,
	val2 int NOT NULL,
	PRIMARY KEY (key)
) USING orioledb;
CREATE INDEX o_test83_idx1 ON o_test83 (val, val2);
BEGIN;
ALTER TABLE o_test83
RENAME COLUMN val TO vala;
ROLLBACK;
SELECT orioledb_table_description('o_test83'::regclass);
                orioledb_table_description                 
-----------------------------------------------------------
 Compress = -1, Primary compress = -1, TOAST compress = -1+
  Column |    Type | Collation | Nullable | Droped        +
     key |  bigint |    (null) |    false |  false        +
     val | integer |    (null) |     true |  false        +
    val2 | integer |    (null) |    false |  false        +
 
(1 row)

SELECT orioledb_tbl_indices('o_test83'::regclass);
              orioledb_tbl_indices              
------------------------------------------------
 Index o_test83_pkey                           +
     Index type: primary, unique               +
     Leaf tuple size: 3, non-leaf tuple size: 1+
     Non-leaf tuple fields: key                +
 Index o_test83_idx1                           +
     Index type: secondary                     +
     Leaf tuple size: 3, non-leaf tuple size: 3+
     Non-leaf tuple fields: val, val2, key     +
     Leaf tuple fields: val, val2, key         +
 
(1 row)

ALTER TABLE o_test83
RENAME COLUMN val TO vala;
SELECT orioledb_table_description('o_test83'::regclass);
                orioledb_table_description                 
-----------------------------------------------------------
 Compress = -1, Primary compress = -1, TOAST compress = -1+
  Column |    Type | Collation | Nullable | Droped        +
     key |  bigint |    (null) |    false |  false        +
    vala | integer |    (null) |     true |  false        +
    val2 | integer |    (null) |    false |  false        +
 
(1 row)

SELECT orioledb_tbl_indices('o_test83'::regclass);
              orioledb_tbl_indices              
------------------------------------------------
 Index o_test83_pkey                           +
     Index type: primary, unique               +
     Leaf tuple size: 3, non-leaf tuple size: 1+
     Non-leaf tuple fields: key                +
 Index o_test83_idx1                           +
     Index type: secondary                     +
     Leaf tuple size: 3, non-leaf tuple size: 3+
     Non-leaf tuple fields: vala, val2, key    +
     Leaf tuple fields: vala, val2, key        +
 
(1 row)

-- Check that partial indices also updated
CREATE TABLE o_test_partial_idx_update
(
  id bigint NOT NULL,
  user_id bigint,
  am bigint,
  CONSTRAINT o_test_partial_idx_update_pkey PRIMARY KEY (id),
  CONSTRAINT o_test_partial_idx_update_amount_check CHECK (am >= 0)
) USING orioledb;
CREATE INDEX o_test_partial_idx_update_idx1
	ON o_test_partial_idx_update (user_id, am);
CREATE INDEX o_test_partial_idx_update_idx2
	ON o_test_partial_idx_update (user_id) WHERE am > 0;
INSERT INTO o_test_partial_idx_update VALUES (1, 100500, 100);
SELECT * FROM o_test_partial_idx_update;
 id | user_id | am  
----+---------+-----
  1 |  100500 | 100
(1 row)

SELECT * FROM o_test_partial_idx_update WHERE user_id=100500 and am > 0;
 id | user_id | am  
----+---------+-----
  1 |  100500 | 100
(1 row)

UPDATE o_test_partial_idx_update SET am=0 WHERE user_id=100500;
SELECT * FROM o_test_partial_idx_update;
 id | user_id | am 
----+---------+----
  1 |  100500 |  0
(1 row)

EXPLAIN SELECT * FROM o_test_partial_idx_update
	WHERE user_id=100500 and am > 0;
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Custom Scan (o_scan) on o_test_partial_idx_update  (cost=4.13..9.48 rows=2 width=24)
   Bitmap heap scan
   Recheck Cond: ((user_id = 100500) AND (am > 0))
   ->  Bitmap Index Scan on o_test_partial_idx_update_idx2  (cost=0.00..4.13 rows=2 width=0)
         Index Cond: (user_id = 100500)
(5 rows)

SELECT * FROM o_test_partial_idx_update WHERE user_id=100500 and am > 0;
 id | user_id | am 
----+---------+----
(0 rows)

SET enable_bitmapscan = off;
EXPLAIN SELECT * FROM o_test_partial_idx_update
	WHERE user_id=100500 and am > 0;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Custom Scan (o_scan) on o_test_partial_idx_update  (cost=0.12..12.15 rows=2 width=24)
   Forward index scan of: o_test_partial_idx_update_idx2
   Conds: (user_id = 100500)
(3 rows)

SELECT * FROM o_test_partial_idx_update WHERE user_id=100500 and am > 0;
 id | user_id | am 
----+---------+----
(0 rows)

SET enable_bitmapscan = on;
CREATE TABLE o_test_nulls
(
  id bigint NOT NULL,
  value bigint,
  PRIMARY KEY (id)
) USING orioledb;
INSERT INTO o_test_nulls (SELECT i, i FROM generate_series(1,10000) i);
INSERT INTO o_test_nulls (SELECT i, NULL FROM generate_series(10001,11000) i);
CREATE INDEX o_test_nulls_value_idx ON o_test_nulls(value NULLS FIRST);
SELECT count(*) FROM o_test_nulls WHERE value IS NULL;
 count 
-------
  1000
(1 row)

SELECT count(*) FROM o_test_nulls WHERE value IS NOT NULL;
 count 
-------
 10000
(1 row)

DROP INDEX o_test_nulls_value_idx;
CREATE INDEX o_test_nulls_value_idx ON o_test_nulls(value NULLS LAST);
SELECT count(*) FROM o_test_nulls WHERE value IS NULL;
 count 
-------
  1000
(1 row)

SELECT count(*) FROM o_test_nulls WHERE value IS NOT NULL;
 count 
-------
 10000
(1 row)

DROP INDEX o_test_nulls_value_idx;
CREATE INDEX o_test_nulls_value_idx ON o_test_nulls(value ASC NULLS FIRST);
SELECT count(*) FROM o_test_nulls WHERE value IS NULL;
 count 
-------
  1000
(1 row)

SELECT count(*) FROM o_test_nulls WHERE value IS NOT NULL;
 count 
-------
 10000
(1 row)

DROP INDEX o_test_nulls_value_idx;
CREATE INDEX o_test_nulls_value_idx ON o_test_nulls(value ASC NULLS LAST);
SELECT count(*) FROM o_test_nulls WHERE value IS NULL;
 count 
-------
  1000
(1 row)

SELECT count(*) FROM o_test_nulls WHERE value IS NOT NULL;
 count 
-------
 10000
(1 row)

DROP INDEX o_test_nulls_value_idx;
CREATE INDEX o_test_nulls_value_idx ON o_test_nulls(value DESC NULLS FIRST);
SELECT count(*) FROM o_test_nulls WHERE value IS NULL;
 count 
-------
  1000
(1 row)

SELECT count(*) FROM o_test_nulls WHERE value IS NOT NULL;
 count 
-------
 10000
(1 row)

DROP INDEX o_test_nulls_value_idx;
CREATE INDEX o_test_nulls_value_idx ON o_test_nulls(value DESC NULLS LAST);
SELECT count(*) FROM o_test_nulls WHERE value IS NULL;
 count 
-------
  1000
(1 row)

SELECT count(*) FROM o_test_nulls WHERE value IS NOT NULL;
 count 
-------
 10000
(1 row)

DROP INDEX o_test_nulls_value_idx;
DROP TABLE o_test_nulls CASCADE;
-- Check that build of index with same fields as pkey succeeds
SET enable_seqscan = off;
CREATE TABLE IF NOT EXISTS o_test_unique_as_pkey (
	key integer NOT NULL,
	val integer NOT NULL,
	val2 integer NOT NULL,
	PRIMARY KEY(key, val)
) USING orioledb;
CREATE UNIQUE INDEX o_test_unique_as_pkey_ix1
	ON o_test_unique_as_pkey (val, key);
INSERT INTO o_test_unique_as_pkey (key, val, val2)
	(SELECT val, val * 100, val * 1000  FROM generate_series(1, 5) val);
\d+ o_test_unique_as_pkey
                          Table "indices.o_test_unique_as_pkey"
 Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
--------+---------+-----------+----------+---------+---------+--------------+-------------
 key    | integer |           | not null |         | plain   |              | 
 val    | integer |           | not null |         | plain   |              | 
 val2   | integer |           | not null |         | plain   |              | 
Indexes:
    "o_test_unique_as_pkey_pkey" PRIMARY KEY, btree (key, val)
    "o_test_unique_as_pkey_ix1" UNIQUE, btree (val, key)

SELECT orioledb_tbl_indices('o_test_unique_as_pkey'::regclass);
              orioledb_tbl_indices              
------------------------------------------------
 Index o_test_unique_as_pkey_pkey              +
     Index type: primary, unique               +
     Leaf tuple size: 3, non-leaf tuple size: 2+
     Non-leaf tuple fields: key, val           +
 Index o_test_unique_as_pkey_ix1               +
     Index type: secondary, unique             +
     Leaf tuple size: 2, non-leaf tuple size: 2+
     Non-leaf tuple fields: val, key           +
     Leaf tuple fields: val, key               +
 
(1 row)

EXPLAIN SELECT * FROM o_test_unique_as_pkey ORDER BY val;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Custom Scan (o_scan) on o_test_unique_as_pkey  (cost=0.15..74.87 rows=2048 width=12)
   Forward index scan of: o_test_unique_as_pkey_ix1
(2 rows)

SELECT * FROM o_test_unique_as_pkey ORDER BY val;
 key | val | val2 
-----+-----+------
   1 | 100 | 1000
   2 | 200 | 2000
   3 | 300 | 3000
   4 | 400 | 4000
   5 | 500 | 5000
(5 rows)

CREATE UNIQUE INDEX o_test_unique_as_pkey_ix2
	ON o_test_unique_as_pkey (val, key);
\d+ o_test_unique_as_pkey
                          Table "indices.o_test_unique_as_pkey"
 Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
--------+---------+-----------+----------+---------+---------+--------------+-------------
 key    | integer |           | not null |         | plain   |              | 
 val    | integer |           | not null |         | plain   |              | 
 val2   | integer |           | not null |         | plain   |              | 
Indexes:
    "o_test_unique_as_pkey_pkey" PRIMARY KEY, btree (key, val)
    "o_test_unique_as_pkey_ix1" UNIQUE, btree (val, key)
    "o_test_unique_as_pkey_ix2" UNIQUE, btree (val, key)

SELECT orioledb_tbl_indices('o_test_unique_as_pkey'::regclass);
              orioledb_tbl_indices              
------------------------------------------------
 Index o_test_unique_as_pkey_pkey              +
     Index type: primary, unique               +
     Leaf tuple size: 3, non-leaf tuple size: 2+
     Non-leaf tuple fields: key, val           +
 Index o_test_unique_as_pkey_ix1               +
     Index type: secondary, unique             +
     Leaf tuple size: 2, non-leaf tuple size: 2+
     Non-leaf tuple fields: val, key           +
     Leaf tuple fields: val, key               +
 Index o_test_unique_as_pkey_ix2               +
     Index type: secondary, unique             +
     Leaf tuple size: 2, non-leaf tuple size: 2+
     Non-leaf tuple fields: val, key           +
     Leaf tuple fields: val, key               +
 
(1 row)

EXPLAIN SELECT * FROM o_test_unique_as_pkey ORDER BY val;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Custom Scan (o_scan) on o_test_unique_as_pkey  (cost=0.13..8.21 rows=5 width=12)
   Forward index scan of: o_test_unique_as_pkey_ix2
(2 rows)

SELECT * FROM o_test_unique_as_pkey ORDER BY val;
 key | val | val2 
-----+-----+------
   1 | 100 | 1000
   2 | 200 | 2000
   3 | 300 | 3000
   4 | 400 | 4000
   5 | 500 | 5000
(5 rows)

RESET enable_seqscan;
CREATE TABLE o_test_renames
(
	key bigint NOT NULL,
	val int,
	PRIMARY KEY (key)
) USING orioledb;
CREATE INDEX o_test_renames_idx ON o_test_renames (val);
\d o_test_renames
          Table "indices.o_test_renames"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 key    | bigint  |           | not null | 
 val    | integer |           |          | 
Indexes:
    "o_test_renames_pkey" PRIMARY KEY, btree (key)
    "o_test_renames_idx" btree (val)

SELECT orioledb_table_description('o_test_renames'::regclass);
                orioledb_table_description                 
-----------------------------------------------------------
 Compress = -1, Primary compress = -1, TOAST compress = -1+
  Column |    Type | Collation | Nullable | Droped        +
     key |  bigint |    (null) |    false |  false        +
     val | integer |    (null) |     true |  false        +
 
(1 row)

SELECT description FROM orioledb_table WHERE reloid = 'o_test_renames'::regclass;
                        description                        
-----------------------------------------------------------
 Compress = -1, Primary compress = -1, TOAST compress = -1+
  Column |    Type | Collation | Nullable | Droped        +
     key |  bigint |    (null) |    false |  false        +
     val | integer |    (null) |     true |  false        +
 
(1 row)

\d o_test_renames_idx
  Index "indices.o_test_renames_idx"
 Column |  Type   | Key? | Definition 
--------+---------+------+------------
 val    | integer | yes  | val
btree, for table "indices.o_test_renames"

SELECT orioledb_tbl_indices('o_test_renames'::regclass);
              orioledb_tbl_indices              
------------------------------------------------
 Index o_test_renames_pkey                     +
     Index type: primary, unique               +
     Leaf tuple size: 2, non-leaf tuple size: 1+
     Non-leaf tuple fields: key                +
 Index o_test_renames_idx                      +
     Index type: secondary                     +
     Leaf tuple size: 2, non-leaf tuple size: 2+
     Non-leaf tuple fields: val, key           +
     Leaf tuple fields: val, key               +
 
(1 row)

SELECT description FROM orioledb_index WHERE index_reloid = 'o_test_renames_idx'::regclass;
                    description                     
----------------------------------------------------
  Column |    Type | Collation | Nullable | Droped +
     val | integer |    (null) |     true |  false +
     key |  bigint |    (null) |    false |  false +
                                                   +
 Key fields: (val, key)                            +
 
(1 row)

ALTER TABLE o_test_renames_idx RENAME TO o_test_renames_idx_as_tbl;
\d o_test_renames
          Table "indices.o_test_renames"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 key    | bigint  |           | not null | 
 val    | integer |           |          | 
Indexes:
    "o_test_renames_pkey" PRIMARY KEY, btree (key)
    "o_test_renames_idx_as_tbl" btree (val)

\d o_test_renames_idx
ALTER INDEX o_test_renames RENAME TO o_test_renames_as_ix;
\d o_test_renames
\d o_test_renames_as_ix
       Table "indices.o_test_renames_as_ix"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 key    | bigint  |           | not null | 
 val    | integer |           |          | 
Indexes:
    "o_test_renames_pkey" PRIMARY KEY, btree (key)
    "o_test_renames_idx_as_tbl" btree (val)

ALTER TABLE o_test_renames_as_ix RENAME COLUMN o_test_renames_idx_as_tbl TO val2;
ERROR:  column "o_test_renames_idx_as_tbl" does not exist
\d o_test_renames_as_ix
       Table "indices.o_test_renames_as_ix"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 key    | bigint  |           | not null | 
 val    | integer |           |          | 
Indexes:
    "o_test_renames_pkey" PRIMARY KEY, btree (key)
    "o_test_renames_idx_as_tbl" btree (val)

CREATE TABLE o_test_subexpr_collate (
    val_1 int PRIMARY KEY,
    val_2 text COLLATE "C" NOT NULL
)USING orioledb;
INSERT INTO o_test_subexpr_collate
	SELECT v, 'XXX' || v FROM generate_series(1, 5) v;
SET enable_seqscan = off;
CREATE INDEX o_test_subexpr_collate_ix1 ON o_test_subexpr_collate (val_2);
EXPLAIN (COSTS OFF) SELECT * FROM o_test_subexpr_collate ORDER BY val_2;
                        QUERY PLAN                        
----------------------------------------------------------
 Custom Scan (o_scan) on o_test_subexpr_collate
   Forward index only scan of: o_test_subexpr_collate_ix1
(2 rows)

SELECT * FROM o_test_subexpr_collate ORDER BY val_2;
 val_1 | val_2 
-------+-------
     1 | XXX1
     2 | XXX2
     3 | XXX3
     4 | XXX4
     5 | XXX5
(5 rows)

CREATE INDEX o_test_subexpr_collate_ix2
	ON o_test_subexpr_collate (val_2 COLLATE "C");
EXPLAIN (COSTS OFF)
	SELECT * FROM o_test_subexpr_collate ORDER BY val_2 COLLATE "C";
                        QUERY PLAN                        
----------------------------------------------------------
 Custom Scan (o_scan) on o_test_subexpr_collate
   Forward index only scan of: o_test_subexpr_collate_ix2
(2 rows)

SELECT * FROM o_test_subexpr_collate ORDER BY val_2 COLLATE "C";
 val_1 | val_2 
-------+-------
     1 | XXX1
     2 | XXX2
     3 | XXX3
     4 | XXX4
     5 | XXX5
(5 rows)

CREATE INDEX o_test_subexpr_collate_ix3
	ON o_test_subexpr_collate ((val_2 COLLATE "C"));
EXPLAIN (COSTS OFF)
	SELECT * FROM o_test_subexpr_collate ORDER BY (val_2 COLLATE "C");
                        QUERY PLAN                        
----------------------------------------------------------
 Custom Scan (o_scan) on o_test_subexpr_collate
   Forward index only scan of: o_test_subexpr_collate_ix3
(2 rows)

SELECT * FROM o_test_subexpr_collate ORDER BY (val_2 COLLATE "C");
 val_1 | val_2 
-------+-------
     1 | XXX1
     2 | XXX2
     3 | XXX3
     4 | XXX4
     5 | XXX5
(5 rows)

ALTER TABLE o_test_subexpr_collate DROP CONSTRAINT o_test_subexpr_collate_pkey;
EXPLAIN (COSTS OFF)
	SELECT * FROM o_test_subexpr_collate ORDER BY (val_2 COLLATE "C");
                     QUERY PLAN                      
-----------------------------------------------------
 Custom Scan (o_scan) on o_test_subexpr_collate
   Forward index scan of: o_test_subexpr_collate_ix3
(2 rows)

SELECT * FROM o_test_subexpr_collate ORDER BY (val_2 COLLATE "C");
 val_1 | val_2 
-------+-------
     1 | XXX1
     2 | XXX2
     3 | XXX3
     4 | XXX4
     5 | XXX5
(5 rows)

CREATE TABLE o_test_reuse_multiple_indices (
	val_1 int PRIMARY KEY,
	val_2 text COLLATE "C" NOT NULL,
	val_3 int,
	val_4 int,
	val_5 int
) USING orioledb;
CREATE INDEX o_test_reuse_multiple_indices_ix1
	ON o_test_reuse_multiple_indices(val_2);
CREATE INDEX o_test_reuse_multiple_indices_ix2
	ON o_test_reuse_multiple_indices(val_3 DESC, val_2 DESC);
CREATE INDEX o_test_reuse_multiple_indices_ix3
	ON o_test_reuse_multiple_indices(val_4) INCLUDE (val_2);
CREATE INDEX o_test_reuse_multiple_indices_ix4
	ON o_test_reuse_multiple_indices(val_5) INCLUDE (val_1, val_2);
SELECT orioledb_table_description('o_test_reuse_multiple_indices'::regclass);
                orioledb_table_description                 
-----------------------------------------------------------
 Compress = -1, Primary compress = -1, TOAST compress = -1+
  Column |    Type | Collation | Nullable | Droped        +
   val_1 | integer |    (null) |    false |  false        +
   val_2 |    text |         C |    false |  false        +
   val_3 | integer |    (null) |     true |  false        +
   val_4 | integer |    (null) |     true |  false        +
   val_5 | integer |    (null) |     true |  false        +
 
(1 row)

SELECT orioledb_tbl_indices('o_test_reuse_multiple_indices'::regclass);
              orioledb_tbl_indices              
------------------------------------------------
 Index o_test_reuse_multiple_indices_pkey      +
     Index type: primary, unique               +
     Leaf tuple size: 5, non-leaf tuple size: 1+
     Non-leaf tuple fields: val_1              +
 Index o_test_reuse_multiple_indices_ix1       +
     Index type: secondary                     +
     Leaf tuple size: 2, non-leaf tuple size: 2+
     Non-leaf tuple fields: val_2, val_1       +
     Leaf tuple fields: val_2, val_1           +
 Index o_test_reuse_multiple_indices_ix2       +
     Index type: secondary                     +
     Leaf tuple size: 3, non-leaf tuple size: 3+
     Non-leaf tuple fields: val_3, val_2, val_1+
     Leaf tuple fields: val_3, val_2, val_1    +
 Index o_test_reuse_multiple_indices_ix3       +
     Index type: secondary                     +
     Leaf tuple size: 3, non-leaf tuple size: 3+
     Non-leaf tuple fields: val_4, val_2, val_1+
     Leaf tuple fields: val_4, val_2, val_1    +
 Index o_test_reuse_multiple_indices_ix4       +
     Index type: secondary                     +
     Leaf tuple size: 3, non-leaf tuple size: 3+
     Non-leaf tuple fields: val_5, val_1, val_2+
     Leaf tuple fields: val_5, val_1, val_2    +
 
(1 row)

\d+ o_test_reuse_multiple_indices
                       Table "indices.o_test_reuse_multiple_indices"
 Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
--------+---------+-----------+----------+---------+----------+--------------+-------------
 val_1  | integer |           | not null |         | plain    |              | 
 val_2  | text    | C         | not null |         | extended |              | 
 val_3  | integer |           |          |         | plain    |              | 
 val_4  | integer |           |          |         | plain    |              | 
 val_5  | integer |           |          |         | plain    |              | 
Indexes:
    "o_test_reuse_multiple_indices_pkey" PRIMARY KEY, btree (val_1)
    "o_test_reuse_multiple_indices_ix1" btree (val_2)
    "o_test_reuse_multiple_indices_ix2" btree (val_3 DESC, val_2 DESC)
    "o_test_reuse_multiple_indices_ix3" btree (val_4) INCLUDE (val_2)
    "o_test_reuse_multiple_indices_ix4" btree (val_5) INCLUDE (val_1, val_2)

\d+ o_test_reuse_multiple_indices_ix1
      Index "indices.o_test_reuse_multiple_indices_ix1"
 Column | Type | Key? | Definition | Storage  | Stats target 
--------+------+------+------------+----------+--------------
 val_2  | text | yes  | val_2      | extended | 
btree, for table "indices.o_test_reuse_multiple_indices"

\d+ o_test_reuse_multiple_indices_ix2
       Index "indices.o_test_reuse_multiple_indices_ix2"
 Column |  Type   | Key? | Definition | Storage  | Stats target 
--------+---------+------+------------+----------+--------------
 val_3  | integer | yes  | val_3      | plain    | 
 val_2  | text    | yes  | val_2      | extended | 
btree, for table "indices.o_test_reuse_multiple_indices"

\d+ o_test_reuse_multiple_indices_ix3
       Index "indices.o_test_reuse_multiple_indices_ix3"
 Column |  Type   | Key? | Definition | Storage  | Stats target 
--------+---------+------+------------+----------+--------------
 val_4  | integer | yes  | val_4      | plain    | 
 val_2  | text    | no   | val_2      | extended | 
btree, for table "indices.o_test_reuse_multiple_indices"

\d+ o_test_reuse_multiple_indices_ix4
       Index "indices.o_test_reuse_multiple_indices_ix4"
 Column |  Type   | Key? | Definition | Storage  | Stats target 
--------+---------+------+------------+----------+--------------
 val_5  | integer | yes  | val_5      | plain    | 
 val_1  | integer | no   | val_1      | plain    | 
 val_2  | text    | no   | val_2      | extended | 
btree, for table "indices.o_test_reuse_multiple_indices"

INSERT INTO o_test_reuse_multiple_indices
	SELECT v, 'XXX' || v, v * 10, v * 100, v * 1000
		FROM generate_series(1, 5) v;
SELECT orioledb_tbl_structure('o_test_reuse_multiple_indices'::regclass,
							  'nue');
                        orioledb_tbl_structure                        
----------------------------------------------------------------------
 Index o_test_reuse_multiple_indices_pkey contents                   +
 Page 0: level = 0, maxKeyLen = 8, nVacatedBytes = 0                 +
 state = free, datoid equal, relnode equal, ix_type = primary, dirty +
     Leftmost, Rightmost                                             +
   Chunk 0: offset = 0, location = 256, hikey location = 64          +
     Item 0: offset = 272, tuple = ('1', 'XXX1', '10', '100', '1000')+
     Item 1: offset = 320, tuple = ('2', 'XXX2', '20', '200', '2000')+
     Item 2: offset = 368, tuple = ('3', 'XXX3', '30', '300', '3000')+
     Item 3: offset = 416, tuple = ('4', 'XXX4', '40', '400', '4000')+
     Item 4: offset = 464, tuple = ('5', 'XXX5', '50', '500', '5000')+
                                                                     +
 Index o_test_reuse_multiple_indices_ix1 contents                    +
 Page 0: level = 0, maxKeyLen = 24, nVacatedBytes = 0                +
 state = free, datoid equal, relnode equal, ix_type = regular, dirty +
     Leftmost, Rightmost                                             +
   Chunk 0: offset = 0, location = 256, hikey location = 64          +
     Item 0: offset = 272, tuple = ('XXX1', '1')                     +
     Item 1: offset = 312, tuple = ('XXX2', '2')                     +
     Item 2: offset = 352, tuple = ('XXX3', '3')                     +
     Item 3: offset = 392, tuple = ('XXX4', '4')                     +
     Item 4: offset = 432, tuple = ('XXX5', '5')                     +
                                                                     +
 Index o_test_reuse_multiple_indices_ix2 contents                    +
 Page 0: level = 0, maxKeyLen = 24, nVacatedBytes = 0                +
 state = free, datoid equal, relnode equal, ix_type = regular, dirty +
     Leftmost, Rightmost                                             +
   Chunk 0: offset = 0, location = 256, hikey location = 64          +
     Item 0: offset = 272, tuple = ('50', 'XXX5', '5')               +
     Item 1: offset = 312, tuple = ('40', 'XXX4', '4')               +
     Item 2: offset = 352, tuple = ('30', 'XXX3', '3')               +
     Item 3: offset = 392, tuple = ('20', 'XXX2', '2')               +
     Item 4: offset = 432, tuple = ('10', 'XXX1', '1')               +
                                                                     +
 Index o_test_reuse_multiple_indices_ix3 contents                    +
 Page 0: level = 0, maxKeyLen = 24, nVacatedBytes = 0                +
 state = free, datoid equal, relnode equal, ix_type = regular, dirty +
     Leftmost, Rightmost                                             +
   Chunk 0: offset = 0, location = 256, hikey location = 64          +
     Item 0: offset = 272, tuple = ('100', 'XXX1', '1')              +
     Item 1: offset = 312, tuple = ('200', 'XXX2', '2')              +
     Item 2: offset = 352, tuple = ('300', 'XXX3', '3')              +
     Item 3: offset = 392, tuple = ('400', 'XXX4', '4')              +
     Item 4: offset = 432, tuple = ('500', 'XXX5', '5')              +
                                                                     +
 Index o_test_reuse_multiple_indices_ix4 contents                    +
 Page 0: level = 0, maxKeyLen = 24, nVacatedBytes = 0                +
 state = free, datoid equal, relnode equal, ix_type = regular, dirty +
     Leftmost, Rightmost                                             +
   Chunk 0: offset = 0, location = 256, hikey location = 64          +
     Item 0: offset = 272, tuple = ('1000', '1', 'XXX1')             +
     Item 1: offset = 312, tuple = ('2000', '2', 'XXX2')             +
     Item 2: offset = 352, tuple = ('3000', '3', 'XXX3')             +
     Item 3: offset = 392, tuple = ('4000', '4', 'XXX4')             +
     Item 4: offset = 432, tuple = ('5000', '5', 'XXX5')             +
                                                                     +
 Index toast: not loaded                                             +
 
(1 row)

EXPLAIN (COSTS OFF)
	SELECT val_2 FROM o_test_reuse_multiple_indices ORDER BY val_2;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Custom Scan (o_scan) on o_test_reuse_multiple_indices
   Forward index only scan of: o_test_reuse_multiple_indices_ix1
(2 rows)

SELECT val_2 FROM o_test_reuse_multiple_indices ORDER BY val_2;
 val_2 
-------
 XXX1
 XXX2
 XXX3
 XXX4
 XXX5
(5 rows)

EXPLAIN (COSTS OFF)
	SELECT val_1, val_2, val_3 FROM o_test_reuse_multiple_indices
		ORDER BY val_3 DESC;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Custom Scan (o_scan) on o_test_reuse_multiple_indices
   Forward index only scan of: o_test_reuse_multiple_indices_ix2
(2 rows)

SELECT val_1, val_2, val_3 FROM o_test_reuse_multiple_indices
	ORDER BY val_3 DESC;
 val_1 | val_2 | val_3 
-------+-------+-------
     5 | XXX5  |    50
     4 | XXX4  |    40
     3 | XXX3  |    30
     2 | XXX2  |    20
     1 | XXX1  |    10
(5 rows)

EXPLAIN (COSTS OFF)
	SELECT val_1, val_2, val_4 FROM o_test_reuse_multiple_indices
		ORDER BY val_4;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Custom Scan (o_scan) on o_test_reuse_multiple_indices
   Forward index only scan of: o_test_reuse_multiple_indices_ix3
(2 rows)

SELECT val_1, val_2, val_4 FROM o_test_reuse_multiple_indices
	ORDER BY val_4;
 val_1 | val_2 | val_4 
-------+-------+-------
     1 | XXX1  |   100
     2 | XXX2  |   200
     3 | XXX3  |   300
     4 | XXX4  |   400
     5 | XXX5  |   500
(5 rows)

EXPLAIN (COSTS OFF)
	SELECT val_1, val_2, val_5 FROM o_test_reuse_multiple_indices
		ORDER BY val_5;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Custom Scan (o_scan) on o_test_reuse_multiple_indices
   Forward index only scan of: o_test_reuse_multiple_indices_ix4
(2 rows)

SELECT val_1, val_2, val_5 FROM o_test_reuse_multiple_indices ORDER BY val_5;
 val_1 | val_2 | val_5 
-------+-------+-------
     1 | XXX1  |  1000
     2 | XXX2  |  2000
     3 | XXX3  |  3000
     4 | XXX4  |  4000
     5 | XXX5  |  5000
(5 rows)

ALTER TABLE o_test_reuse_multiple_indices
	ALTER val_2 TYPE text COLLATE "C",
	ALTER val_2 TYPE text COLLATE "POSIX";
SELECT orioledb_table_description('o_test_reuse_multiple_indices'::regclass);
                orioledb_table_description                 
-----------------------------------------------------------
 Compress = -1, Primary compress = -1, TOAST compress = -1+
  Column |    Type | Collation | Nullable | Droped        +
   val_1 | integer |    (null) |    false |  false        +
   val_2 |    text |     POSIX |    false |  false        +
   val_3 | integer |    (null) |     true |  false        +
   val_4 | integer |    (null) |     true |  false        +
   val_5 | integer |    (null) |     true |  false        +
 
(1 row)

SELECT orioledb_tbl_indices('o_test_reuse_multiple_indices'::regclass);
              orioledb_tbl_indices              
------------------------------------------------
 Index o_test_reuse_multiple_indices_pkey      +
     Index type: primary, unique               +
     Leaf tuple size: 5, non-leaf tuple size: 1+
     Non-leaf tuple fields: val_1              +
 Index o_test_reuse_multiple_indices_ix3       +
     Index type: secondary                     +
     Leaf tuple size: 3, non-leaf tuple size: 3+
     Non-leaf tuple fields: val_4, val_2, val_1+
     Leaf tuple fields: val_4, val_2, val_1    +
 Index o_test_reuse_multiple_indices_ix4       +
     Index type: secondary                     +
     Leaf tuple size: 3, non-leaf tuple size: 3+
     Non-leaf tuple fields: val_5, val_1, val_2+
     Leaf tuple fields: val_5, val_1, val_2    +
 Index o_test_reuse_multiple_indices_ix1       +
     Index type: secondary                     +
     Leaf tuple size: 2, non-leaf tuple size: 2+
     Non-leaf tuple fields: val_2, val_1       +
     Leaf tuple fields: val_2, val_1           +
 Index o_test_reuse_multiple_indices_ix2       +
     Index type: secondary                     +
     Leaf tuple size: 3, non-leaf tuple size: 3+
     Non-leaf tuple fields: val_3, val_2, val_1+
     Leaf tuple fields: val_3, val_2, val_1    +
 
(1 row)

SELECT orioledb_tbl_structure('o_test_reuse_multiple_indices'::regclass,
							  'nue');
                        orioledb_tbl_structure                        
----------------------------------------------------------------------
 Index o_test_reuse_multiple_indices_pkey contents                   +
 Page 0: level = 0, maxKeyLen = 8, nVacatedBytes = 0                 +
 state = free, datoid equal, relnode equal, ix_type = primary, dirty +
     Leftmost, Rightmost                                             +
   Chunk 0: offset = 0, location = 256, hikey location = 64          +
     Item 0: offset = 272, tuple = ('1', 'XXX1', '10', '100', '1000')+
     Item 1: offset = 320, tuple = ('2', 'XXX2', '20', '200', '2000')+
     Item 2: offset = 368, tuple = ('3', 'XXX3', '30', '300', '3000')+
     Item 3: offset = 416, tuple = ('4', 'XXX4', '40', '400', '4000')+
     Item 4: offset = 464, tuple = ('5', 'XXX5', '50', '500', '5000')+
                                                                     +
 Index o_test_reuse_multiple_indices_ix3 contents                    +
 Page 0: level = 0, maxKeyLen = 24, nVacatedBytes = 0                +
 state = free, datoid equal, relnode equal, ix_type = regular, dirty +
     Leftmost, Rightmost                                             +
   Chunk 0: offset = 0, location = 256, hikey location = 64          +
     Item 0: offset = 272, tuple = ('100', 'XXX1', '1')              +
     Item 1: offset = 312, tuple = ('200', 'XXX2', '2')              +
     Item 2: offset = 352, tuple = ('300', 'XXX3', '3')              +
     Item 3: offset = 392, tuple = ('400', 'XXX4', '4')              +
     Item 4: offset = 432, tuple = ('500', 'XXX5', '5')              +
                                                                     +
 Index o_test_reuse_multiple_indices_ix4 contents                    +
 Page 0: level = 0, maxKeyLen = 24, nVacatedBytes = 0                +
 state = free, datoid equal, relnode equal, ix_type = regular, dirty +
     Leftmost, Rightmost                                             +
   Chunk 0: offset = 0, location = 256, hikey location = 64          +
     Item 0: offset = 272, tuple = ('1000', '1', 'XXX1')             +
     Item 1: offset = 312, tuple = ('2000', '2', 'XXX2')             +
     Item 2: offset = 352, tuple = ('3000', '3', 'XXX3')             +
     Item 3: offset = 392, tuple = ('4000', '4', 'XXX4')             +
     Item 4: offset = 432, tuple = ('5000', '5', 'XXX5')             +
                                                                     +
 Index o_test_reuse_multiple_indices_ix1: not loaded                 +
 Index o_test_reuse_multiple_indices_ix2: not loaded                 +
 Index toast: not loaded                                             +
 
(1 row)

\d+ o_test_reuse_multiple_indices
                       Table "indices.o_test_reuse_multiple_indices"
 Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
--------+---------+-----------+----------+---------+----------+--------------+-------------
 val_1  | integer |           | not null |         | plain    |              | 
 val_2  | text    | POSIX     | not null |         | extended |              | 
 val_3  | integer |           |          |         | plain    |              | 
 val_4  | integer |           |          |         | plain    |              | 
 val_5  | integer |           |          |         | plain    |              | 
Indexes:
    "o_test_reuse_multiple_indices_pkey" PRIMARY KEY, btree (val_1)
    "o_test_reuse_multiple_indices_ix1" btree (val_2)
    "o_test_reuse_multiple_indices_ix2" btree (val_3 DESC, val_2 DESC)
    "o_test_reuse_multiple_indices_ix3" btree (val_4) INCLUDE (val_2)
    "o_test_reuse_multiple_indices_ix4" btree (val_5) INCLUDE (val_1, val_2)

EXPLAIN (COSTS OFF)
	SELECT chr(ASCII('a') + val_5 / 1000) FROM o_test_reuse_multiple_indices;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Custom Scan (o_scan) on o_test_reuse_multiple_indices
   Forward index only scan of: o_test_reuse_multiple_indices_ix4
(2 rows)

SELECT chr(ASCII('a') + val_5 / 1000) FROM o_test_reuse_multiple_indices;
 chr 
-----
 b
 c
 d
 e
 f
(5 rows)

EXPLAIN SELECT val_1, val_5 FROM o_test_reuse_multiple_indices ORDER BY val_5;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Custom Scan (o_scan) on o_test_reuse_multiple_indices  (cost=0.13..8.21 rows=5 width=8)
   Forward index only scan of: o_test_reuse_multiple_indices_ix4
(2 rows)

SELECT val_1, val_5 FROM o_test_reuse_multiple_indices ORDER BY val_5;
 val_1 | val_5 
-------+-------
     1 |  1000
     2 |  2000
     3 |  3000
     4 |  4000
     5 |  5000
(5 rows)

ALTER TABLE o_test_reuse_multiple_indices ALTER val_5 TYPE char
	USING chr(ASCII('a') + val_5 / 1000);
SELECT orioledb_table_description('o_test_reuse_multiple_indices'::regclass);
                orioledb_table_description                 
-----------------------------------------------------------
 Compress = -1, Primary compress = -1, TOAST compress = -1+
  Column |         Type | Collation | Nullable | Droped   +
   val_1 |      integer |    (null) |    false |  false   +
   val_2 |         text |     POSIX |    false |  false   +
   val_3 |      integer |    (null) |     true |  false   +
   val_4 |      integer |    (null) |     true |  false   +
   val_5 | character(1) |   default |     true |  false   +
 
(1 row)

SELECT orioledb_tbl_indices('o_test_reuse_multiple_indices'::regclass);
              orioledb_tbl_indices              
------------------------------------------------
 Index o_test_reuse_multiple_indices_pkey      +
     Index type: primary, unique               +
     Leaf tuple size: 5, non-leaf tuple size: 1+
     Non-leaf tuple fields: val_1              +
 Index o_test_reuse_multiple_indices_ix1       +
     Index type: secondary                     +
     Leaf tuple size: 2, non-leaf tuple size: 2+
     Non-leaf tuple fields: val_2, val_1       +
     Leaf tuple fields: val_2, val_1           +
 Index o_test_reuse_multiple_indices_ix2       +
     Index type: secondary                     +
     Leaf tuple size: 3, non-leaf tuple size: 3+
     Non-leaf tuple fields: val_3, val_2, val_1+
     Leaf tuple fields: val_3, val_2, val_1    +
 Index o_test_reuse_multiple_indices_ix3       +
     Index type: secondary                     +
     Leaf tuple size: 3, non-leaf tuple size: 3+
     Non-leaf tuple fields: val_4, val_2, val_1+
     Leaf tuple fields: val_4, val_2, val_1    +
 Index o_test_reuse_multiple_indices_ix4       +
     Index type: secondary                     +
     Leaf tuple size: 3, non-leaf tuple size: 3+
     Non-leaf tuple fields: val_5, val_1, val_2+
     Leaf tuple fields: val_5, val_1, val_2    +
 
(1 row)

EXPLAIN SELECT val_1, val_5 FROM o_test_reuse_multiple_indices ORDER BY val_5;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Custom Scan (o_scan) on o_test_reuse_multiple_indices  (cost=0.13..8.21 rows=5 width=12)
   Forward index only scan of: o_test_reuse_multiple_indices_ix4
(2 rows)

SELECT val_1, val_5 FROM o_test_reuse_multiple_indices ORDER BY val_5;
 val_1 | val_5 
-------+-------
     1 | b
     2 | c
     3 | d
     4 | e
     5 | f
(5 rows)

\d+ o_test_reuse_multiple_indices
                         Table "indices.o_test_reuse_multiple_indices"
 Column |     Type     | Collation | Nullable | Default | Storage  | Stats target | Description 
--------+--------------+-----------+----------+---------+----------+--------------+-------------
 val_1  | integer      |           | not null |         | plain    |              | 
 val_2  | text         | POSIX     | not null |         | extended |              | 
 val_3  | integer      |           |          |         | plain    |              | 
 val_4  | integer      |           |          |         | plain    |              | 
 val_5  | character(1) |           |          |         | extended |              | 
Indexes:
    "o_test_reuse_multiple_indices_pkey" PRIMARY KEY, btree (val_1)
    "o_test_reuse_multiple_indices_ix1" btree (val_2)
    "o_test_reuse_multiple_indices_ix2" btree (val_3 DESC, val_2 DESC)
    "o_test_reuse_multiple_indices_ix3" btree (val_4) INCLUDE (val_2)
    "o_test_reuse_multiple_indices_ix4" btree (val_5) INCLUDE (val_1, val_2)

\d+ o_test_reuse_multiple_indices_ix1
      Index "indices.o_test_reuse_multiple_indices_ix1"
 Column | Type | Key? | Definition | Storage  | Stats target 
--------+------+------+------------+----------+--------------
 val_2  | text | yes  | val_2      | extended | 
btree, for table "indices.o_test_reuse_multiple_indices"

\d+ o_test_reuse_multiple_indices_ix2
       Index "indices.o_test_reuse_multiple_indices_ix2"
 Column |  Type   | Key? | Definition | Storage  | Stats target 
--------+---------+------+------------+----------+--------------
 val_3  | integer | yes  | val_3      | plain    | 
 val_2  | text    | yes  | val_2      | extended | 
btree, for table "indices.o_test_reuse_multiple_indices"

\d+ o_test_reuse_multiple_indices_ix3
       Index "indices.o_test_reuse_multiple_indices_ix3"
 Column |  Type   | Key? | Definition | Storage  | Stats target 
--------+---------+------+------------+----------+--------------
 val_4  | integer | yes  | val_4      | plain    | 
 val_2  | text    | no   | val_2      | extended | 
btree, for table "indices.o_test_reuse_multiple_indices"

\d+ o_test_reuse_multiple_indices_ix4
          Index "indices.o_test_reuse_multiple_indices_ix4"
 Column |     Type     | Key? | Definition | Storage  | Stats target 
--------+--------------+------+------------+----------+--------------
 val_5  | character(1) | yes  | val_5      | extended | 
 val_1  | integer      | no   | val_1      | plain    | 
 val_2  | text         | no   | val_2      | extended | 
btree, for table "indices.o_test_reuse_multiple_indices"

SET enable_seqscan = off;
EXPLAIN (COSTS OFF)
	SELECT val_2 FROM o_test_reuse_multiple_indices ORDER BY val_2;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Custom Scan (o_scan) on o_test_reuse_multiple_indices
   Forward index only scan of: o_test_reuse_multiple_indices_ix1
(2 rows)

SELECT val_2 FROM o_test_reuse_multiple_indices ORDER BY val_2;
 val_2 
-------
 XXX1
 XXX2
 XXX3
 XXX4
 XXX5
(5 rows)

EXPLAIN (COSTS OFF)
	SELECT val_1, val_2, val_3 FROM o_test_reuse_multiple_indices
		ORDER BY val_3 DESC;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Custom Scan (o_scan) on o_test_reuse_multiple_indices
   Forward index only scan of: o_test_reuse_multiple_indices_ix2
(2 rows)

SELECT val_1, val_2, val_3 FROM o_test_reuse_multiple_indices
	ORDER BY val_3 DESC;
 val_1 | val_2 | val_3 
-------+-------+-------
     5 | XXX5  |    50
     4 | XXX4  |    40
     3 | XXX3  |    30
     2 | XXX2  |    20
     1 | XXX1  |    10
(5 rows)

EXPLAIN (COSTS OFF)
	SELECT val_1, val_2, val_4 FROM o_test_reuse_multiple_indices
		ORDER BY val_4;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Custom Scan (o_scan) on o_test_reuse_multiple_indices
   Forward index only scan of: o_test_reuse_multiple_indices_ix3
(2 rows)

SELECT val_1, val_2, val_4 FROM o_test_reuse_multiple_indices ORDER BY val_4;
 val_1 | val_2 | val_4 
-------+-------+-------
     1 | XXX1  |   100
     2 | XXX2  |   200
     3 | XXX3  |   300
     4 | XXX4  |   400
     5 | XXX5  |   500
(5 rows)

EXPLAIN (COSTS OFF)
	SELECT val_1, val_2, val_5 FROM o_test_reuse_multiple_indices
		ORDER BY val_5;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Custom Scan (o_scan) on o_test_reuse_multiple_indices
   Forward index only scan of: o_test_reuse_multiple_indices_ix4
(2 rows)

SELECT val_1, val_2, val_5 FROM o_test_reuse_multiple_indices ORDER BY val_5;
 val_1 | val_2 | val_5 
-------+-------+-------
     1 | XXX1  | b
     2 | XXX2  | c
     3 | XXX3  | d
     4 | XXX4  | e
     5 | XXX5  | f
(5 rows)

SELECT orioledb_tbl_structure('o_test_reuse_multiple_indices'::regclass, 'nue');
                                  orioledb_tbl_structure                                   
-------------------------------------------------------------------------------------------
 Index o_test_reuse_multiple_indices_pkey contents                                        +
 Page 0: level = 0, maxKeyLen = 4, nVacatedBytes = 0                                      +
 state = free, datoid equal, relnode equal, ix_type = primary, clean                      +
     Leftmost, Rightmost                                                                  +
   Chunk 0: offset = 0, location = 256, hikey location = 80, hikey = ('2')                +
     Item 0: offset = 264, tuple = ('1', 'XXX1', '10', '100', 'b')                        +
   Chunk 1: offset = 1, location = 312, hikey location = 88, hikey = ('3')                +
     Item 1: offset = 320, tuple = ('2', 'XXX2', '20', '200', 'c')                        +
   Chunk 2: offset = 2, location = 368, hikey location = 96, hikey = ('4')                +
     Item 2: offset = 376, tuple = ('3', 'XXX3', '30', '300', 'd')                        +
   Chunk 3: offset = 3, location = 424, hikey location = 104, hikey = ('5')               +
     Item 3: offset = 432, tuple = ('4', 'XXX4', '40', '400', 'e')                        +
   Chunk 4: offset = 4, location = 480, hikey location = 112                              +
     Item 4: offset = 488, tuple = ('5', 'XXX5', '50', '500', 'f')                        +
                                                                                          +
 Index o_test_reuse_multiple_indices_ix1 contents                                         +
 Page 0: level = 0, maxKeyLen = 20, nVacatedBytes = 0                                     +
 state = free, datoid equal, relnode equal, ix_type = regular, clean                      +
     Leftmost, Rightmost                                                                  +
   Chunk 0: offset = 0, location = 256, hikey location = 80, hikey = ('XXX2', '2')        +
     Item 0: offset = 264, tuple = ('XXX1', '1')                                          +
   Chunk 1: offset = 1, location = 304, hikey location = 104, hikey = ('XXX3', '3')       +
     Item 1: offset = 312, tuple = ('XXX2', '2')                                          +
   Chunk 2: offset = 2, location = 352, hikey location = 128, hikey = ('XXX4', '4')       +
     Item 2: offset = 360, tuple = ('XXX3', '3')                                          +
   Chunk 3: offset = 3, location = 400, hikey location = 152, hikey = ('XXX5', '5')       +
     Item 3: offset = 408, tuple = ('XXX4', '4')                                          +
   Chunk 4: offset = 4, location = 448, hikey location = 176                              +
     Item 4: offset = 456, tuple = ('XXX5', '5')                                          +
                                                                                          +
 Index o_test_reuse_multiple_indices_ix2 contents                                         +
 Page 0: level = 0, maxKeyLen = 24, nVacatedBytes = 0                                     +
 state = free, datoid equal, relnode equal, ix_type = regular, clean                      +
     Leftmost, Rightmost                                                                  +
   Chunk 0: offset = 0, location = 256, hikey location = 80, hikey = ('40', 'XXX4', '4')  +
     Item 0: offset = 264, tuple = ('50', 'XXX5', '5')                                    +
   Chunk 1: offset = 1, location = 304, hikey location = 104, hikey = ('30', 'XXX3', '3') +
     Item 1: offset = 312, tuple = ('40', 'XXX4', '4')                                    +
   Chunk 2: offset = 2, location = 352, hikey location = 128, hikey = ('20', 'XXX2', '2') +
     Item 2: offset = 360, tuple = ('30', 'XXX3', '3')                                    +
   Chunk 3: offset = 3, location = 400, hikey location = 152, hikey = ('10', 'XXX1', '1') +
     Item 3: offset = 408, tuple = ('20', 'XXX2', '2')                                    +
   Chunk 4: offset = 4, location = 448, hikey location = 176                              +
     Item 4: offset = 456, tuple = ('10', 'XXX1', '1')                                    +
                                                                                          +
 Index o_test_reuse_multiple_indices_ix3 contents                                         +
 Page 0: level = 0, maxKeyLen = 24, nVacatedBytes = 0                                     +
 state = free, datoid equal, relnode equal, ix_type = regular, clean                      +
     Leftmost, Rightmost                                                                  +
   Chunk 0: offset = 0, location = 256, hikey location = 80, hikey = ('200', 'XXX2', '2') +
     Item 0: offset = 264, tuple = ('100', 'XXX1', '1')                                   +
   Chunk 1: offset = 1, location = 304, hikey location = 104, hikey = ('300', 'XXX3', '3')+
     Item 1: offset = 312, tuple = ('200', 'XXX2', '2')                                   +
   Chunk 2: offset = 2, location = 352, hikey location = 128, hikey = ('400', 'XXX4', '4')+
     Item 2: offset = 360, tuple = ('300', 'XXX3', '3')                                   +
   Chunk 3: offset = 3, location = 400, hikey location = 152, hikey = ('500', 'XXX5', '5')+
     Item 3: offset = 408, tuple = ('400', 'XXX4', '4')                                   +
   Chunk 4: offset = 4, location = 448, hikey location = 176                              +
     Item 4: offset = 456, tuple = ('500', 'XXX5', '5')                                   +
                                                                                          +
 Index o_test_reuse_multiple_indices_ix4 contents                                         +
 Page 0: level = 0, maxKeyLen = 21, nVacatedBytes = 0                                     +
 state = free, datoid equal, relnode equal, ix_type = regular, clean                      +
     Leftmost, Rightmost                                                                  +
   Chunk 0: offset = 0, location = 256, hikey location = 80, hikey = ('c', '2', 'XXX2')   +
     Item 0: offset = 264, tuple = ('b', '1', 'XXX1')                                     +
   Chunk 1: offset = 1, location = 304, hikey location = 104, hikey = ('d', '3', 'XXX3')  +
     Item 1: offset = 312, tuple = ('c', '2', 'XXX2')                                     +
   Chunk 2: offset = 2, location = 352, hikey location = 128, hikey = ('e', '4', 'XXX4')  +
     Item 2: offset = 360, tuple = ('d', '3', 'XXX3')                                     +
   Chunk 3: offset = 3, location = 400, hikey location = 152, hikey = ('f', '5', 'XXX5')  +
     Item 3: offset = 408, tuple = ('e', '4', 'XXX4')                                     +
   Chunk 4: offset = 4, location = 448, hikey location = 176                              +
     Item 4: offset = 456, tuple = ('f', '5', 'XXX5')                                     +
                                                                                          +
 Index toast: not loaded                                                                  +
 
(1 row)

ALTER TABLE o_test_reuse_multiple_indices
	DROP CONSTRAINT o_test_reuse_multiple_indices_pkey;
SELECT orioledb_table_description('o_test_reuse_multiple_indices'::regclass);
                orioledb_table_description                 
-----------------------------------------------------------
 Compress = -1, Primary compress = -1, TOAST compress = -1+
  Column |         Type | Collation | Nullable | Droped   +
   val_1 |      integer |    (null) |    false |  false   +
   val_2 |         text |     POSIX |    false |  false   +
   val_3 |      integer |    (null) |     true |  false   +
   val_4 |      integer |    (null) |     true |  false   +
   val_5 | character(1) |   default |     true |  false   +
 
(1 row)

SELECT orioledb_tbl_indices('o_test_reuse_multiple_indices'::regclass);
                 orioledb_tbl_indices                 
------------------------------------------------------
 Index ctid_primary                                  +
     Index type: primary, unique, ctid               +
     Leaf tuple size: 6, non-leaf tuple size: 1      +
     Non-leaf tuple fields: ctid                     +
 Index o_test_reuse_multiple_indices_ix1             +
     Index type: secondary                           +
     Leaf tuple size: 2, non-leaf tuple size: 2      +
     Non-leaf tuple fields: val_2, ctid              +
     Leaf tuple fields: val_2, ctid                  +
 Index o_test_reuse_multiple_indices_ix2             +
     Index type: secondary                           +
     Leaf tuple size: 3, non-leaf tuple size: 3      +
     Non-leaf tuple fields: val_3, val_2, ctid       +
     Leaf tuple fields: val_3, val_2, ctid           +
 Index o_test_reuse_multiple_indices_ix3             +
     Index type: secondary                           +
     Leaf tuple size: 3, non-leaf tuple size: 3      +
     Non-leaf tuple fields: val_4, val_2, ctid       +
     Leaf tuple fields: val_4, val_2, ctid           +
 Index o_test_reuse_multiple_indices_ix4             +
     Index type: secondary                           +
     Leaf tuple size: 4, non-leaf tuple size: 4      +
     Non-leaf tuple fields: val_5, val_1, val_2, ctid+
     Leaf tuple fields: val_5, val_1, val_2, ctid    +
 
(1 row)

EXPLAIN (COSTS OFF)
	SELECT val_2 FROM o_test_reuse_multiple_indices ORDER BY val_2;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Custom Scan (o_scan) on o_test_reuse_multiple_indices
   Forward index only scan of: o_test_reuse_multiple_indices_ix1
(2 rows)

SELECT val_2 FROM o_test_reuse_multiple_indices ORDER BY val_2;
 val_2 
-------
 XXX1
 XXX2
 XXX3
 XXX4
 XXX5
(5 rows)

EXPLAIN (COSTS OFF)
	SELECT val_1, val_2, val_3 FROM o_test_reuse_multiple_indices
		ORDER BY val_3 DESC;
                         QUERY PLAN                         
------------------------------------------------------------
 Custom Scan (o_scan) on o_test_reuse_multiple_indices
   Forward index scan of: o_test_reuse_multiple_indices_ix2
(2 rows)

SELECT val_1, val_2, val_3 FROM o_test_reuse_multiple_indices
	ORDER BY val_3 DESC;
 val_1 | val_2 | val_3 
-------+-------+-------
     5 | XXX5  |    50
     4 | XXX4  |    40
     3 | XXX3  |    30
     2 | XXX2  |    20
     1 | XXX1  |    10
(5 rows)

EXPLAIN (COSTS OFF)
	SELECT val_1, val_2, val_4 FROM o_test_reuse_multiple_indices
		ORDER BY val_4;
                         QUERY PLAN                         
------------------------------------------------------------
 Custom Scan (o_scan) on o_test_reuse_multiple_indices
   Forward index scan of: o_test_reuse_multiple_indices_ix3
(2 rows)

SELECT val_1, val_2, val_4 FROM o_test_reuse_multiple_indices ORDER BY val_4;
 val_1 | val_2 | val_4 
-------+-------+-------
     1 | XXX1  |   100
     2 | XXX2  |   200
     3 | XXX3  |   300
     4 | XXX4  |   400
     5 | XXX5  |   500
(5 rows)

EXPLAIN (COSTS OFF)
	SELECT val_1, val_2, val_5 FROM o_test_reuse_multiple_indices
		ORDER BY val_5;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Custom Scan (o_scan) on o_test_reuse_multiple_indices
   Forward index only scan of: o_test_reuse_multiple_indices_ix4
(2 rows)

SELECT val_1, val_2, val_5 FROM o_test_reuse_multiple_indices ORDER BY val_5;
 val_1 | val_2 | val_5 
-------+-------+-------
     1 | XXX1  | b
     2 | XXX2  | c
     3 | XXX3  | d
     4 | XXX4  | e
     5 | XXX5  | f
(5 rows)

SELECT orioledb_tbl_structure('o_test_reuse_multiple_indices'::regclass, 'nue');
                                      orioledb_tbl_structure                                      
--------------------------------------------------------------------------------------------------
 Index ctid_primary contents                                                                     +
 Page 0: level = 0, maxKeyLen = 6, nVacatedBytes = 0                                             +
 state = free, datoid equal, relnode equal, ix_type = primary, clean                             +
     Leftmost, Rightmost                                                                         +
   Chunk 0: offset = 0, location = 256, hikey location = 80, hikey = ('(0,1)')                   +
     Item 0: offset = 264, tuple = ('(0,0)', '1', 'XXX1', '10', '100', 'b')                      +
   Chunk 1: offset = 1, location = 320, hikey location = 88, hikey = ('(0,2)')                   +
     Item 1: offset = 328, tuple = ('(0,1)', '2', 'XXX2', '20', '200', 'c')                      +
   Chunk 2: offset = 2, location = 384, hikey location = 96, hikey = ('(0,3)')                   +
     Item 2: offset = 392, tuple = ('(0,2)', '3', 'XXX3', '30', '300', 'd')                      +
   Chunk 3: offset = 3, location = 448, hikey location = 104, hikey = ('(0,4)')                  +
     Item 3: offset = 456, tuple = ('(0,3)', '4', 'XXX4', '40', '400', 'e')                      +
   Chunk 4: offset = 4, location = 512, hikey location = 112                                     +
     Item 4: offset = 520, tuple = ('(0,4)', '5', 'XXX5', '50', '500', 'f')                      +
                                                                                                 +
 Index o_test_reuse_multiple_indices_ix1 contents                                                +
 Page 0: level = 0, maxKeyLen = 20, nVacatedBytes = 0                                            +
 state = free, datoid equal, relnode equal, ix_type = regular, clean                             +
     Leftmost, Rightmost                                                                         +
   Chunk 0: offset = 0, location = 256, hikey location = 80, hikey = ('XXX2', '(0,1)')           +
     Item 0: offset = 264, tuple = ('XXX1', '(0,0)')                                             +
   Chunk 1: offset = 1, location = 304, hikey location = 104, hikey = ('XXX3', '(0,2)')          +
     Item 1: offset = 312, tuple = ('XXX2', '(0,1)')                                             +
   Chunk 2: offset = 2, location = 352, hikey location = 128, hikey = ('XXX4', '(0,3)')          +
     Item 2: offset = 360, tuple = ('XXX3', '(0,2)')                                             +
   Chunk 3: offset = 3, location = 400, hikey location = 152, hikey = ('XXX5', '(0,4)')          +
     Item 3: offset = 408, tuple = ('XXX4', '(0,3)')                                             +
   Chunk 4: offset = 4, location = 448, hikey location = 176                                     +
     Item 4: offset = 456, tuple = ('XXX5', '(0,4)')                                             +
                                                                                                 +
 Index o_test_reuse_multiple_indices_ix2 contents                                                +
 Page 0: level = 0, maxKeyLen = 24, nVacatedBytes = 0                                            +
 state = free, datoid equal, relnode equal, ix_type = regular, clean                             +
     Leftmost, Rightmost                                                                         +
   Chunk 0: offset = 0, location = 256, hikey location = 80, hikey = ('40', 'XXX4', '(0,3)')     +
     Item 0: offset = 264, tuple = ('50', 'XXX5', '(0,4)')                                       +
   Chunk 1: offset = 1, location = 304, hikey location = 104, hikey = ('30', 'XXX3', '(0,2)')    +
     Item 1: offset = 312, tuple = ('40', 'XXX4', '(0,3)')                                       +
   Chunk 2: offset = 2, location = 352, hikey location = 128, hikey = ('20', 'XXX2', '(0,1)')    +
     Item 2: offset = 360, tuple = ('30', 'XXX3', '(0,2)')                                       +
   Chunk 3: offset = 3, location = 400, hikey location = 152, hikey = ('10', 'XXX1', '(0,0)')    +
     Item 3: offset = 408, tuple = ('20', 'XXX2', '(0,1)')                                       +
   Chunk 4: offset = 4, location = 448, hikey location = 176                                     +
     Item 4: offset = 456, tuple = ('10', 'XXX1', '(0,0)')                                       +
                                                                                                 +
 Index o_test_reuse_multiple_indices_ix3 contents                                                +
 Page 0: level = 0, maxKeyLen = 24, nVacatedBytes = 0                                            +
 state = free, datoid equal, relnode equal, ix_type = regular, clean                             +
     Leftmost, Rightmost                                                                         +
   Chunk 0: offset = 0, location = 256, hikey location = 80, hikey = ('200', 'XXX2', '(0,1)')    +
     Item 0: offset = 264, tuple = ('100', 'XXX1', '(0,0)')                                      +
   Chunk 1: offset = 1, location = 304, hikey location = 104, hikey = ('300', 'XXX3', '(0,2)')   +
     Item 1: offset = 312, tuple = ('200', 'XXX2', '(0,1)')                                      +
   Chunk 2: offset = 2, location = 352, hikey location = 128, hikey = ('400', 'XXX4', '(0,3)')   +
     Item 2: offset = 360, tuple = ('300', 'XXX3', '(0,2)')                                      +
   Chunk 3: offset = 3, location = 400, hikey location = 152, hikey = ('500', 'XXX5', '(0,4)')   +
     Item 3: offset = 408, tuple = ('400', 'XXX4', '(0,3)')                                      +
   Chunk 4: offset = 4, location = 448, hikey location = 176                                     +
     Item 4: offset = 456, tuple = ('500', 'XXX5', '(0,4)')                                      +
                                                                                                 +
 Index o_test_reuse_multiple_indices_ix4 contents                                                +
 Page 0: level = 0, maxKeyLen = 28, nVacatedBytes = 0                                            +
 state = free, datoid equal, relnode equal, ix_type = regular, clean                             +
     Leftmost, Rightmost                                                                         +
   Chunk 0: offset = 0, location = 256, hikey location = 80, hikey = ('c', '2', 'XXX2', '(0,1)') +
     Item 0: offset = 264, tuple = ('b', '1', 'XXX1', '(0,0)')                                   +
   Chunk 1: offset = 1, location = 312, hikey location = 112, hikey = ('d', '3', 'XXX3', '(0,2)')+
     Item 1: offset = 320, tuple = ('c', '2', 'XXX2', '(0,1)')                                   +
   Chunk 2: offset = 2, location = 368, hikey location = 144, hikey = ('e', '4', 'XXX4', '(0,3)')+
     Item 2: offset = 376, tuple = ('d', '3', 'XXX3', '(0,2)')                                   +
   Chunk 3: offset = 3, location = 424, hikey location = 176, hikey = ('f', '5', 'XXX5', '(0,4)')+
     Item 3: offset = 432, tuple = ('e', '4', 'XXX4', '(0,3)')                                   +
   Chunk 4: offset = 4, location = 480, hikey location = 208                                     +
     Item 4: offset = 488, tuple = ('f', '5', 'XXX5', '(0,4)')                                   +
                                                                                                 +
 Index toast: not loaded                                                                         +
 
(1 row)

\d+ o_test_reuse_multiple_indices
                         Table "indices.o_test_reuse_multiple_indices"
 Column |     Type     | Collation | Nullable | Default | Storage  | Stats target | Description 
--------+--------------+-----------+----------+---------+----------+--------------+-------------
 val_1  | integer      |           | not null |         | plain    |              | 
 val_2  | text         | POSIX     | not null |         | extended |              | 
 val_3  | integer      |           |          |         | plain    |              | 
 val_4  | integer      |           |          |         | plain    |              | 
 val_5  | character(1) |           |          |         | extended |              | 
Indexes:
    "o_test_reuse_multiple_indices_ix1" btree (val_2)
    "o_test_reuse_multiple_indices_ix2" btree (val_3 DESC, val_2 DESC)
    "o_test_reuse_multiple_indices_ix3" btree (val_4) INCLUDE (val_2)
    "o_test_reuse_multiple_indices_ix4" btree (val_5) INCLUDE (val_1, val_2)

\d+ o_test_reuse_multiple_indices_ix1
      Index "indices.o_test_reuse_multiple_indices_ix1"
 Column | Type | Key? | Definition | Storage  | Stats target 
--------+------+------+------------+----------+--------------
 val_2  | text | yes  | val_2      | extended | 
btree, for table "indices.o_test_reuse_multiple_indices"

\d+ o_test_reuse_multiple_indices_ix2
       Index "indices.o_test_reuse_multiple_indices_ix2"
 Column |  Type   | Key? | Definition | Storage  | Stats target 
--------+---------+------+------------+----------+--------------
 val_3  | integer | yes  | val_3      | plain    | 
 val_2  | text    | yes  | val_2      | extended | 
btree, for table "indices.o_test_reuse_multiple_indices"

\d+ o_test_reuse_multiple_indices_ix3
       Index "indices.o_test_reuse_multiple_indices_ix3"
 Column |  Type   | Key? | Definition | Storage  | Stats target 
--------+---------+------+------------+----------+--------------
 val_4  | integer | yes  | val_4      | plain    | 
 val_2  | text    | no   | val_2      | extended | 
btree, for table "indices.o_test_reuse_multiple_indices"

\d+ o_test_reuse_multiple_indices_ix4
          Index "indices.o_test_reuse_multiple_indices_ix4"
 Column |     Type     | Key? | Definition | Storage  | Stats target 
--------+--------------+------+------------+----------+--------------
 val_5  | character(1) | yes  | val_5      | extended | 
 val_1  | integer      | no   | val_1      | plain    | 
 val_2  | text         | no   | val_2      | extended | 
btree, for table "indices.o_test_reuse_multiple_indices"

RESET enable_seqscan;
-- Test that fields added when we create table with include indices
CREATE TABLE o_test_include_like
(
	key int8 NOT NULL PRIMARY KEY,
	value text,
	val2 int
) USING orioledb;
CREATE INDEX o_test_include_like_ix1 ON o_test_include_like (key);
CREATE INDEX o_test_include_like_ix2 on o_test_include_like (value);
CREATE UNIQUE INDEX o_test_include_like_ix_include
	ON o_test_include_like (val2) INCLUDE (value);
SELECT orioledb_tbl_indices('o_test_include_like'::regclass);
              orioledb_tbl_indices              
------------------------------------------------
 Index o_test_include_like_pkey                +
     Index type: primary, unique               +
     Leaf tuple size: 3, non-leaf tuple size: 1+
     Non-leaf tuple fields: key                +
 Index o_test_include_like_ix1                 +
     Index type: secondary                     +
     Leaf tuple size: 1, non-leaf tuple size: 1+
     Non-leaf tuple fields: key                +
     Leaf tuple fields: key                    +
 Index o_test_include_like_ix2                 +
     Index type: secondary                     +
     Leaf tuple size: 2, non-leaf tuple size: 2+
     Non-leaf tuple fields: value, key         +
     Leaf tuple fields: value, key             +
 Index o_test_include_like_ix_include          +
     Index type: secondary, unique             +
     Leaf tuple size: 3, non-leaf tuple size: 3+
     Non-leaf tuple fields: val2, value, key   +
     Leaf tuple fields: val2, value, key       +
 
(1 row)

\d+ o_test_include_like
                            Table "indices.o_test_include_like"
 Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
--------+---------+-----------+----------+---------+----------+--------------+-------------
 key    | bigint  |           | not null |         | plain    |              | 
 value  | text    |           |          |         | extended |              | 
 val2   | integer |           |          |         | plain    |              | 
Indexes:
    "o_test_include_like_pkey" PRIMARY KEY, btree (key)
    "o_test_include_like_ix1" btree (key)
    "o_test_include_like_ix2" btree (value)
    "o_test_include_like_ix_include" UNIQUE, btree (val2) INCLUDE (value)

CREATE TABLE IF NOT EXISTS o_test_include_like_like
	(LIKE o_test_include_like INCLUDING INDEXES INCLUDING CONSTRAINTS)
		USING orioledb;
SELECT orioledb_tbl_indices('o_test_include_like_like'::regclass);
              orioledb_tbl_indices              
------------------------------------------------
 Index o_test_include_like_like_pkey           +
     Index type: primary, unique               +
     Leaf tuple size: 3, non-leaf tuple size: 1+
     Non-leaf tuple fields: key                +
 Index o_test_include_like_like_key_idx        +
     Index type: secondary                     +
     Leaf tuple size: 1, non-leaf tuple size: 1+
     Non-leaf tuple fields: key                +
     Leaf tuple fields: key                    +
 Index o_test_include_like_like_value_idx      +
     Index type: secondary                     +
     Leaf tuple size: 2, non-leaf tuple size: 2+
     Non-leaf tuple fields: value, key         +
     Leaf tuple fields: value, key             +
 Index o_test_include_like_like_val2_value_idx +
     Index type: secondary, unique             +
     Leaf tuple size: 3, non-leaf tuple size: 3+
     Non-leaf tuple fields: val2, value, key   +
     Leaf tuple fields: val2, value, key       +
 
(1 row)

\d+ o_test_include_like_like
                         Table "indices.o_test_include_like_like"
 Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
--------+---------+-----------+----------+---------+----------+--------------+-------------
 key    | bigint  |           | not null |         | plain    |              | 
 value  | text    |           |          |         | extended |              | 
 val2   | integer |           |          |         | plain    |              | 
Indexes:
    "o_test_include_like_like_pkey" PRIMARY KEY, btree (key)
    "o_test_include_like_like_key_idx" btree (key)
    "o_test_include_like_like_val2_value_idx" UNIQUE, btree (val2) INCLUDE (value)
    "o_test_include_like_like_value_idx" btree (value)

DROP TABLE o_test_include_like_like;
ALTER TABLE o_test_include_like DROP CONSTRAINT o_test_include_like_pkey;
SELECT orioledb_tbl_indices('o_test_include_like'::regclass);
              orioledb_tbl_indices              
------------------------------------------------
 Index ctid_primary                            +
     Index type: primary, unique, ctid         +
     Leaf tuple size: 4, non-leaf tuple size: 1+
     Non-leaf tuple fields: ctid               +
 Index o_test_include_like_ix1                 +
     Index type: secondary                     +
     Leaf tuple size: 2, non-leaf tuple size: 2+
     Non-leaf tuple fields: key, ctid          +
     Leaf tuple fields: key, ctid              +
 Index o_test_include_like_ix2                 +
     Index type: secondary                     +
     Leaf tuple size: 2, non-leaf tuple size: 2+
     Non-leaf tuple fields: value, ctid        +
     Leaf tuple fields: value, ctid            +
 Index o_test_include_like_ix_include          +
     Index type: secondary, unique             +
     Leaf tuple size: 3, non-leaf tuple size: 3+
     Non-leaf tuple fields: val2, value, ctid  +
     Leaf tuple fields: val2, value, ctid      +
 
(1 row)

\d+ o_test_include_like
                            Table "indices.o_test_include_like"
 Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
--------+---------+-----------+----------+---------+----------+--------------+-------------
 key    | bigint  |           | not null |         | plain    |              | 
 value  | text    |           |          |         | extended |              | 
 val2   | integer |           |          |         | plain    |              | 
Indexes:
    "o_test_include_like_ix1" btree (key)
    "o_test_include_like_ix2" btree (value)
    "o_test_include_like_ix_include" UNIQUE, btree (val2) INCLUDE (value)

CREATE TABLE IF NOT EXISTS o_test_include_like_like
	(LIKE o_test_include_like INCLUDING INDEXES INCLUDING CONSTRAINTS)
		USING orioledb;
SELECT orioledb_tbl_indices('o_test_include_like_like'::regclass);
              orioledb_tbl_indices              
------------------------------------------------
 Index ctid_primary                            +
     Index type: primary, unique, ctid         +
     Leaf tuple size: 4, non-leaf tuple size: 1+
     Non-leaf tuple fields: ctid               +
 Index o_test_include_like_like_key_idx        +
     Index type: secondary                     +
     Leaf tuple size: 2, non-leaf tuple size: 2+
     Non-leaf tuple fields: key, ctid          +
     Leaf tuple fields: key, ctid              +
 Index o_test_include_like_like_value_idx      +
     Index type: secondary                     +
     Leaf tuple size: 2, non-leaf tuple size: 2+
     Non-leaf tuple fields: value, ctid        +
     Leaf tuple fields: value, ctid            +
 Index o_test_include_like_like_val2_value_idx +
     Index type: secondary, unique             +
     Leaf tuple size: 3, non-leaf tuple size: 3+
     Non-leaf tuple fields: val2, value, ctid  +
     Leaf tuple fields: val2, value, ctid      +
 
(1 row)

\d+ o_test_include_like_like
                         Table "indices.o_test_include_like_like"
 Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
--------+---------+-----------+----------+---------+----------+--------------+-------------
 key    | bigint  |           | not null |         | plain    |              | 
 value  | text    |           |          |         | extended |              | 
 val2   | integer |           |          |         | plain    |              | 
Indexes:
    "o_test_include_like_like_key_idx" btree (key)
    "o_test_include_like_like_val2_value_idx" UNIQUE, btree (val2) INCLUDE (value)
    "o_test_include_like_like_value_idx" btree (value)

DROP TABLE o_test_include_like_like;
-- Test that fields also added when we create table like postgres table
CREATE TABLE pg_test_include_like
(
	key int8 NOT NULL PRIMARY KEY,
	value text,
	val2 int
) USING heap;
CREATE INDEX pg_test_include_like_ix1 ON pg_test_include_like (key);
CREATE INDEX pg_test_include_like_ix2 on pg_test_include_like (value);
CREATE UNIQUE INDEX pg_test_include_like_ix_include
	ON pg_test_include_like (val2) INCLUDE (value);
\d+ pg_test_include_like
                           Table "indices.pg_test_include_like"
 Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
--------+---------+-----------+----------+---------+----------+--------------+-------------
 key    | bigint  |           | not null |         | plain    |              | 
 value  | text    |           |          |         | extended |              | 
 val2   | integer |           |          |         | plain    |              | 
Indexes:
    "pg_test_include_like_pkey" PRIMARY KEY, btree (key)
    "pg_test_include_like_ix1" btree (key)
    "pg_test_include_like_ix2" btree (value)
    "pg_test_include_like_ix_include" UNIQUE, btree (val2) INCLUDE (value)

CREATE TABLE IF NOT EXISTS o_test_include_like_like
	(LIKE pg_test_include_like INCLUDING INDEXES INCLUDING CONSTRAINTS)
		USING orioledb;
SELECT orioledb_tbl_indices('o_test_include_like_like'::regclass);
              orioledb_tbl_indices              
------------------------------------------------
 Index o_test_include_like_like_pkey           +
     Index type: primary, unique               +
     Leaf tuple size: 3, non-leaf tuple size: 1+
     Non-leaf tuple fields: key                +
 Index o_test_include_like_like_key_idx        +
     Index type: secondary                     +
     Leaf tuple size: 1, non-leaf tuple size: 1+
     Non-leaf tuple fields: key                +
     Leaf tuple fields: key                    +
 Index o_test_include_like_like_value_idx      +
     Index type: secondary                     +
     Leaf tuple size: 2, non-leaf tuple size: 2+
     Non-leaf tuple fields: value, key         +
     Leaf tuple fields: value, key             +
 Index o_test_include_like_like_val2_value_idx +
     Index type: secondary, unique             +
     Leaf tuple size: 3, non-leaf tuple size: 3+
     Non-leaf tuple fields: val2, value, key   +
     Leaf tuple fields: val2, value, key       +
 
(1 row)

\d+ o_test_include_like_like
                         Table "indices.o_test_include_like_like"
 Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
--------+---------+-----------+----------+---------+----------+--------------+-------------
 key    | bigint  |           | not null |         | plain    |              | 
 value  | text    |           |          |         | extended |              | 
 val2   | integer |           |          |         | plain    |              | 
Indexes:
    "o_test_include_like_like_pkey" PRIMARY KEY, btree (key)
    "o_test_include_like_like_key_idx" btree (key)
    "o_test_include_like_like_val2_value_idx" UNIQUE, btree (val2) INCLUDE (value)
    "o_test_include_like_like_value_idx" btree (value)

DROP TABLE o_test_include_like_like;
CREATE TABLE o_test_partial_unique(
    val_1 int4,
    val_2 text
)USING orioledb;
INSERT INTO o_test_partial_unique VALUES (25, 'ac');
INSERT INTO o_test_partial_unique VALUES (26, 'bc');
INSERT INTO o_test_partial_unique VALUES (27, 'C');
INSERT INTO o_test_partial_unique VALUES (25, 'dc');
SELECT orioledb_tbl_structure('o_test_partial_unique'::regclass, 'nue');
                       orioledb_tbl_structure                        
---------------------------------------------------------------------
 Index ctid_primary contents                                        +
 Page 0: level = 0, maxKeyLen = 8, nVacatedBytes = 0                +
 state = free, datoid equal, relnode equal, ix_type = primary, dirty+
     Leftmost, Rightmost                                            +
   Chunk 0: offset = 0, location = 256, hikey location = 64         +
     Item 0: offset = 264, tuple = ('(0,1)', '25', 'ac')            +
     Item 1: offset = 304, tuple = ('(0,2)', '26', 'bc')            +
     Item 2: offset = 344, tuple = ('(0,3)', '27', 'C')             +
     Item 3: offset = 384, tuple = ('(0,4)', '25', 'dc')            +
                                                                    +
 Index toast: not loaded                                            +
 
(1 row)

CREATE UNIQUE INDEX o_test_partial_unique_ix ON o_test_partial_unique(val_1)
	WHERE val_2 LIKE '%c';
ERROR:  could not create unique index "o_test_partial_unique_ix"
DETAIL:  Duplicate keys exist.
DELETE FROM o_test_partial_unique WHERE val_2 = 'dc';
CREATE UNIQUE INDEX o_test_partial_unique_ix ON o_test_partial_unique(val_1)
	WHERE val_2 LIKE '%c';
BEGIN;
	SET LOCAL enable_seqscan = off;
	EXPLAIN SELECT val_2 FROM o_test_partial_unique WHERE val_2 LIKE '%c';
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Custom Scan (o_scan) on o_test_partial_unique  (cost=0.12..8.14 rows=1 width=32)
   Forward index scan of: o_test_partial_unique_ix
(2 rows)

	SELECT val_2 FROM o_test_partial_unique WHERE val_2 LIKE '%c';
 val_2 
-------
 ac
 bc
(2 rows)

COMMIT;
SELECT orioledb_tbl_structure('o_test_partial_unique'::regclass, 'nue');
                               orioledb_tbl_structure                                
-------------------------------------------------------------------------------------
 Index ctid_primary contents                                                        +
 Page 0: level = 0, maxKeyLen = 8, nVacatedBytes = 40                               +
 state = free, datoid equal, relnode equal, ix_type = primary, dirty                +
     Leftmost, Rightmost                                                            +
   Chunk 0: offset = 0, location = 256, hikey location = 64                         +
     Item 0: offset = 264, tuple = ('(0,1)', '25', 'ac')                            +
     Item 1: offset = 304, tuple = ('(0,2)', '26', 'bc')                            +
     Item 2: offset = 344, tuple = ('(0,3)', '27', 'C')                             +
     Item 3: deleted, offset = 384, tuple = ('(0,4)', '25', 'dc')                   +
                                                                                    +
 Index o_test_partial_unique_ix contents                                            +
 Page 0: level = 0, maxKeyLen = 10, nVacatedBytes = 0                               +
 state = free, datoid equal, relnode equal, ix_type = unique, clean                 +
     Leftmost, Rightmost                                                            +
   Chunk 0: offset = 0, location = 256, hikey location = 64, hikey = ('26', '(0,2)')+
     Item 0: offset = 264, tuple = ('25', '(0,1)')                                  +
   Chunk 1: offset = 1, location = 296, hikey location = 80                         +
     Item 1: offset = 304, tuple = ('26', '(0,2)')                                  +
                                                                                    +
 Index toast: not loaded                                                            +
 
(1 row)

SELECT orioledb_tbl_indices('o_test_partial_unique'::regclass);
              orioledb_tbl_indices              
------------------------------------------------
 Index ctid_primary                            +
     Index type: primary, unique, ctid         +
     Leaf tuple size: 3, non-leaf tuple size: 1+
     Non-leaf tuple fields: ctid               +
 Index o_test_partial_unique_ix                +
     Index type: secondary, unique             +
     Predicate: (val_2 ~~ '%c'::text)          +
     Leaf tuple size: 2, non-leaf tuple size: 2+
     Non-leaf tuple fields: val_1, ctid        +
     Leaf tuple fields: val_1, ctid            +
 
(1 row)

CREATE TABLE o_test_unique_expr (
    val_1 int4,
    val_2 text,
    val_3 int,
    val_4 int
) USING orioledb;
CREATE UNIQUE INDEX o_test_unique_expr_ix1 ON o_test_unique_expr(val_1);
CREATE UNIQUE INDEX o_test_unique_expr_ix2 ON o_test_unique_expr(lower(val_2));
CREATE UNIQUE INDEX o_test_unique_expr_ix3 ON o_test_unique_expr(abs(val_3),
																 val_4);
SELECT orioledb_tbl_indices('o_test_unique_expr'::regclass);
                orioledb_tbl_indices                
----------------------------------------------------
 Index ctid_primary                                +
     Index type: primary, unique, ctid             +
     Leaf tuple size: 5, non-leaf tuple size: 1    +
     Non-leaf tuple fields: ctid                   +
 Index o_test_unique_expr_ix1                      +
     Index type: secondary, unique                 +
     Leaf tuple size: 2, non-leaf tuple size: 2    +
     Non-leaf tuple fields: val_1, ctid            +
     Leaf tuple fields: val_1, ctid                +
 Index o_test_unique_expr_ix2                      +
     Index type: secondary, unique                 +
     Leaf tuple size: 2, non-leaf tuple size: 2    +
     Non-leaf tuple fields: lower(val_2), ctid     +
     Leaf tuple fields: lower(val_2), ctid         +
 Index o_test_unique_expr_ix3                      +
     Index type: secondary, unique                 +
     Leaf tuple size: 3, non-leaf tuple size: 3    +
     Non-leaf tuple fields: abs(val_3), val_4, ctid+
     Leaf tuple fields: abs(val_3), val_4, ctid    +
 
(1 row)

INSERT INTO o_test_unique_expr VALUES (1, 'a', 1, 1);
SELECT * FROM o_test_unique_expr;
 val_1 | val_2 | val_3 | val_4 
-------+-------+-------+-------
     1 | a     |     1 |     1
(1 row)

INSERT INTO o_test_unique_expr VALUES (2, 'a', 1, 1);
ERROR:  duplicate key value violates unique constraint "o_test_unique_expr_ix2"
DETAIL:  Key (lower(val_2))=('a') already exists.
SELECT * FROM o_test_unique_expr;
 val_1 | val_2 | val_3 | val_4 
-------+-------+-------+-------
     1 | a     |     1 |     1
(1 row)

INSERT INTO o_test_unique_expr VALUES (2, 'b', 2, 1);
SELECT * FROM o_test_unique_expr;
 val_1 | val_2 | val_3 | val_4 
-------+-------+-------+-------
     1 | a     |     1 |     1
     2 | b     |     2 |     1
(2 rows)

INSERT INTO o_test_unique_expr VALUES (3, 'c', 2, 1);
ERROR:  duplicate key value violates unique constraint "o_test_unique_expr_ix3"
DETAIL:  Key (abs(val_3), val_4)=('2', '1') already exists.
SELECT * FROM o_test_unique_expr;
 val_1 | val_2 | val_3 | val_4 
-------+-------+-------+-------
     1 | a     |     1 |     1
     2 | b     |     2 |     1
(2 rows)

CREATE TABLE o_test_reindex_empty (
  val_1 int PRIMARY KEY
) USING orioledb;
REINDEX INDEX o_test_reindex_empty_pkey;
CREATE TABLE o_test_pkey_mixed
(
	f1 int,
	f2 int,
	f3 int,
	i1 int,
	i2 int,
	pk1 int,
	pk2 int,
	pk3 int,
	pk4 int,
	PRIMARY KEY (pk1, pk2, pk3, pk4)
) USING orioledb;
CREATE INDEX o_test_pkey_mixed_ix1
	ON o_test_pkey_mixed (f1, f2, pk1, f3) INCLUDE (i1, pk4, i2);
\d+ o_test_pkey_mixed
                            Table "indices.o_test_pkey_mixed"
 Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
--------+---------+-----------+----------+---------+---------+--------------+-------------
 f1     | integer |           |          |         | plain   |              | 
 f2     | integer |           |          |         | plain   |              | 
 f3     | integer |           |          |         | plain   |              | 
 i1     | integer |           |          |         | plain   |              | 
 i2     | integer |           |          |         | plain   |              | 
 pk1    | integer |           | not null |         | plain   |              | 
 pk2    | integer |           | not null |         | plain   |              | 
 pk3    | integer |           | not null |         | plain   |              | 
 pk4    | integer |           | not null |         | plain   |              | 
Indexes:
    "o_test_pkey_mixed_pkey" PRIMARY KEY, btree (pk1, pk2, pk3, pk4)
    "o_test_pkey_mixed_ix1" btree (f1, f2, pk1, f3) INCLUDE (i1, pk4, i2)

-- f1 f2 pk1 f3 i1 pk4 i2 pk2 pk3
SELECT orioledb_tbl_indices('o_test_pkey_mixed'::regclass);
                       orioledb_tbl_indices                        
-------------------------------------------------------------------
 Index o_test_pkey_mixed_pkey                                     +
     Index type: primary, unique                                  +
     Leaf tuple size: 9, non-leaf tuple size: 4                   +
     Non-leaf tuple fields: pk1, pk2, pk3, pk4                    +
 Index o_test_pkey_mixed_ix1                                      +
     Index type: secondary                                        +
     Leaf tuple size: 9, non-leaf tuple size: 9                   +
     Non-leaf tuple fields: f1, f2, pk1, f3, i1, pk4, i2, pk2, pk3+
     Leaf tuple fields: f1, f2, pk1, f3, i1, pk4, i2, pk2, pk3    +
 
(1 row)

CREATE UNIQUE INDEX o_test_pkey_mixed_uniq1
	ON o_test_pkey_mixed (f2, f1, pk1, f3) INCLUDE (i1, pk4, i2);
\d+ o_test_pkey_mixed
                            Table "indices.o_test_pkey_mixed"
 Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
--------+---------+-----------+----------+---------+---------+--------------+-------------
 f1     | integer |           |          |         | plain   |              | 
 f2     | integer |           |          |         | plain   |              | 
 f3     | integer |           |          |         | plain   |              | 
 i1     | integer |           |          |         | plain   |              | 
 i2     | integer |           |          |         | plain   |              | 
 pk1    | integer |           | not null |         | plain   |              | 
 pk2    | integer |           | not null |         | plain   |              | 
 pk3    | integer |           | not null |         | plain   |              | 
 pk4    | integer |           | not null |         | plain   |              | 
Indexes:
    "o_test_pkey_mixed_pkey" PRIMARY KEY, btree (pk1, pk2, pk3, pk4)
    "o_test_pkey_mixed_ix1" btree (f1, f2, pk1, f3) INCLUDE (i1, pk4, i2)
    "o_test_pkey_mixed_uniq1" UNIQUE, btree (f2, f1, pk1, f3) INCLUDE (i1, pk4, i2)

-- f1 f2 pk1 f3 i1 pk4 i2 pk2 pk3
-- f2 f1 pk1 f3 i1 pk4 i2 pk2 pk3
SELECT orioledb_tbl_indices('o_test_pkey_mixed'::regclass);
                       orioledb_tbl_indices                        
-------------------------------------------------------------------
 Index o_test_pkey_mixed_pkey                                     +
     Index type: primary, unique                                  +
     Leaf tuple size: 9, non-leaf tuple size: 4                   +
     Non-leaf tuple fields: pk1, pk2, pk3, pk4                    +
 Index o_test_pkey_mixed_ix1                                      +
     Index type: secondary                                        +
     Leaf tuple size: 9, non-leaf tuple size: 9                   +
     Non-leaf tuple fields: f1, f2, pk1, f3, i1, pk4, i2, pk2, pk3+
     Leaf tuple fields: f1, f2, pk1, f3, i1, pk4, i2, pk2, pk3    +
 Index o_test_pkey_mixed_uniq1                                    +
     Index type: secondary, unique                                +
     Leaf tuple size: 9, non-leaf tuple size: 9                   +
     Non-leaf tuple fields: f2, f1, pk1, f3, i1, pk4, i2, pk2, pk3+
     Leaf tuple fields: f2, f1, pk1, f3, i1, pk4, i2, pk2, pk3    +
 
(1 row)

CREATE INDEX o_test_pkey_mixed_ix3
	ON o_test_pkey_mixed (f3, f2, pk4, f1, pk4) INCLUDE (pk3);
\d+ o_test_pkey_mixed
                            Table "indices.o_test_pkey_mixed"
 Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
--------+---------+-----------+----------+---------+---------+--------------+-------------
 f1     | integer |           |          |         | plain   |              | 
 f2     | integer |           |          |         | plain   |              | 
 f3     | integer |           |          |         | plain   |              | 
 i1     | integer |           |          |         | plain   |              | 
 i2     | integer |           |          |         | plain   |              | 
 pk1    | integer |           | not null |         | plain   |              | 
 pk2    | integer |           | not null |         | plain   |              | 
 pk3    | integer |           | not null |         | plain   |              | 
 pk4    | integer |           | not null |         | plain   |              | 
Indexes:
    "o_test_pkey_mixed_pkey" PRIMARY KEY, btree (pk1, pk2, pk3, pk4)
    "o_test_pkey_mixed_ix1" btree (f1, f2, pk1, f3) INCLUDE (i1, pk4, i2)
    "o_test_pkey_mixed_ix3" btree (f3, f2, pk4, f1, pk4) INCLUDE (pk3)
    "o_test_pkey_mixed_uniq1" UNIQUE, btree (f2, f1, pk1, f3) INCLUDE (i1, pk4, i2)

-- f1 f2 pk1 f3 i1 pk4 i2 pk2 pk3
-- f2 f1 pk1 f3 i1 pk4 i2 pk2 pk3
-- f3 f2 pk4 f1 pk3 pk1 pk2
SELECT orioledb_tbl_indices('o_test_pkey_mixed'::regclass);
                       orioledb_tbl_indices                        
-------------------------------------------------------------------
 Index o_test_pkey_mixed_pkey                                     +
     Index type: primary, unique                                  +
     Leaf tuple size: 9, non-leaf tuple size: 4                   +
     Non-leaf tuple fields: pk1, pk2, pk3, pk4                    +
 Index o_test_pkey_mixed_ix1                                      +
     Index type: secondary                                        +
     Leaf tuple size: 9, non-leaf tuple size: 9                   +
     Non-leaf tuple fields: f1, f2, pk1, f3, i1, pk4, i2, pk2, pk3+
     Leaf tuple fields: f1, f2, pk1, f3, i1, pk4, i2, pk2, pk3    +
 Index o_test_pkey_mixed_uniq1                                    +
     Index type: secondary, unique                                +
     Leaf tuple size: 9, non-leaf tuple size: 9                   +
     Non-leaf tuple fields: f2, f1, pk1, f3, i1, pk4, i2, pk2, pk3+
     Leaf tuple fields: f2, f1, pk1, f3, i1, pk4, i2, pk2, pk3    +
 Index o_test_pkey_mixed_ix3                                      +
     Index type: secondary                                        +
     Leaf tuple size: 7, non-leaf tuple size: 7                   +
     Non-leaf tuple fields: f3, f2, pk4, f1, pk3, pk1, pk2        +
     Leaf tuple fields: f3, f2, pk4, f1, pk3, pk1, pk2            +
 
(1 row)

CREATE INDEX o_test_pkey_mixed_ix4
	ON o_test_pkey_mixed (i1, f1, pk4, f2, pk4) INCLUDE (pk3, i2);
\d+ o_test_pkey_mixed
                            Table "indices.o_test_pkey_mixed"
 Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
--------+---------+-----------+----------+---------+---------+--------------+-------------
 f1     | integer |           |          |         | plain   |              | 
 f2     | integer |           |          |         | plain   |              | 
 f3     | integer |           |          |         | plain   |              | 
 i1     | integer |           |          |         | plain   |              | 
 i2     | integer |           |          |         | plain   |              | 
 pk1    | integer |           | not null |         | plain   |              | 
 pk2    | integer |           | not null |         | plain   |              | 
 pk3    | integer |           | not null |         | plain   |              | 
 pk4    | integer |           | not null |         | plain   |              | 
Indexes:
    "o_test_pkey_mixed_pkey" PRIMARY KEY, btree (pk1, pk2, pk3, pk4)
    "o_test_pkey_mixed_ix1" btree (f1, f2, pk1, f3) INCLUDE (i1, pk4, i2)
    "o_test_pkey_mixed_ix3" btree (f3, f2, pk4, f1, pk4) INCLUDE (pk3)
    "o_test_pkey_mixed_ix4" btree (i1, f1, pk4, f2, pk4) INCLUDE (pk3, i2)
    "o_test_pkey_mixed_uniq1" UNIQUE, btree (f2, f1, pk1, f3) INCLUDE (i1, pk4, i2)

-- f1 f2 pk1 f3 i1 pk4 i2 pk2 pk3
-- f2 f1 pk1 f3 i1 pk4 i2 pk2 pk3
-- f3 f2 pk4 f1 pk3 pk1 pk2
-- i1 f1 pk4 f2 pk3 i2 pk1 pk2
SELECT orioledb_tbl_indices('o_test_pkey_mixed'::regclass);
                       orioledb_tbl_indices                        
-------------------------------------------------------------------
 Index o_test_pkey_mixed_pkey                                     +
     Index type: primary, unique                                  +
     Leaf tuple size: 9, non-leaf tuple size: 4                   +
     Non-leaf tuple fields: pk1, pk2, pk3, pk4                    +
 Index o_test_pkey_mixed_ix1                                      +
     Index type: secondary                                        +
     Leaf tuple size: 9, non-leaf tuple size: 9                   +
     Non-leaf tuple fields: f1, f2, pk1, f3, i1, pk4, i2, pk2, pk3+
     Leaf tuple fields: f1, f2, pk1, f3, i1, pk4, i2, pk2, pk3    +
 Index o_test_pkey_mixed_uniq1                                    +
     Index type: secondary, unique                                +
     Leaf tuple size: 9, non-leaf tuple size: 9                   +
     Non-leaf tuple fields: f2, f1, pk1, f3, i1, pk4, i2, pk2, pk3+
     Leaf tuple fields: f2, f1, pk1, f3, i1, pk4, i2, pk2, pk3    +
 Index o_test_pkey_mixed_ix3                                      +
     Index type: secondary                                        +
     Leaf tuple size: 7, non-leaf tuple size: 7                   +
     Non-leaf tuple fields: f3, f2, pk4, f1, pk3, pk1, pk2        +
     Leaf tuple fields: f3, f2, pk4, f1, pk3, pk1, pk2            +
 Index o_test_pkey_mixed_ix4                                      +
     Index type: secondary                                        +
     Leaf tuple size: 8, non-leaf tuple size: 8                   +
     Non-leaf tuple fields: i1, f1, pk4, f2, pk3, i2, pk1, pk2    +
     Leaf tuple fields: i1, f1, pk4, f2, pk3, i2, pk1, pk2        +
 
(1 row)

INSERT INTO o_test_pkey_mixed
	SELECT 1 * 10 ^ v, 2 * 10 ^ v, 3 * 10 ^ v, 4 * 10 ^ v, 5 * 10 ^ v,
		   6 * 10 ^ v, 7 * 10 ^ v, 8 * 10 ^ v, 9 * 10 ^ v FROM
		   generate_series(0, 2) v;
SELECT orioledb_tbl_structure('o_test_pkey_mixed'::regclass, 'nue');
                                      orioledb_tbl_structure                                       
---------------------------------------------------------------------------------------------------
 Index o_test_pkey_mixed_pkey contents                                                            +
 Page 0: level = 0, maxKeyLen = 16, nVacatedBytes = 0                                             +
 state = free, datoid equal, relnode equal, ix_type = primary, dirty                              +
     Leftmost, Rightmost                                                                          +
   Chunk 0: offset = 0, location = 256, hikey location = 64                                       +
     Item 0: offset = 264, tuple = ('1', '2', '3', '4', '5', '6', '7', '8', '9')                  +
     Item 1: offset = 320, tuple = ('10', '20', '30', '40', '50', '60', '70', '80', '90')         +
     Item 2: offset = 376, tuple = ('100', '200', '300', '400', '500', '600', '700', '800', '900')+
                                                                                                  +
 Index o_test_pkey_mixed_ix1 contents                                                             +
 Page 0: level = 0, maxKeyLen = 40, nVacatedBytes = 0                                             +
 state = free, datoid equal, relnode equal, ix_type = regular, dirty                              +
     Leftmost, Rightmost                                                                          +
   Chunk 0: offset = 0, location = 256, hikey location = 64                                       +
     Item 0: offset = 264, tuple = ('1', '2', '6', '3', '4', '9', '5', '7', '8')                  +
     Item 1: offset = 320, tuple = ('10', '20', '60', '30', '40', '90', '50', '70', '80')         +
     Item 2: offset = 376, tuple = ('100', '200', '600', '300', '400', '900', '500', '700', '800')+
                                                                                                  +
 Index o_test_pkey_mixed_uniq1 contents                                                           +
 Page 0: level = 0, maxKeyLen = 40, nVacatedBytes = 0                                             +
 state = free, datoid equal, relnode equal, ix_type = unique, dirty                               +
     Leftmost, Rightmost                                                                          +
   Chunk 0: offset = 0, location = 256, hikey location = 64                                       +
     Item 0: offset = 264, tuple = ('2', '1', '6', '3', '4', '9', '5', '7', '8')                  +
     Item 1: offset = 320, tuple = ('20', '10', '60', '30', '40', '90', '50', '70', '80')         +
     Item 2: offset = 376, tuple = ('200', '100', '600', '300', '400', '900', '500', '700', '800')+
                                                                                                  +
 Index o_test_pkey_mixed_ix3 contents                                                             +
 Page 0: level = 0, maxKeyLen = 32, nVacatedBytes = 0                                             +
 state = free, datoid equal, relnode equal, ix_type = regular, dirty                              +
     Leftmost, Rightmost                                                                          +
   Chunk 0: offset = 0, location = 256, hikey location = 64                                       +
     Item 0: offset = 264, tuple = ('3', '2', '9', '1', '8', '6', '7')                            +
     Item 1: offset = 312, tuple = ('30', '20', '90', '10', '80', '60', '70')                     +
     Item 2: offset = 360, tuple = ('300', '200', '900', '100', '800', '600', '700')              +
                                                                                                  +
 Index o_test_pkey_mixed_ix4 contents                                                             +
 Page 0: level = 0, maxKeyLen = 32, nVacatedBytes = 0                                             +
 state = free, datoid equal, relnode equal, ix_type = regular, dirty                              +
     Leftmost, Rightmost                                                                          +
   Chunk 0: offset = 0, location = 256, hikey location = 64                                       +
     Item 0: offset = 264, tuple = ('4', '1', '9', '2', '8', '5', '6', '7')                       +
     Item 1: offset = 312, tuple = ('40', '10', '90', '20', '80', '50', '60', '70')               +
     Item 2: offset = 360, tuple = ('400', '100', '900', '200', '800', '500', '600', '700')       +
                                                                                                  +
 Index toast: not loaded                                                                          +
 
(1 row)

EXPLAIN (COSTS OFF) SELECT * FROM o_test_pkey_mixed;
          QUERY PLAN           
-------------------------------
 Seq Scan on o_test_pkey_mixed
(1 row)

SELECT * FROM o_test_pkey_mixed;
 f1  | f2  | f3  | i1  | i2  | pk1 | pk2 | pk3 | pk4 
-----+-----+-----+-----+-----+-----+-----+-----+-----
   1 |   2 |   3 |   4 |   5 |   6 |   7 |   8 |   9
  10 |  20 |  30 |  40 |  50 |  60 |  70 |  80 |  90
 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900
(3 rows)

SET enable_seqscan = off;
EXPLAIN (COSTS OFF) SELECT * FROM o_test_pkey_mixed ORDER BY f1;
                     QUERY PLAN                      
-----------------------------------------------------
 Custom Scan (o_scan) on o_test_pkey_mixed
   Forward index only scan of: o_test_pkey_mixed_ix1
(2 rows)

SELECT * FROM o_test_pkey_mixed ORDER BY f1;
 f1  | f2  | f3  | i1  | i2  | pk1 | pk2 | pk3 | pk4 
-----+-----+-----+-----+-----+-----+-----+-----+-----
   1 |   2 |   3 |   4 |   5 |   6 |   7 |   8 |   9
  10 |  20 |  30 |  40 |  50 |  60 |  70 |  80 |  90
 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900
(3 rows)

EXPLAIN (COSTS OFF) SELECT * FROM o_test_pkey_mixed ORDER BY f2;
                      QUERY PLAN                       
-------------------------------------------------------
 Custom Scan (o_scan) on o_test_pkey_mixed
   Forward index only scan of: o_test_pkey_mixed_uniq1
(2 rows)

SELECT * FROM o_test_pkey_mixed ORDER BY f2;
 f1  | f2  | f3  | i1  | i2  | pk1 | pk2 | pk3 | pk4 
-----+-----+-----+-----+-----+-----+-----+-----+-----
   1 |   2 |   3 |   4 |   5 |   6 |   7 |   8 |   9
  10 |  20 |  30 |  40 |  50 |  60 |  70 |  80 |  90
 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900
(3 rows)

EXPLAIN (COSTS OFF) SELECT * FROM o_test_pkey_mixed ORDER BY f3;
                   QUERY PLAN                   
------------------------------------------------
 Custom Scan (o_scan) on o_test_pkey_mixed
   Forward index scan of: o_test_pkey_mixed_ix3
(2 rows)

SELECT * FROM o_test_pkey_mixed ORDER BY f3;
 f1  | f2  | f3  | i1  | i2  | pk1 | pk2 | pk3 | pk4 
-----+-----+-----+-----+-----+-----+-----+-----+-----
   1 |   2 |   3 |   4 |   5 |   6 |   7 |   8 |   9
  10 |  20 |  30 |  40 |  50 |  60 |  70 |  80 |  90
 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900
(3 rows)

EXPLAIN (COSTS OFF) SELECT * FROM o_test_pkey_mixed ORDER BY i1;
                   QUERY PLAN                   
------------------------------------------------
 Custom Scan (o_scan) on o_test_pkey_mixed
   Forward index scan of: o_test_pkey_mixed_ix4
(2 rows)

SELECT * FROM o_test_pkey_mixed ORDER BY i1;
 f1  | f2  | f3  | i1  | i2  | pk1 | pk2 | pk3 | pk4 
-----+-----+-----+-----+-----+-----+-----+-----+-----
   1 |   2 |   3 |   4 |   5 |   6 |   7 |   8 |   9
  10 |  20 |  30 |  40 |  50 |  60 |  70 |  80 |  90
 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900
(3 rows)

RESET enable_seqscan;
CREATE TABLE o_test_pkey_include_box
(
	pk1 int,
	pk2 box,
	f2 int,
	PRIMARY KEY (pk1) INCLUDE (pk2)
) USING orioledb;
\d+ o_test_pkey_include_box
                         Table "indices.o_test_pkey_include_box"
 Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
--------+---------+-----------+----------+---------+---------+--------------+-------------
 pk1    | integer |           | not null |         | plain   |              | 
 pk2    | box     |           |          |         | plain   |              | 
 f2     | integer |           |          |         | plain   |              | 
Indexes:
    "o_test_pkey_include_box_pkey" PRIMARY KEY, btree (pk1) INCLUDE (pk2)

SELECT orioledb_tbl_indices('o_test_pkey_include_box'::regclass);
              orioledb_tbl_indices              
------------------------------------------------
 Index o_test_pkey_include_box_pkey            +
     Index type: primary, unique               +
     Leaf tuple size: 3, non-leaf tuple size: 2+
     Non-leaf tuple fields: pk1, pk2           +
 
(1 row)

INSERT INTO o_test_pkey_include_box
	SELECT 1 * 10 ^ v, box(point(2 * 10 ^ v, 3 * 10 ^ v),
						   point(4 * 10 ^ v, 5 * 10 ^ v)),
		   6 * 10 ^ v FROM generate_series(0, 2) v;
SELECT orioledb_tbl_structure('o_test_pkey_include_box'::regclass, 'nue');
                         orioledb_tbl_structure                          
-------------------------------------------------------------------------
 Index o_test_pkey_include_box_pkey contents                            +
 Page 0: level = 0, maxKeyLen = 40, nVacatedBytes = 0                   +
 state = free, datoid equal, relnode equal, ix_type = primary, dirty    +
     Leftmost, Rightmost                                                +
   Chunk 0: offset = 0, location = 256, hikey location = 64             +
     Item 0: offset = 264, tuple = ('1', '(4,5),(2,3)', '6')            +
     Item 1: offset = 328, tuple = ('10', '(40,50),(20,30)', '60')      +
     Item 2: offset = 392, tuple = ('100', '(400,500),(200,300)', '600')+
                                                                        +
 Index toast: not loaded                                                +
 
(1 row)

SET enable_seqscan = off;
EXPLAIN (COSTS OFF) SELECT * FROM o_test_pkey_include_box ORDER BY pk1;
                      QUERY PLAN                       
-------------------------------------------------------
 Custom Scan (o_scan) on o_test_pkey_include_box
   Forward index scan of: o_test_pkey_include_box_pkey
(2 rows)

SELECT * FROM o_test_pkey_include_box ORDER BY pk1;
 pk1 |         pk2         | f2  
-----+---------------------+-----
   1 | (4,5),(2,3)         |   6
  10 | (40,50),(20,30)     |  60
 100 | (400,500),(200,300) | 600
(3 rows)

RESET enable_seqscan;
CREATE TABLE o_test_include_box (
	val_1 int,
	val_4 box
) USING orioledb;
CREATE UNIQUE INDEX o_test_include_box_ix1
	ON o_test_include_box (val_1) INCLUDE (val_4);
\d+ o_test_include_box
                            Table "indices.o_test_include_box"
 Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
--------+---------+-----------+----------+---------+---------+--------------+-------------
 val_1  | integer |           |          |         | plain   |              | 
 val_4  | box     |           |          |         | plain   |              | 
Indexes:
    "o_test_include_box_ix1" UNIQUE, btree (val_1) INCLUDE (val_4)

SELECT orioledb_tbl_indices('o_test_include_box'::regclass);
              orioledb_tbl_indices              
------------------------------------------------
 Index ctid_primary                            +
     Index type: primary, unique, ctid         +
     Leaf tuple size: 3, non-leaf tuple size: 1+
     Non-leaf tuple fields: ctid               +
 Index o_test_include_box_ix1                  +
     Index type: secondary, unique             +
     Leaf tuple size: 3, non-leaf tuple size: 3+
     Non-leaf tuple fields: val_1, val_4, ctid +
     Leaf tuple fields: val_1, val_4, ctid     +
 
(1 row)

INSERT INTO o_test_include_box
	SELECT 1 * 10 ^ v, box(point(2 * 10 ^ v, 3 * 10 ^ v),
						   point(4 * 10 ^ v, 5 * 10 ^ v))
		FROM generate_series(0, 2) v;
SELECT orioledb_tbl_structure('o_test_include_box'::regclass, 'nue');
                          orioledb_tbl_structure                           
---------------------------------------------------------------------------
 Index ctid_primary contents                                              +
 Page 0: level = 0, maxKeyLen = 8, nVacatedBytes = 0                      +
 state = free, datoid equal, relnode equal, ix_type = primary, dirty      +
     Leftmost, Rightmost                                                  +
   Chunk 0: offset = 0, location = 256, hikey location = 64               +
     Item 0: offset = 264, tuple = ('(0,1)', '1', '(4,5),(2,3)')          +
     Item 1: offset = 328, tuple = ('(0,2)', '10', '(40,50),(20,30)')     +
     Item 2: offset = 392, tuple = ('(0,3)', '100', '(400,500),(200,300)')+
                                                                          +
 Index o_test_include_box_ix1 contents                                    +
 Page 0: level = 0, maxKeyLen = 48, nVacatedBytes = 0                     +
 state = free, datoid equal, relnode equal, ix_type = unique, dirty       +
     Leftmost, Rightmost                                                  +
   Chunk 0: offset = 0, location = 256, hikey location = 64               +
     Item 0: offset = 264, tuple = ('1', '(4,5),(2,3)', '(0,1)')          +
     Item 1: offset = 328, tuple = ('10', '(40,50),(20,30)', '(0,2)')     +
     Item 2: offset = 392, tuple = ('100', '(400,500),(200,300)', '(0,3)')+
                                                                          +
 Index toast: not loaded                                                  +
 
(1 row)

SET enable_seqscan = off;
EXPLAIN (COSTS OFF) SELECT * FROM o_test_include_box ORDER BY val_1;
                      QUERY PLAN                      
------------------------------------------------------
 Custom Scan (o_scan) on o_test_include_box
   Forward index only scan of: o_test_include_box_ix1
(2 rows)

SELECT * FROM o_test_include_box ORDER BY val_1;
 val_1 |        val_4        
-------+---------------------
     1 | (4,5),(2,3)
    10 | (40,50),(20,30)
   100 | (400,500),(200,300)
(3 rows)

RESET enable_seqscan;
CREATE TABLE o_test_include_box_with_pkey (
	val_1 int PRIMARY KEY,
	val_2 int,
	val_3 int,
	val_4 box
) USING orioledb;
CREATE UNIQUE INDEX o_test_include_box_with_pkey_ix1
	ON o_test_include_box_with_pkey (val_2) INCLUDE (val_4);
CREATE UNIQUE INDEX o_test_include_box_with_pkey_ix2
	ON o_test_include_box_with_pkey (val_3);
\d+ o_test_include_box_with_pkey
                       Table "indices.o_test_include_box_with_pkey"
 Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
--------+---------+-----------+----------+---------+---------+--------------+-------------
 val_1  | integer |           | not null |         | plain   |              | 
 val_2  | integer |           |          |         | plain   |              | 
 val_3  | integer |           |          |         | plain   |              | 
 val_4  | box     |           |          |         | plain   |              | 
Indexes:
    "o_test_include_box_with_pkey_pkey" PRIMARY KEY, btree (val_1)
    "o_test_include_box_with_pkey_ix1" UNIQUE, btree (val_2) INCLUDE (val_4)
    "o_test_include_box_with_pkey_ix2" UNIQUE, btree (val_3)

SELECT orioledb_tbl_indices('o_test_include_box_with_pkey'::regclass);
              orioledb_tbl_indices              
------------------------------------------------
 Index o_test_include_box_with_pkey_pkey       +
     Index type: primary, unique               +
     Leaf tuple size: 4, non-leaf tuple size: 1+
     Non-leaf tuple fields: val_1              +
 Index o_test_include_box_with_pkey_ix1        +
     Index type: secondary, unique             +
     Leaf tuple size: 3, non-leaf tuple size: 3+
     Non-leaf tuple fields: val_2, val_4, val_1+
     Leaf tuple fields: val_2, val_4, val_1    +
 Index o_test_include_box_with_pkey_ix2        +
     Index type: secondary, unique             +
     Leaf tuple size: 2, non-leaf tuple size: 2+
     Non-leaf tuple fields: val_3, val_1       +
     Leaf tuple fields: val_3, val_1           +
 
(1 row)

INSERT INTO o_test_include_box_with_pkey
	SELECT 1 * 10 ^ v, 2 * 10 ^ v, 3 * 10 ^ v,
		   box(point(4 * 10 ^ v, 5 * 10 ^ v), point(6 * 10 ^ v, 7 * 10 ^ v))
		FROM generate_series(0, 2) v;
SELECT orioledb_tbl_structure('o_test_include_box_with_pkey'::regclass, 'nue');
                             orioledb_tbl_structure                             
--------------------------------------------------------------------------------
 Index o_test_include_box_with_pkey_pkey contents                              +
 Page 0: level = 0, maxKeyLen = 8, nVacatedBytes = 0                           +
 state = free, datoid equal, relnode equal, ix_type = primary, dirty           +
     Leftmost, Rightmost                                                       +
   Chunk 0: offset = 0, location = 256, hikey location = 64                    +
     Item 0: offset = 264, tuple = ('1', '2', '3', '(6,7),(4,5)')              +
     Item 1: offset = 328, tuple = ('10', '20', '30', '(60,70),(40,50)')       +
     Item 2: offset = 392, tuple = ('100', '200', '300', '(600,700),(400,500)')+
                                                                               +
 Index o_test_include_box_with_pkey_ix1 contents                               +
 Page 0: level = 0, maxKeyLen = 48, nVacatedBytes = 0                          +
 state = free, datoid equal, relnode equal, ix_type = unique, dirty            +
     Leftmost, Rightmost                                                       +
   Chunk 0: offset = 0, location = 256, hikey location = 64                    +
     Item 0: offset = 264, tuple = ('2', '(6,7),(4,5)', '1')                   +
     Item 1: offset = 328, tuple = ('20', '(60,70),(40,50)', '10')             +
     Item 2: offset = 392, tuple = ('200', '(600,700),(400,500)', '100')       +
                                                                               +
 Index o_test_include_box_with_pkey_ix2 contents                               +
 Page 0: level = 0, maxKeyLen = 8, nVacatedBytes = 0                           +
 state = free, datoid equal, relnode equal, ix_type = unique, dirty            +
     Leftmost, Rightmost                                                       +
   Chunk 0: offset = 0, location = 256, hikey location = 64                    +
     Item 0: offset = 264, tuple = ('3', '1')                                  +
     Item 1: offset = 288, tuple = ('30', '10')                                +
     Item 2: offset = 312, tuple = ('300', '100')                              +
                                                                               +
 Index toast: not loaded                                                       +
 
(1 row)

SET enable_seqscan = off;
EXPLAIN (COSTS OFF) SELECT * FROM o_test_include_box_with_pkey ORDER BY val_1;
                         QUERY PLAN                         
------------------------------------------------------------
 Custom Scan (o_scan) on o_test_include_box_with_pkey
   Forward index scan of: o_test_include_box_with_pkey_pkey
(2 rows)

SELECT * FROM o_test_include_box_with_pkey ORDER BY val_1;
 val_1 | val_2 | val_3 |        val_4        
-------+-------+-------+---------------------
     1 |     2 |     3 | (6,7),(4,5)
    10 |    20 |    30 | (60,70),(40,50)
   100 |   200 |   300 | (600,700),(400,500)
(3 rows)

EXPLAIN (COSTS OFF) SELECT * FROM o_test_include_box_with_pkey ORDER BY val_2;
                        QUERY PLAN                         
-----------------------------------------------------------
 Custom Scan (o_scan) on o_test_include_box_with_pkey
   Forward index scan of: o_test_include_box_with_pkey_ix1
(2 rows)

SELECT * FROM o_test_include_box_with_pkey ORDER BY val_2;
 val_1 | val_2 | val_3 |        val_4        
-------+-------+-------+---------------------
     1 |     2 |     3 | (6,7),(4,5)
    10 |    20 |    30 | (60,70),(40,50)
   100 |   200 |   300 | (600,700),(400,500)
(3 rows)

EXPLAIN (COSTS OFF) SELECT * FROM o_test_include_box_with_pkey ORDER BY val_3;
                        QUERY PLAN                         
-----------------------------------------------------------
 Custom Scan (o_scan) on o_test_include_box_with_pkey
   Forward index scan of: o_test_include_box_with_pkey_ix2
(2 rows)

SELECT * FROM o_test_include_box_with_pkey ORDER BY val_3;
 val_1 | val_2 | val_3 |        val_4        
-------+-------+-------+---------------------
     1 |     2 |     3 | (6,7),(4,5)
    10 |    20 |    30 | (60,70),(40,50)
   100 |   200 |   300 | (600,700),(400,500)
(3 rows)

RESET enable_seqscan;
CREATE TABLE o_test_drop_included_pkey_field (
    val_1 int,
    val_2 int,
    val_3 int,
    val_4 int NULL,
    PRIMARY KEY (val_4, val_2)
) USING orioledb;
CREATE INDEX o_test_drop_included_pkey_field_ix1
	ON o_test_drop_included_pkey_field (val_1);
\d o_test_drop_included_pkey_field
  Table "indices.o_test_drop_included_pkey_field"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 val_1  | integer |           |          | 
 val_2  | integer |           | not null | 
 val_3  | integer |           |          | 
 val_4  | integer |           | not null | 
Indexes:
    "o_test_drop_included_pkey_field_pkey" PRIMARY KEY, btree (val_4, val_2)
    "o_test_drop_included_pkey_field_ix1" btree (val_1)

ALTER TABLE o_test_drop_included_pkey_field DROP COLUMN val_4;
\d o_test_drop_included_pkey_field
  Table "indices.o_test_drop_included_pkey_field"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 val_1  | integer |           |          | 
 val_2  | integer |           | not null | 
 val_3  | integer |           |          | 
Indexes:
    "o_test_drop_included_pkey_field_ix1" btree (val_1)

CREATE TABLE o_test_row_searchkey (
	val_1 int,
	val_2 int,
	PRIMARY KEY (val_1, val_2)
) USING orioledb;
INSERT INTO o_test_row_searchkey
	SELECT v % 5, (20 - v) % 6 FROM generate_series(1, 20) v;
SELECT * FROM o_test_row_searchkey ORDER BY val_1, val_2;
 val_1 | val_2 
-------+-------
     0 |     0
     0 |     3
     0 |     4
     0 |     5
     1 |     1
     1 |     2
     1 |     3
     1 |     4
     2 |     0
     2 |     1
     2 |     2
     2 |     3
     3 |     0
     3 |     1
     3 |     2
     3 |     5
     4 |     0
     4 |     1
     4 |     4
     4 |     5
(20 rows)

SET enable_seqscan = off;
EXPLAIN (COSTS OFF)
	SELECT * FROM o_test_row_searchkey
		WHERE (val_1, val_2) < (2, 3) AND val_1 > 0 AND val_2 > 0
			ORDER BY val_1, val_2;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Custom Scan (o_scan) on o_test_row_searchkey
   Forward index only scan of: o_test_row_searchkey_pkey
   Conds: ((ROW(val_1, val_2) < ROW(2, 3)) AND (val_1 > 0) AND (val_2 > 0))
(3 rows)

SELECT * FROM o_test_row_searchkey
	WHERE (val_1, val_2) < (2, 3) AND val_1 > 0 AND val_2 > 0
		ORDER BY val_1, val_2;
 val_1 | val_2 
-------+-------
     1 |     1
     1 |     2
     1 |     3
     1 |     4
     2 |     1
     2 |     2
(6 rows)

EXPLAIN (COSTS OFF)
	SELECT * FROM o_test_row_searchkey
		WHERE (val_1 < 2 OR (val_1 = 2 AND (val_2 < 3))) AND
			  val_1 > 0 AND val_2 > 0
			ORDER BY val_1, val_2;
                        QUERY PLAN                        
----------------------------------------------------------
 Custom Scan (o_scan) on o_test_row_searchkey
   Filter: ((val_1 < 2) OR ((val_1 = 2) AND (val_2 < 3)))
   Forward index only scan of: o_test_row_searchkey_pkey
   Conds: ((val_1 > 0) AND (val_2 > 0))
(4 rows)

SELECT * FROM o_test_row_searchkey
	WHERE (val_1 < 2 OR (val_1 = 2 AND (val_2 < 3))) AND
		  val_1 > 0 AND val_2 > 0
		ORDER BY val_1, val_2;
 val_1 | val_2 
-------+-------
     1 |     1
     1 |     2
     1 |     3
     1 |     4
     2 |     1
     2 |     2
(6 rows)

EXPLAIN (COSTS OFF)
	SELECT * FROM o_test_row_searchkey
		WHERE (val_1, val_2) <= (2, 3) AND val_1 > 0 AND val_2 > 0
			ORDER BY val_1, val_2;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Custom Scan (o_scan) on o_test_row_searchkey
   Forward index only scan of: o_test_row_searchkey_pkey
   Conds: ((ROW(val_1, val_2) <= ROW(2, 3)) AND (val_1 > 0) AND (val_2 > 0))
(3 rows)

SELECT * FROM o_test_row_searchkey
	WHERE (val_1, val_2) <= (2, 3) AND val_1 > 0 AND val_2 > 0
		ORDER BY val_1, val_2;
 val_1 | val_2 
-------+-------
     1 |     1
     1 |     2
     1 |     3
     1 |     4
     2 |     1
     2 |     2
     2 |     3
(7 rows)

EXPLAIN (COSTS OFF)
	SELECT * FROM o_test_row_searchkey
		WHERE (val_1 < 2 OR (val_1 = 2 AND (val_2 < 3 OR val_2 = 3))) AND
			  val_1 > 0 AND val_2 > 0
			ORDER BY val_1, val_2;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Custom Scan (o_scan) on o_test_row_searchkey
   Filter: ((val_1 < 2) OR ((val_1 = 2) AND ((val_2 < 3) OR (val_2 = 3))))
   Forward index only scan of: o_test_row_searchkey_pkey
   Conds: ((val_1 > 0) AND (val_2 > 0))
(4 rows)

SELECT * FROM o_test_row_searchkey
	WHERE (val_1 < 2 OR (val_1 = 2 AND (val_2 < 3 OR val_2 = 3))) AND
		  val_1 > 0 AND val_2 > 0
		ORDER BY val_1, val_2;
 val_1 | val_2 
-------+-------
     1 |     1
     1 |     2
     1 |     3
     1 |     4
     2 |     1
     2 |     2
     2 |     3
(7 rows)

EXPLAIN (COSTS OFF)
	SELECT * FROM o_test_row_searchkey
		WHERE (val_1, val_2) < (2, 3) AND (val_1, val_2) > (1, 2)
			ORDER BY val_1, val_2;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Custom Scan (o_scan) on o_test_row_searchkey
   Forward index only scan of: o_test_row_searchkey_pkey
   Conds: ((ROW(val_1, val_2) < ROW(2, 3)) AND (ROW(val_1, val_2) > ROW(1, 2)))
(3 rows)

SELECT * FROM o_test_row_searchkey
	WHERE (val_1, val_2) < (2, 3) AND (val_1, val_2) > (1, 2)
		ORDER BY val_1, val_2;
 val_1 | val_2 
-------+-------
     1 |     3
     1 |     4
     2 |     0
     2 |     1
     2 |     2
(5 rows)

EXPLAIN (COSTS OFF)
	SELECT * FROM o_test_row_searchkey
		WHERE (val_1 < 2 OR (val_1 = 2 AND (val_2 < 3))) AND
			  (val_1 > 1 OR (val_1 = 1 AND val_2 > 2))
			ORDER BY val_1, val_2;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Custom Scan (o_scan) on o_test_row_searchkey
   Filter: (((val_1 < 2) OR ((val_1 = 2) AND (val_2 < 3))) AND ((val_1 > 1) OR ((val_1 = 1) AND (val_2 > 2))))
   Forward index only scan of: o_test_row_searchkey_pkey
(3 rows)

SELECT * FROM o_test_row_searchkey
	WHERE (val_1 < 2 OR (val_1 = 2 AND (val_2 < 3))) AND
		  (val_1 > 1 OR (val_1 = 1 AND val_2 > 2))
		ORDER BY val_1, val_2;
 val_1 | val_2 
-------+-------
     1 |     3
     1 |     4
     2 |     0
     2 |     1
     2 |     2
(5 rows)

EXPLAIN (COSTS OFF)
	SELECT * FROM o_test_row_searchkey
		WHERE (val_1, val_2) <= (2, 3) AND (val_1, val_2) >= (1, 2)
			ORDER BY val_1, val_2;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Custom Scan (o_scan) on o_test_row_searchkey
   Forward index only scan of: o_test_row_searchkey_pkey
   Conds: ((ROW(val_1, val_2) <= ROW(2, 3)) AND (ROW(val_1, val_2) >= ROW(1, 2)))
(3 rows)

SELECT * FROM o_test_row_searchkey
	WHERE (val_1, val_2) <= (2, 3) AND (val_1, val_2) >= (1, 2)
		ORDER BY val_1, val_2;
 val_1 | val_2 
-------+-------
     1 |     2
     1 |     3
     1 |     4
     2 |     0
     2 |     1
     2 |     2
     2 |     3
(7 rows)

EXPLAIN (COSTS OFF)
	SELECT * FROM o_test_row_searchkey
		WHERE (val_1 < 2 OR (val_1 = 2 AND (val_2 <= 3))) AND
			  (val_1 > 1 OR (val_1 = 1 AND val_2 >= 2))
			ORDER BY val_1, val_2;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Custom Scan (o_scan) on o_test_row_searchkey
   Filter: (((val_1 < 2) OR ((val_1 = 2) AND (val_2 <= 3))) AND ((val_1 > 1) OR ((val_1 = 1) AND (val_2 >= 2))))
   Forward index only scan of: o_test_row_searchkey_pkey
(3 rows)

SELECT * FROM o_test_row_searchkey
	WHERE (val_1 < 2 OR (val_1 = 2 AND (val_2 <= 3))) AND
		  (val_1 > 1 OR (val_1 = 1 AND val_2 >= 2))
		ORDER BY val_1, val_2;
 val_1 | val_2 
-------+-------
     1 |     2
     1 |     3
     1 |     4
     2 |     0
     2 |     1
     2 |     2
     2 |     3
(7 rows)

RESET enable_seqscan;
CREATE TABLE o_test_row_searchkey_pkey_include (
	val_1 int,
	val_2 int,
	PRIMARY KEY(val_1) INCLUDE(val_2)
) USING orioledb;
INSERT INTO o_test_row_searchkey_pkey_include
	SELECT v, NULL FROM generate_series(1,5) v;
SELECT orioledb_tbl_structure('o_test_row_searchkey_pkey_include'::regclass,
							  'nue');
                       orioledb_tbl_structure                        
---------------------------------------------------------------------
 Index o_test_row_searchkey_pkey_include_pkey contents              +
 Page 0: level = 0, maxKeyLen = 24, nVacatedBytes = 0               +
 state = free, datoid equal, relnode equal, ix_type = primary, dirty+
     Leftmost, Rightmost                                            +
   Chunk 0: offset = 0, location = 256, hikey location = 64         +
     Item 0: offset = 272, tuple = ('1', null)                      +
     Item 1: offset = 312, tuple = ('2', null)                      +
     Item 2: offset = 352, tuple = ('3', null)                      +
     Item 3: offset = 392, tuple = ('4', null)                      +
     Item 4: offset = 432, tuple = ('5', null)                      +
                                                                    +
 Index toast: not loaded                                            +
 
(1 row)

EXPLAIN (COSTS OFF)
	SELECT * FROM o_test_row_searchkey_pkey_include
		WHERE (val_1) < (2);
                              QUERY PLAN                              
----------------------------------------------------------------------
 Custom Scan (o_scan) on o_test_row_searchkey_pkey_include
   Forward index only scan of: o_test_row_searchkey_pkey_include_pkey
   Conds: (val_1 < 2)
(3 rows)

SELECT * FROM o_test_row_searchkey_pkey_include
	WHERE (val_1) < (2);
 val_1 | val_2 
-------+-------
     1 |      
(1 row)

CREATE TABLE o_test_duplicate_error (
	val_1 int,
	val_2 int,
	val_3 int,
	val_4 int,
	PRIMARY KEY (val_1,val_2) INCLUDE (val_3,val_4)
) USING orioledb;
INSERT INTO o_test_duplicate_error VALUES (1, 2, 3, 4);
INSERT INTO o_test_duplicate_error VALUES (1, 2, 5, 6);
ERROR:  duplicate key value violates unique constraint "o_test_duplicate_error_pkey"
DETAIL:  Key (val_1, val_2)=('1', '2') already exists.
CREATE TABLE o_test_drop_add_primary (
	val_1 int,
	val_2 int,
	val_3 int,
	val_4 int,
	CONSTRAINT const1 PRIMARY KEY (val_4)
) USING orioledb;
ALTER TABLE o_test_drop_add_primary DROP CONSTRAINT const1;
CREATE UNIQUE INDEX o_test_drop_add_primary_ix1
	ON o_test_drop_add_primary (val_1, val_2) INCLUDE (val_3, val_1);
ALTER TABLE o_test_drop_add_primary ADD PRIMARY KEY (val_4);
\d o_test_drop_add_primary
      Table "indices.o_test_drop_add_primary"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 val_1  | integer |           |          | 
 val_2  | integer |           |          | 
 val_3  | integer |           |          | 
 val_4  | integer |           | not null | 
Indexes:
    "o_test_drop_add_primary_pkey" PRIMARY KEY, btree (val_4)
    "o_test_drop_add_primary_ix1" UNIQUE, btree (val_1, val_2) INCLUDE (val_3, val_1)

TRUNCATE TABLE o_test_drop_add_primary;
CREATE TYPE type_1 AS (
	a int,
	b int
);
CREATE TABLE o_test_add_drop_pkey_same_trx (
	val_1 type_1 NOT NULL,
	val_2 int NOT NULL DEFAULT 5,
	val_3 text DEFAULT 'abc'
) USING orioledb;
CREATE INDEX o_test_add_drop_pkey_same_trx_idx1
	ON o_test_add_drop_pkey_same_trx (val_2, val_3);
INSERT INTO o_test_add_drop_pkey_same_trx VALUES ((1, 2)), ((2, 3));
INSERT INTO o_test_add_drop_pkey_same_trx VALUES ((3, 4), 6, 'def');
SELECT * FROM o_test_add_drop_pkey_same_trx;
 val_1 | val_2 | val_3 
-------+-------+-------
 (1,2) |     5 | abc
 (2,3) |     5 | abc
 (3,4) |     6 | def
(3 rows)

SELECT * FROM o_test_add_drop_pkey_same_trx WHERE val_3 = 'abc';
 val_1 | val_2 | val_3 
-------+-------+-------
 (1,2) |     5 | abc
 (2,3) |     5 | abc
(2 rows)

BEGIN;
ALTER TABLE o_test_add_drop_pkey_same_trx
    ADD CONSTRAINT o_test_add_drop_pkey_same_trx_pkey PRIMARY KEY (val_1);
ALTER TABLE o_test_add_drop_pkey_same_trx
	DROP CONSTRAINT o_test_add_drop_pkey_same_trx_pkey;
SELECT * FROM o_test_add_drop_pkey_same_trx;
 val_1 | val_2 | val_3 
-------+-------+-------
 (1,2) |     5 | abc
 (2,3) |     5 | abc
 (3,4) |     6 | def
(3 rows)

SELECT * FROM o_test_add_drop_pkey_same_trx WHERE val_3 = 'abc';
 val_1 | val_2 | val_3 
-------+-------+-------
 (1,2) |     5 | abc
 (2,3) |     5 | abc
(2 rows)

COMMIT;
CREATE TABLE o_test_unique_ix_duplicate (
	c1 int,
	c2 int,
	c3 int,
	c4 int
) USING orioledb;
INSERT INTO o_test_unique_ix_duplicate VALUES (1, 2, 3, 4);
INSERT INTO o_test_unique_ix_duplicate VALUES (1, 2, 5, 6);
CREATE UNIQUE INDEX o_test_unique_ix_duplicate_uniq1
	ON o_test_unique_ix_duplicate USING btree (c1, c2) INCLUDE (c3, c4);
ERROR:  could not create unique index "o_test_unique_ix_duplicate_uniq1"
DETAIL:  Duplicate keys exist.
CREATE TABLE o_test_expr_index_on_conflict(
	val_1 text NOT NULL,
	val_2 text
)USING orioledb;
CREATE UNIQUE INDEX
	ON o_test_expr_index_on_conflict(lower(val_1));
INSERT INTO o_test_expr_index_on_conflict(val_1, val_2)
	VALUES('AaBb', 'insert1') ON CONFLICT (lower(val_1))
		DO UPDATE set val_1 = EXCLUDED.val_1;
SET enable_seqscan = off;
EXPLAIN (COSTS OFF)
	SELECT * FROM o_test_expr_index_on_conflict ORDER BY lower(val_1);
                            QUERY PLAN                            
------------------------------------------------------------------
 Custom Scan (o_scan) on o_test_expr_index_on_conflict
   Forward index scan of: o_test_expr_index_on_conflict_lower_idx
(2 rows)

SELECT * FROM o_test_expr_index_on_conflict ORDER BY lower(val_1);
 val_1 |  val_2  
-------+---------
 AaBb  | insert1
(1 row)

INSERT INTO o_test_expr_index_on_conflict(val_1, val_2)
	VALUES('AABB', 'insert2') ON CONFLICT (lower(val_1))
		DO UPDATE set val_1 = EXCLUDED.val_1;
SELECT * FROM o_test_expr_index_on_conflict ORDER BY lower(val_1);
 val_1 |  val_2  
-------+---------
 AABB  | insert1
(1 row)

CREATE TABLE o_test_expr_include_index(
	val_1 text NOT NULL,
	val_2 text
)USING orioledb;
CREATE UNIQUE INDEX ON o_test_expr_include_index(lower(val_1)) INCLUDE (val_2);
INSERT INTO o_test_expr_include_index(val_1, val_2)
	VALUES('AaBb', 'insert1') ON CONFLICT (lower(val_1))
		DO UPDATE set val_1 = EXCLUDED.val_1;
EXPLAIN (COSTS OFF)
	SELECT * FROM o_test_expr_include_index ORDER BY lower(val_1);
                             QUERY PLAN                             
--------------------------------------------------------------------
 Custom Scan (o_scan) on o_test_expr_include_index
   Forward index scan of: o_test_expr_include_index_lower_val_2_idx
(2 rows)

SELECT * FROM o_test_expr_include_index ORDER BY lower(val_1);
 val_1 |  val_2  
-------+---------
 AaBb  | insert1
(1 row)

INSERT INTO o_test_expr_include_index(val_1, val_2)
	VALUES('AABB', 'insert2') ON CONFLICT (lower(val_1))
		DO UPDATE set val_1 = EXCLUDED.val_1;
SELECT * FROM o_test_expr_include_index ORDER BY lower(val_1);
 val_1 |  val_2  
-------+---------
 AABB  | insert1
(1 row)

RESET enable_seqscan;
CREATE TABLE o_test_equal_but_binary_not_equal(
  val_1 float4,
  val_2 int,
  PRIMARY KEY (val_1)
)USING orioledb;
SELECT 'NaN'::float4 = '-NaN'::float4;
 ?column? 
----------
 t
(1 row)

SELECT '0'::float4 = '-0'::float4;
 ?column? 
----------
 t
(1 row)

INSERT INTO o_test_equal_but_binary_not_equal VALUES ('NaN', 2);
INSERT INTO o_test_equal_but_binary_not_equal VALUES ('0', 4);
SELECT orioledb_tbl_structure('o_test_equal_but_binary_not_equal'::regclass,
							  'nue');
                       orioledb_tbl_structure                        
---------------------------------------------------------------------
 Index o_test_equal_but_binary_not_equal_pkey contents              +
 Page 0: level = 0, maxKeyLen = 8, nVacatedBytes = 0                +
 state = free, datoid equal, relnode equal, ix_type = primary, dirty+
     Leftmost, Rightmost                                            +
   Chunk 0: offset = 0, location = 256, hikey location = 64         +
     Item 0: offset = 264, tuple = ('0', '4')                       +
     Item 1: offset = 288, tuple = ('NaN', '2')                     +
                                                                    +
 Index toast: not loaded                                            +
 
(1 row)

UPDATE o_test_equal_but_binary_not_equal
	SET val_1 = '-NaN', val_2 = 3 WHERE val_1 = 'NaN';
UPDATE o_test_equal_but_binary_not_equal
	SET val_1 = '-0', val_2 = 3 WHERE val_1 = '0';
SELECT orioledb_tbl_structure('o_test_equal_but_binary_not_equal'::regclass,
							  'nue');
                       orioledb_tbl_structure                        
---------------------------------------------------------------------
 Index o_test_equal_but_binary_not_equal_pkey contents              +
 Page 0: level = 0, maxKeyLen = 8, nVacatedBytes = 0                +
 state = free, datoid equal, relnode equal, ix_type = primary, dirty+
     Leftmost, Rightmost                                            +
   Chunk 0: offset = 0, location = 256, hikey location = 64         +
     Item 0: offset = 264, tuple = ('-0', '3')                      +
     Item 1: offset = 288, tuple = ('NaN', '3')                     +
                                                                    +
 Index toast: not loaded                                            +
 
(1 row)

CREATE TABLE o_test_pkey_include_same_fields
(
	val_1 int,
	val_2 int,
	PRIMARY KEY (val_1) INCLUDE (val_2, val_2)
) USING orioledb;
CREATE INDEX o_test_pkey_include_same_fields_ix1
	ON o_test_pkey_include_same_fields (val_1) INCLUDE (val_2, val_2);
\d+ o_test_pkey_include_same_fields
                     Table "indices.o_test_pkey_include_same_fields"
 Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
--------+---------+-----------+----------+---------+---------+--------------+-------------
 val_1  | integer |           | not null |         | plain   |              | 
 val_2  | integer |           |          |         | plain   |              | 
Indexes:
    "o_test_pkey_include_same_fields_pkey" PRIMARY KEY, btree (val_1) INCLUDE (val_2, val_2)
    "o_test_pkey_include_same_fields_ix1" btree (val_1) INCLUDE (val_2, val_2)

SELECT orioledb_tbl_indices('o_test_pkey_include_same_fields'::regclass);
              orioledb_tbl_indices              
------------------------------------------------
 Index o_test_pkey_include_same_fields_pkey    +
     Index type: primary, unique               +
     Leaf tuple size: 2, non-leaf tuple size: 2+
     Non-leaf tuple fields: val_1, val_2       +
 Index o_test_pkey_include_same_fields_ix1     +
     Index type: secondary                     +
     Leaf tuple size: 2, non-leaf tuple size: 2+
     Non-leaf tuple fields: val_1, val_2       +
     Leaf tuple fields: val_1, val_2           +
 
(1 row)

INSERT INTO o_test_pkey_include_same_fields VALUES (1, 1);
SELECT * FROM o_test_pkey_include_same_fields;
 val_1 | val_2 
-------+-------
     1 |     1
(1 row)

EXPLAIN (COSTS OFF)
	UPDATE o_test_pkey_include_same_fields SET val_2 = 2 WHERE val_1 = 1;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Update on o_test_pkey_include_same_fields
   ->  Custom Scan (o_scan) on o_test_pkey_include_same_fields
         Forward index scan of: o_test_pkey_include_same_fields_ix1
         Conds: (val_1 = 1)
(4 rows)

UPDATE o_test_pkey_include_same_fields SET val_2 = 2 WHERE val_1 = 1;
SELECT * FROM o_test_pkey_include_same_fields;
 val_1 | val_2 
-------+-------
     1 |     2
(1 row)

CREATE TABLE o_test_include_same_as_pkey
(
	val_1 int,
	val_2 int,
	PRIMARY KEY (val_1) INCLUDE (val_1)
) USING orioledb;
CREATE INDEX o_test_include_same_as_pkey_ix1
	ON o_test_include_same_as_pkey (val_1) INCLUDE (val_1);
INSERT INTO o_test_include_same_as_pkey VALUES (1, 1);
SELECT * FROM o_test_include_same_as_pkey;
 val_1 | val_2 
-------+-------
     1 |     1
(1 row)

EXPLAIN (COSTS OFF)
	UPDATE o_test_include_same_as_pkey SET val_2 = 2 WHERE val_1 = 1;
                           QUERY PLAN                           
----------------------------------------------------------------
 Update on o_test_include_same_as_pkey
   ->  Custom Scan (o_scan) on o_test_include_same_as_pkey
         Forward index scan of: o_test_include_same_as_pkey_ix1
         Conds: (val_1 = 1)
(4 rows)

UPDATE o_test_include_same_as_pkey SET val_2 = 2 WHERE val_1 = 1;
DROP EXTENSION orioledb CASCADE;
NOTICE:  drop cascades to 53 other objects
DETAIL:  drop cascades to table o_test50
drop cascades to table o_test51
drop cascades to table o_test52
drop cascades to table o_test53
drop cascades to table o_test54
drop cascades to table o_test55
drop cascades to table o_test56
drop cascades to table o_test57
drop cascades to table o_test58
drop cascades to table o_test59
drop cascades to table o_test61
drop cascades to table o_test65
drop cascades to table o_test66
drop cascades to table o_test67
drop cascades to table o_test68
drop cascades to table o_test69
drop cascades to table o_test70
drop cascades to table o_test71
drop cascades to table o_test72
drop cascades to table o_test73
drop cascades to table o_test74
drop cascades to table o_test75
drop cascades to table o_test76
drop cascades to table o_test77
drop cascades to table o_test78
drop cascades to table o_test79
drop cascades to table o_test82
drop cascades to table o_test83
drop cascades to table o_test_partial_idx_update
drop cascades to table o_test_unique_as_pkey
drop cascades to table o_test_renames_as_ix
drop cascades to table o_test_subexpr_collate
drop cascades to table o_test_reuse_multiple_indices
drop cascades to table o_test_include_like
drop cascades to table o_test_partial_unique
drop cascades to table o_test_unique_expr
drop cascades to table o_test_reindex_empty
drop cascades to table o_test_pkey_mixed
drop cascades to table o_test_pkey_include_box
drop cascades to table o_test_include_box
drop cascades to table o_test_include_box_with_pkey
drop cascades to table o_test_drop_included_pkey_field
drop cascades to table o_test_row_searchkey
drop cascades to table o_test_row_searchkey_pkey_include
drop cascades to table o_test_duplicate_error
drop cascades to table o_test_drop_add_primary
drop cascades to table o_test_add_drop_pkey_same_trx
drop cascades to table o_test_unique_ix_duplicate
drop cascades to table o_test_expr_index_on_conflict
drop cascades to table o_test_expr_include_index
drop cascades to table o_test_equal_but_binary_not_equal
drop cascades to table o_test_pkey_include_same_fields
drop cascades to table o_test_include_same_as_pkey
DROP SCHEMA indices CASCADE;
NOTICE:  drop cascades to 4 other objects
DETAIL:  drop cascades to function smart_explain(text)
drop cascades to table test66
drop cascades to table pg_test_include_like
drop cascades to type type_1
RESET search_path;
