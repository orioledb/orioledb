#!/usr/bin/env python3

import os
import pathlib
import shutil
import sys

from os import listdir
from os.path import isfile, join
from inspect import cleandoc
from textwrap import dedent, indent

from test.pg_tests.utils import file_name_to_test_name

expectedFailures = []

if not 'PG_SRC_PATH' in os.environ:
	print("PG_SRC_PATH env variable should be path to postgres sources",
	      file=sys.stderr)

script_path = os.path.dirname(os.path.realpath(__file__))
recoverydir = join(os.environ['PG_SRC_PATH'], 'src/test/recovery/t')
bindir = pathlib.Path(shutil.which("postgres")).parent.resolve()
pattern = join(recoverydir, "*")
include_path = join(script_path, "perl_include")

tests = [
    f for f in listdir(recoverydir)
    if isfile(join(recoverydir, f)) and f.endswith(".pl")
]

single_test_path = os.path.join(script_path, '_g_rec_single_test.py')
with open(single_test_path, 'w') as f:
	f.write(
	    cleandoc(f"""
		# generated by test/pg_tests/isolation.py
		from ..t.base_test import BaseTest
		from .utils import prove
		from unittest import expectedFailure

		class Run(BaseTest):
	"""))
	f.write(
	    indent(
	        dedent(f"""
			test_path = "{recoverydir}"
			include_path = "{include_path}"

	"""), "\t"))
	for test in tests:
		if test not in expectedFailures:
			decorator = ""
		else:
			decorator = "@expectedFailure"
		f.write(
		    indent(
		        dedent(f"""
			{decorator}
			def {file_name_to_test_name(test)}(self):
				node = self.node
				node.append_conf(default_table_access_method='orioledb')
				# node.start()
				prove(node, "{test}", test_path=self.test_path, include_path=self.include_path, verbose=True)
				# node.stop()
		"""), "\t"))

from . import _g_rec_single_test

# shortcuts for calling single tests like this "test.pg_tests.recovery.test_replslot_limit"
for test in tests:
	globals()[file_name_to_test_name(
	    test)] = lambda testname=test: _g_rec_single_test.Run(
	        file_name_to_test_name(testname))

from ._g_rec_single_test import Run
