/*-------------------------------------------------------------------------
 *
 * page_chunks.c
 *		Internals of OrioleDB page chunks: routines for working with chunks
 *		and their items.
 *
 * Copyright (c) 2021-2025, Oriole DB Inc.
 * Copyright (c) 2025, Supabase Inc.
 *
 * IDENTIFICATION
 *	  contrib/orioledb/src/btree/page_chunks.c
 *
 *-------------------------------------------------------------------------
 */
#include "postgres.h"

#include "orioledb.h"

#include "btree/find.h"
#include "btree/insert.h"
#include "btree/page_chunks.h"
#include "btree/undo.h"
#include "recovery/recovery.h"
#include "transam/undo.h"
#include "tuple/format.h"
#include "utils/page_pool.h"
#include "utils/ucm.h"
#include "catalog/sys_trees.h"

#include "access/transam.h"
#include "miscadmin.h"
#include "utils/memdebug.h"

/*
 * Load chunk to the partial page.
 */
bool
partial_load_hikeys_chunk(PartialPageState *partial, Page img)
{
	uint64		imgState,
				srcState;
	Page		src = partial->src;
	LocationIndex chunkBegin,
				chunkEnd;
	BTreePageHeader *header = (BTreePageHeader *) img;

	if (!partial->isPartial || partial->hikeysChunkIsLoaded)
		return true;

	chunkBegin = offsetof(BTreePageHeader, chunkDesc);
	chunkEnd = header->hikeysEnd;

	Assert(chunkBegin >= 0 && chunkBegin <= ORIOLEDB_BLCKSZ);
	Assert(chunkEnd >= 0 && chunkEnd <= ORIOLEDB_BLCKSZ);

	memcpy((Pointer) img + chunkBegin,
		   (Pointer) src + chunkBegin,
		   chunkEnd - chunkBegin);

	pg_read_barrier();

	imgState = pg_atomic_read_u64(&(O_PAGE_HEADER(img)->state));
	srcState = pg_atomic_read_u64(&(O_PAGE_HEADER(src)->state));
	if ((imgState & PAGE_STATE_CHANGE_COUNT_MASK) != (srcState & PAGE_STATE_CHANGE_COUNT_MASK) ||
		O_PAGE_STATE_READ_IS_BLOCKED(srcState))
		return false;

	if (O_PAGE_GET_CHANGE_COUNT(img) != O_PAGE_GET_CHANGE_COUNT(src))
		return false;

	partial->hikeysChunkIsLoaded = true;
	return true;
}

/*
 * Load chunk to the partial page.
 */
bool
partial_load_chunk(PartialPageState *partial, Page img,
				   OffsetNumber chunkOffset, BTreePageItemLocator *loc)
{
	uint64		imgState = pg_atomic_read_u64(&(O_PAGE_HEADER(img)->state)),
				srcState;
	Page		src = partial->src;
	LocationIndex chunkBegin,
				chunkEnd;
	BTreePageHeader *header;

	if (!partial->isPartial || partial->chunkIsLoaded[chunkOffset])
		return true;

	if (partial->hikeysChunkIsLoaded)
	{
		header = (BTreePageHeader *) img;
		chunkBegin = SHORT_GET_LOCATION(header->chunkDesc[chunkOffset].shortLocation);
		if (chunkOffset + 1 < header->chunksCount)
		{
			if (loc)
				loc->chunkItemsCount = header->chunkDesc[chunkOffset + 1].offset -
					header->chunkDesc[chunkOffset].offset;
			chunkEnd = SHORT_GET_LOCATION(header->chunkDesc[chunkOffset + 1].shortLocation);
		}
		else
		{
			if (loc)
				loc->chunkItemsCount = header->itemsCount -
					header->chunkDesc[chunkOffset].offset;
			chunkEnd = header->dataSize;
		}
	}
	else
	{
		header = (BTreePageHeader *) src;
		chunkBegin = SHORT_GET_LOCATION(header->chunkDesc[chunkOffset].shortLocation);
		if (chunkOffset + 1 < header->chunksCount)
		{
			if (loc)
				loc->chunkItemsCount = header->chunkDesc[chunkOffset + 1].offset -
					header->chunkDesc[chunkOffset].offset;
			chunkEnd = SHORT_GET_LOCATION(header->chunkDesc[chunkOffset + 1].shortLocation);
		}
		else
		{
			if (loc)
				loc->chunkItemsCount = header->itemsCount -
					header->chunkDesc[chunkOffset].offset;
			chunkEnd = header->dataSize;
		}

		pg_read_barrier();

		srcState = pg_atomic_read_u64(&(O_PAGE_HEADER(src)->state));
		if ((imgState & PAGE_STATE_CHANGE_COUNT_MASK) != (srcState & PAGE_STATE_CHANGE_COUNT_MASK) ||
			O_PAGE_STATE_READ_IS_BLOCKED(srcState))
			return false;
	}

	Assert(chunkBegin >= 0 && chunkBegin <= ORIOLEDB_BLCKSZ);
	Assert(chunkEnd >= 0 && chunkEnd <= ORIOLEDB_BLCKSZ);

	VALGRIND_CHECK_MEM_IS_DEFINED((Pointer) src + chunkBegin,
								  chunkEnd - chunkBegin);

	memcpy((Pointer) img + chunkBegin,
		   (Pointer) src + chunkBegin,
		   chunkEnd - chunkBegin);

	pg_read_barrier();

	srcState = pg_atomic_read_u64(&(O_PAGE_HEADER(src)->state));
	if ((imgState & PAGE_STATE_CHANGE_COUNT_MASK) != (srcState & PAGE_STATE_CHANGE_COUNT_MASK) ||
		O_PAGE_STATE_READ_IS_BLOCKED(srcState))
		return false;

	if (O_PAGE_GET_CHANGE_COUNT(img) != O_PAGE_GET_CHANGE_COUNT(src))
		return false;

	partial->chunkIsLoaded[chunkOffset] = true;
	if (loc)
	{
		loc->chunkOffset = chunkOffset;
		loc->itemOffset = 0;
		loc->chunk = (BTreePageChunk *) ((Pointer) img + chunkBegin);
		loc->chunkSize = chunkEnd - chunkBegin;
	}
	return true;
}

BTreeItemPageFitType
page_locator_fits_item(BTreeDescr *desc, Page p, BTreePageItemLocator *locator,
					   LocationIndex size, bool replace, CommitSeqNo csn)
{
	int			freeSpace = BTREE_PAGE_FREE_SPACE(p);
	int			spaceNeeded = size;
	int			compactedFreeSpace;
	int			oldItemSize;

	Assert(spaceNeeded == MAXALIGN(spaceNeeded));

	if (!replace)
	{
		/*
		 * During insert of new item, take into account extension of chunk
		 * items array.
		 */
		spaceNeeded +=
			MAXALIGN((locator->chunkItemsCount + 1) * sizeof(LocationIndex)) -
			MAXALIGN(locator->chunkItemsCount * sizeof(LocationIndex));
	}
	else
	{
		/*
		 * During tuple replacement, take into account change in the item
		 * size. We can replace tuples only on leafs.
		 */
		Assert(O_PAGE_IS(p, LEAF));

		oldItemSize = BTREE_PAGE_GET_ITEM_SIZE(p, locator);

		spaceNeeded -= oldItemSize;
		Assert(spaceNeeded == MAXALIGN(spaceNeeded));
	}

	if (freeSpace >= spaceNeeded)
	{
		/* Already have enough of free space on the page */
		return BTreeItemPageFitAsIs;
	}

	/*
	 * Tuple didn't fit "as is".  Page needs compaction or split.
	 */
	Assert(spaceNeeded >= 0);

	/*
	 * Compaction is only possible on leafs, and not possible for bridge
	 * indexes.
	 */
	if (!O_PAGE_IS(p, LEAF) || desc->type == oIndexBridge)
		return BTreeItemPageFitSplitRequired;

	/* Start with optimistic estimate of free space after compaction */
	compactedFreeSpace = freeSpace + PAGE_GET_N_VACATED(p);

	if (replace)
	{
		/* Correct the estimation according to our tuple replacement */
		BTreeLeafTuphdr *tupHdr;

		tupHdr = (BTreeLeafTuphdr *) BTREE_PAGE_LOCATOR_GET_ITEM(p, locator);

		if (tupHdr->deleted)
		{
			/*
			 * If the current tuple is deleted, then the item size is already
			 * in out estimation.  However, we also took into account for
			 * spaceNeeded.  Correct our calculation of free space after
			 * compaction.
			 */
			compactedFreeSpace -= BTREE_PAGE_GET_ITEM_SIZE(p, locator);
		}
		else
		{
			OTuple		tuple;
			int			oldItemCompactedSize;

			/*
			 * Similarly to the previous case, the possible tuple shrinking is
			 * both in our estimation of free space after compaction and in
			 * the spaceNeeded.
			 */
			BTREE_PAGE_READ_LEAF_TUPLE(tuple, p, locator);
			oldItemCompactedSize = (BTreeLeafTuphdrSize + MAXALIGN(o_btree_len(desc, tuple, OTupleLength)));

			Assert(oldItemSize >= oldItemCompactedSize);
			compactedFreeSpace -= (oldItemSize - oldItemCompactedSize);
		}
	}

	/*
	 * We have a chance to do a compation on leaf.  Check if at least
	 * optimistic esimate will work.
	 */
	if (compactedFreeSpace < spaceNeeded)
		return BTreeItemPageFitSplitRequired;

	/*
	 * Switch to real estimate.  Real estimate is much slower, but there is a
	 * good chance to avoid a page split.  For the tuple replacement case,
	 * skip item to be replaced from the calculation, as it's already taken
	 * into account for spaceNeeded.
	 */
	if (!replace)
		compactedFreeSpace = freeSpace + page_get_vacated_space(desc, p, csn);
	else
		compactedFreeSpace = freeSpace + page_get_vacated_skip_item(desc, p, csn, BTREE_PAGE_LOCATOR_GET_OFFSET(p, locator));

	if (compactedFreeSpace >= spaceNeeded)
		return BTreeItemPageFitCompactRequired;
	else
		return BTreeItemPageFitSplitRequired;
}

void
init_page_first_chunk(BTreeDescr *desc, Page p, LocationIndex hikeySize)
{
	BTreePageHeader *header = (BTreePageHeader *) p;

	Assert(hikeySize == MAXALIGN(hikeySize));

	if (hikeySize == 0)
		header->flags |= O_BTREE_FLAG_HIKEYS_FIXED;

	header->chunksCount = 1;
	header->itemsCount = 0;

	header->hikeysEnd = MAXALIGN(sizeof(BTreePageHeader)) + hikeySize;
	if (header->hikeysEnd > BTREE_PAGE_HIKEYS_END(desc, p))
		header->dataSize = header->hikeysEnd;
	else
		header->dataSize = BTREE_PAGE_HIKEYS_END(desc, p);

	header->chunkDesc[0].hikeyShortLocation = LOCATION_GET_SHORT(MAXALIGN(sizeof(BTreePageHeader)));
	header->chunkDesc[0].shortLocation = LOCATION_GET_SHORT(header->dataSize);
	header->chunkDesc[0].offset = 0;
	header->chunkDesc[0].hikeyFlags = 0;
	header->chunkDesc[0].chunkKeysFixed = 1;
}

void
page_chunk_fill_locator(Page p, OffsetNumber chunkOffset,
						BTreePageItemLocator *locator)
{
	BTreePageHeader *header = (BTreePageHeader *) p;

	if (chunkOffset + 1 < header->chunksCount)
	{
		locator->chunkItemsCount = header->chunkDesc[chunkOffset + 1].offset -
			header->chunkDesc[chunkOffset].offset;
		locator->chunkSize = SHORT_GET_LOCATION(header->chunkDesc[chunkOffset + 1].shortLocation) -
			SHORT_GET_LOCATION(header->chunkDesc[chunkOffset].shortLocation);
	}
	else
	{
		locator->chunkItemsCount = header->itemsCount -
			header->chunkDesc[chunkOffset].offset;
		locator->chunkSize = header->dataSize -
			SHORT_GET_LOCATION(header->chunkDesc[chunkOffset].shortLocation);
	}
	locator->chunkOffset = chunkOffset;
	locator->itemOffset = 0;
	locator->chunk = (BTreePageChunk *) (p + SHORT_GET_LOCATION(header->chunkDesc[chunkOffset].shortLocation));
}

void
page_item_fill_locator(Page p, OffsetNumber itemOffset,
					   BTreePageItemLocator *locator)
{
	BTreePageHeader *header = (BTreePageHeader *) p;
	OffsetNumber chunkOffset;

	chunkOffset = 0;
	while (chunkOffset < header->chunksCount - 1 &&
		   itemOffset >= header->chunkDesc[chunkOffset + 1].offset)
		chunkOffset++;

	page_chunk_fill_locator(p, chunkOffset, locator);
	locator->itemOffset = itemOffset - header->chunkDesc[chunkOffset].offset;
}

void
page_item_fill_locator_backwards(Page p, OffsetNumber itemOffset,
								 BTreePageItemLocator *locator)
{
	BTreePageHeader *header = (BTreePageHeader *) p;
	OffsetNumber chunkOffset;

	chunkOffset = header->chunksCount - 1;
	while (itemOffset < header->chunkDesc[chunkOffset].offset)
	{
		Assert(chunkOffset > 0);
		chunkOffset--;
	}

	page_chunk_fill_locator(p, chunkOffset, locator);
	locator->itemOffset = itemOffset - header->chunkDesc[chunkOffset].offset;
}

/*
 * Locate the next page item.
 */
bool
page_locator_next_chunk(Page p, BTreePageItemLocator *locator)
{
	while (locator->itemOffset >= locator->chunkItemsCount)
	{
		BTreePageHeader *header = (BTreePageHeader *) p;

		if (locator->chunkOffset + 1 < header->chunksCount)
		{
			page_chunk_fill_locator(p, locator->chunkOffset + 1, locator);
		}
		else
		{
			return false;
		}
	}
	return true;
}

/*
 * Locate the next page item.
 */
bool
page_locator_prev_chunk(Page p, BTreePageItemLocator *locator)
{
	do
	{
		if (locator->chunkOffset > 0)
		{
			page_chunk_fill_locator(p, locator->chunkOffset - 1, locator);
		}
		else
		{
			locator->chunk = NULL;
			return false;
		}
	}
	while (locator->chunkItemsCount == 0);
	locator->itemOffset = locator->chunkItemsCount - 1;
	return true;
}

/*
 * Insert a new item of given size at the given location.
 */
void
page_locator_insert_item(Page p, BTreePageItemLocator *locator,
						 LocationIndex itemsize)
{
	int			itemsShift,
				dataShift;
	Pointer		firstItemPtr,
				itemPtr,
				endPtr;
	BTreePageHeader *header = (BTreePageHeader *) p;
	OffsetNumber i;

	Assert(itemsize == MAXALIGN(itemsize));

	/* Calculate the change of (maxaligned) item array size */
	itemsShift = MAXALIGN(sizeof(LocationIndex) * (locator->chunkItemsCount + 1)) -
		MAXALIGN(sizeof(LocationIndex) * locator->chunkItemsCount);

	/* Calculate the shift of the data after new item inserted */
	dataShift = itemsShift + itemsize;

	firstItemPtr = (Pointer) locator->chunk +
		MAXALIGN(sizeof(LocationIndex) * locator->chunkItemsCount);

	if (locator->itemOffset < locator->chunkItemsCount)
	{
		itemPtr = (Pointer) locator->chunk +
			ITEM_GET_OFFSET(locator->chunk->items[locator->itemOffset]);
	}
	else
	{
		Assert(locator->itemOffset == locator->chunkItemsCount);
		itemPtr = (Pointer) locator->chunk + locator->chunkSize;
	}
	endPtr = (Pointer) p + header->dataSize;

	/* Data should still fit to the page */
	Assert(endPtr + dataShift <= (Pointer) p + ORIOLEDB_BLCKSZ);

	/* Shift the data after insert location */
	Assert(itemPtr <= endPtr);
	memmove(itemPtr + dataShift, itemPtr, endPtr - itemPtr);

	/* Adjust chunks parameters */
	for (i = locator->chunkOffset + 1; i < header->chunksCount; i++)
	{
		header->chunkDesc[i].shortLocation += LOCATION_GET_SHORT(dataShift);
		header->chunkDesc[i].offset++;
	}
	header->itemsCount++;
	header->dataSize += dataShift;

	if (itemsShift != 0)
	{
		/*
		 * If items array size is changed, then we have to also move the items
		 * before insert location and adjust those locations in the items
		 * array.
		 */
		memmove(firstItemPtr + itemsShift, firstItemPtr, itemPtr - firstItemPtr);
		for (i = 0; i < locator->itemOffset; i++)
			locator->chunk->items[i] += itemsShift;
	}

	/* Add new element to the items array  */
	for (i = locator->chunkItemsCount; i > locator->itemOffset; i--)
		locator->chunk->items[i] = locator->chunk->items[i - 1] + dataShift;
	locator->chunk->items[locator->itemOffset] = (Pointer) itemPtr - (Pointer) locator->chunk + itemsShift;

	/* Adjust the locator */
	locator->chunkItemsCount++;
	locator->chunkSize += dataShift;
}

bool
page_locator_fits_new_item(Page p, BTreePageItemLocator *locator,
						   LocationIndex itemsize)
{
	LocationIndex sizeDiff;

	sizeDiff = MAXALIGN(sizeof(LocationIndex) * (locator->chunkItemsCount + 1)) -
		MAXALIGN(sizeof(LocationIndex) * locator->chunkItemsCount);

	sizeDiff += MAXALIGN(itemsize);

	return BTREE_PAGE_FREE_SPACE(p) >= sizeDiff;
}

/*
 * Get size of the item at given location.
 */
LocationIndex
page_locator_get_item_size(Page p, BTreePageItemLocator *locator)
{
	LocationIndex itemOffset,
				nextItemOffset;
	BTreePageHeader *header = (BTreePageHeader *) p;

	/* Calculate offset form the beginning of the chunk */
	itemOffset = ITEM_GET_OFFSET(locator->chunk->items[locator->itemOffset]);
	if (locator->itemOffset + 1 < locator->chunkItemsCount)
	{
		/* Next item is in the same chunk */
		nextItemOffset = ITEM_GET_OFFSET(locator->chunk->items[locator->itemOffset + 1]);
	}
	else
	{
		/*
		 * Next item is in the next chunk. Recalculate offsets from the
		 * beginning of the page.
		 */
		itemOffset += (Pointer) locator->chunk - (Pointer) p;
		if (locator->chunkOffset + 1 < header->chunksCount)
			nextItemOffset = SHORT_GET_LOCATION(header->chunkDesc[locator->chunkOffset + 1].shortLocation);
		else
			nextItemOffset = header->dataSize;
	}
	return (nextItemOffset - itemOffset);
}

/*
 * Resizes page item under given locator.
 */
void
page_locator_resize_item(Page p, BTreePageItemLocator *locator,
						 LocationIndex newsize)
{
	int			dataShift;
	Pointer		nextItemPtr,
				endPtr;
	BTreePageHeader *header = (BTreePageHeader *) p;
	OffsetNumber i;

	/* Calculate data shift */
	Assert(newsize == MAXALIGN(newsize));
	dataShift = newsize - page_locator_get_item_size(p, locator);
	Assert(dataShift == MAXALIGN(dataShift));

	if (dataShift == 0)
		return;

	Assert(locator->itemOffset < locator->chunkSize);
	if (locator->itemOffset + 1 < locator->chunkItemsCount)
		nextItemPtr = (Pointer) locator->chunk +
			ITEM_GET_OFFSET(locator->chunk->items[locator->itemOffset + 1]);
	else
		nextItemPtr = (Pointer) locator->chunk + locator->chunkSize;
	endPtr = (Pointer) p + header->dataSize;

	Assert(endPtr + dataShift <= (Pointer) p + ORIOLEDB_BLCKSZ);

	/* Shift the data after the item */
	memmove(nextItemPtr + dataShift, nextItemPtr, endPtr - nextItemPtr);

	/* Adjust chunk positions */
	for (i = locator->chunkOffset + 1; i < header->chunksCount; i++)
		header->chunkDesc[i].shortLocation += LOCATION_GET_SHORT(dataShift);
	header->dataSize += dataShift;

	/* Adjust the items array */
	for (i = locator->itemOffset + 1; i < locator->chunkItemsCount; i++)
		locator->chunk->items[i] += dataShift;

	/* Adjust the locator */
	locator->chunkSize += dataShift;
}

/*
 * Merge two chunks into one.
 */
static void
page_merge_chunks(Page p, OffsetNumber index)
{
	LocationIndex tmpItems[BTREE_PAGE_MAX_CHUNK_ITEMS],
				hikeyShift,
				hikeyShift2,
				shift1,
				shift2;
	OffsetNumber i,
				count1,
				count2;
	BTreePageHeader *header = (BTreePageHeader *) p;
	BTreePageItemLocator loc1,
				loc2;
	Pointer		chunk1DataPtr,
				chunk1EndPtr,
				chunk2DataPtr,
				endPtr,
				p1_1,
				p1_2,
				p2_1,
				p2_2;
	int			len1,
				len2;

	Assert(index + 1 < header->chunksCount);

	page_chunk_fill_locator(p, index, &loc1);
	page_chunk_fill_locator(p, index + 1, &loc2);

	count1 = loc1.chunkItemsCount;
	count2 = loc2.chunkItemsCount;

	chunk1DataPtr = (Pointer) loc1.chunk +
		MAXALIGN(sizeof(LocationIndex) * count1);
	chunk1EndPtr = (Pointer) loc1.chunk + loc1.chunkSize;

	chunk2DataPtr = (Pointer) loc2.chunk +
		MAXALIGN(sizeof(LocationIndex) * count2);
	endPtr = (Pointer) p + header->dataSize;

	shift1 = MAXALIGN(sizeof(LocationIndex) * (count1 + count2)) -
		MAXALIGN(sizeof(LocationIndex) * count1);
	shift2 = MAXALIGN(sizeof(LocationIndex) * count1) +
		MAXALIGN(sizeof(LocationIndex) * count2) -
		MAXALIGN(sizeof(LocationIndex) * (count1 + count2));

	tmpItems[0] = 0;
	for (i = 0; i < count2; i++)
	{
		tmpItems[i] = loc2.chunk->items[i] -
			MAXALIGN(sizeof(LocationIndex) * count2) +
			MAXALIGN(sizeof(LocationIndex) * (count1 + count2)) +
			(chunk1EndPtr - chunk1DataPtr);
	}

	if (shift1 != 0)
	{
		for (i = 0; i < count1; i++)
			loc1.chunk->items[i] += shift1;
		memmove(chunk1DataPtr + shift1,
				chunk1DataPtr,
				chunk1EndPtr - chunk1DataPtr);
	}

	if (shift2 != 0)
	{
		memmove(chunk2DataPtr - shift2,
				chunk2DataPtr,
				endPtr - chunk2DataPtr);
		header->dataSize -= shift2;
	}

	memcpy((Pointer) loc1.chunk + sizeof(LocationIndex) * count1,
		   tmpItems,
		   sizeof(LocationIndex) * count2);

	hikeyShift = MAXALIGN(offsetof(BTreePageHeader, chunkDesc) + sizeof(BTreePageChunkDesc) * header->chunksCount) -
		MAXALIGN(offsetof(BTreePageHeader, chunkDesc) + sizeof(BTreePageChunkDesc) * (header->chunksCount - 1));
	hikeyShift2 = hikeyShift +
		SHORT_GET_LOCATION(header->chunkDesc[index + 1].hikeyShortLocation) -
		SHORT_GET_LOCATION(header->chunkDesc[index].hikeyShortLocation);

	p1_1 = (Pointer) p + SHORT_GET_LOCATION(header->chunkDesc[0].hikeyShortLocation) - hikeyShift;
	p1_2 = (Pointer) p + SHORT_GET_LOCATION(header->chunkDesc[0].hikeyShortLocation);
	len1 = SHORT_GET_LOCATION(header->chunkDesc[index].hikeyShortLocation) -
		SHORT_GET_LOCATION(header->chunkDesc[0].hikeyShortLocation);

	p2_1 = (Pointer) p + SHORT_GET_LOCATION(header->chunkDesc[index].hikeyShortLocation) - hikeyShift;
	p2_2 = (Pointer) p + SHORT_GET_LOCATION(header->chunkDesc[index + 1].hikeyShortLocation);
	len2 = header->hikeysEnd - SHORT_GET_LOCATION(header->chunkDesc[index + 1].hikeyShortLocation);

	header->chunkDesc[index].hikeyFlags = header->chunkDesc[index + 1].hikeyFlags;
	header->chunkDesc[index].chunkKeysFixed &= header->chunkDesc[index + 1].chunkKeysFixed;
	for (i = index + 2; i < header->chunksCount; i++)
	{
		header->chunkDesc[i - 1].offset = header->chunkDesc[i].offset;
		header->chunkDesc[i - 1].hikeyFlags = header->chunkDesc[i].hikeyFlags;
		header->chunkDesc[i - 1].chunkKeysFixed = header->chunkDesc[i].chunkKeysFixed;
		header->chunkDesc[i - 1].hikeyShortLocation = header->chunkDesc[i].hikeyShortLocation - LOCATION_GET_SHORT(hikeyShift2);
		header->chunkDesc[i - 1].shortLocation = header->chunkDesc[i].shortLocation - LOCATION_GET_SHORT(shift2);
	}

	if (hikeyShift > 0)
	{
		for (i = 0; i <= index; i++)
			header->chunkDesc[i].hikeyShortLocation = header->chunkDesc[i].hikeyShortLocation - LOCATION_GET_SHORT(hikeyShift);
	}

	if (hikeyShift > 0)
		memmove(p1_1, p1_2, len1);

	memmove(p2_1, p2_2, len2);

	header->hikeysEnd -= hikeyShift2;
	header->chunksCount--;

	header->flags |= O_BTREE_FLAG_HIKEYS_FIXED;
	for (i = 0; i < header->chunksCount; i++)
	{
		if (!(header->chunkDesc[i].hikeyFlags & O_TUPLE_FLAGS_FIXED_FORMAT))
			header->flags &= ~O_BTREE_FLAG_HIKEYS_FIXED;
	}

	VALGRIND_CHECK_MEM_IS_DEFINED(p, ORIOLEDB_BLCKSZ);
}

/*
 * Deletes page item under given locator.
 */
void
page_locator_delete_item(Page p, BTreePageItemLocator *locator)
{
	int			itemsShift,
				dataShift,
				itemsize;
	Pointer		firstItemPtr,
				itemPtr,
				endPtr;
	BTreePageHeader *header = (BTreePageHeader *) p;
	OffsetNumber i;

	/* Get item size */
	itemsize = page_locator_get_item_size(p, locator);
	Assert(itemsize == MAXALIGN(itemsize));

	itemsShift = MAXALIGN(sizeof(LocationIndex) * locator->chunkItemsCount) -
		MAXALIGN(sizeof(LocationIndex) * (locator->chunkItemsCount - 1));
	dataShift = itemsShift + itemsize;

	firstItemPtr = (Pointer) locator->chunk +
		MAXALIGN(sizeof(LocationIndex) * locator->chunkItemsCount);
	Assert(locator->itemOffset < locator->chunkSize);
	itemPtr = (Pointer) locator->chunk +
		ITEM_GET_OFFSET(locator->chunk->items[locator->itemOffset]);
	endPtr = (Pointer) p + header->dataSize;

	Assert(endPtr - dataShift >= itemPtr - itemsShift);

	/*
	 * Adjust the items array.  We should do this first to prevent it been
	 * overridden by the data when it's shorten.
	 */
	for (i = locator->itemOffset; i < locator->chunkItemsCount - 1; i++)
		locator->chunk->items[i] = locator->chunk->items[i + 1] - dataShift;

	if (itemsShift != 0)
	{
		/* Shift the data before deleted item when items arrays is shorten. */
		memmove(firstItemPtr - itemsShift, firstItemPtr, itemPtr - firstItemPtr);

		/* Shift item pointers of those items */
		for (i = 0; i < locator->itemOffset; i++)
			locator->chunk->items[i] -= itemsShift;
	}

	/* Move the data after deleted item */
	memmove(itemPtr - itemsShift, itemPtr + itemsize, endPtr - itemPtr - itemsize);

	/* Adjust position of following chunks */
	for (i = locator->chunkOffset + 1; i < header->chunksCount; i++)
	{
		header->chunkDesc[i].shortLocation -= LOCATION_GET_SHORT(dataShift);
		header->chunkDesc[i].offset--;
	}
	header->itemsCount--;
	header->dataSize -= dataShift;

	/* Adjust the locator */
	locator->chunkItemsCount--;
	locator->chunkSize -= dataShift;

	if (locator->chunkItemsCount == 0)
	{
		if (locator->chunkOffset > 0)
		{
			page_merge_chunks(p, locator->chunkOffset - 1);
			page_chunk_fill_locator(p, locator->chunkOffset - 1, locator);
			locator->itemOffset = locator->chunkItemsCount;
		}
		else if (locator->chunkOffset + 1 < header->chunksCount)
		{
			page_merge_chunks(p, locator->chunkOffset);
			page_chunk_fill_locator(p, locator->chunkOffset, locator);
		}
	}
}

/*
 * Split the given page chunk into two.
 */
static void
page_split_chunk(BTreeDescr *desc, Page p, BTreePageItemLocator *locator,
				 LocationIndex hikeysEnd, LocationIndex hikeySize)
{
	LocationIndex tmpItems[BTREE_PAGE_MAX_CHUNK_ITEMS],
				leftItemsShift,
				rightItemsShift,
				dataShift,
				chunkDescShift,
				hikeyShift;
	Pointer		firstItemPtr,
				itemPtr,
				endPtr,
				rightChunkPtr,
				firstHikeyPtr,
				hikeyPtr,
				hikeyEndPtr;
	bool		leftChunkKeysFixed = true,
				rightChunkKeysFixed = true;
	OffsetNumber i,
				leftItemsCount,
				rightItemsCount;
	BTreePageHeader *header = (BTreePageHeader *) p;

	if (Log_error_verbosity == PGERROR_TERSE && desc->oids.reloid == SYS_TREES_O_INDICES)
	{
		extern Datum orioledb_sys_tree_structure(PG_FUNCTION_ARGS);
		Datum res;
		text  *options;
		uint32 saved_CritSectionCount = CritSectionCount;
		CritSectionCount = 0;
		options = cstring_to_text("");
		res = DirectFunctionCall3(orioledb_sys_tree_structure, 
		              ObjectIdGetDatum(3),
		              PointerGetDatum(options),
		              Int32GetDatum(PAGE_GET_LEVEL(p) == 0 ? 2 : 1));
		elog(WARNING, "TREE BEFORE CHUNK SPLIT: %s", text_to_cstring(DatumGetTextP(res)));
    	// libunwind_backtrace();
		CritSectionCount = saved_CritSectionCount;
	}
	Assert(hikeySize == MAXALIGN(hikeySize));

	leftItemsCount = locator->itemOffset;
	rightItemsCount = locator->chunkItemsCount - locator->itemOffset;
	firstItemPtr = (Pointer) locator->chunk +
		MAXALIGN(sizeof(LocationIndex) * locator->chunkItemsCount);
	itemPtr = (Pointer) locator->chunk +
		ITEM_GET_OFFSET(locator->chunk->items[locator->itemOffset]);
	endPtr = (Pointer) p + header->dataSize;
	Assert(firstItemPtr >= p && itemPtr >= firstItemPtr && endPtr >= itemPtr);
	Assert(endPtr <= (Pointer) p + ORIOLEDB_BLCKSZ);

	/*
	 * Save positions of the items, which go to the right chunk.  We have to
	 * do this in order to make these items not overridden while data is
	 * moved. Position are counted from the beginning of the new chunk.
	 */
	leftItemsShift = MAXALIGN(sizeof(LocationIndex) * locator->chunkItemsCount) -
		MAXALIGN(sizeof(LocationIndex) * leftItemsCount);
	rightItemsShift = ITEM_GET_OFFSET(locator->chunk->items[locator->itemOffset]) -
		MAXALIGN(sizeof(LocationIndex) * rightItemsCount);
	for (i = locator->itemOffset; i < locator->chunkItemsCount; i++)
	{
		if (!(ITEM_GET_FLAGS(locator->chunk->items[i]) & O_TUPLE_FLAGS_FIXED_FORMAT))
			rightChunkKeysFixed = false;
		tmpItems[i - locator->itemOffset] = locator->chunk->items[i] - rightItemsShift;
	}

	VALGRIND_CHECK_MEM_IS_DEFINED(tmpItems, sizeof(tmpItems[0]) * rightItemsCount);

	/*
	 * Move the data items belong to the left chunk accordingly to new size of
	 * items array.
	 */
	for (i = 0; i < locator->itemOffset; i++)
	{
		if (!(ITEM_GET_FLAGS(locator->chunk->items[i]) & O_TUPLE_FLAGS_FIXED_FORMAT))
			leftChunkKeysFixed = false;
		locator->chunk->items[i] -= leftItemsShift;
	}
	memmove(firstItemPtr - leftItemsShift,
			firstItemPtr,
			itemPtr - firstItemPtr);

	VALGRIND_CHECK_MEM_IS_DEFINED(p, ORIOLEDB_BLCKSZ);

	/* Shift the data items belong to the right chunk */
	dataShift = MAXALIGN(sizeof(LocationIndex) * rightItemsCount) +
		MAXALIGN(sizeof(LocationIndex) * leftItemsCount) -
		MAXALIGN(sizeof(LocationIndex) * locator->chunkItemsCount);
	Assert(itemPtr + dataShift + (endPtr - itemPtr) <= (Pointer) p + ORIOLEDB_BLCKSZ);
	memmove(itemPtr + dataShift, itemPtr, endPtr - itemPtr);

	VALGRIND_CHECK_MEM_IS_DEFINED(p, ORIOLEDB_BLCKSZ);

	/* Place the right chunk items array */
	rightChunkPtr = itemPtr -
		MAXALIGN(sizeof(LocationIndex) * locator->chunkItemsCount) +
		MAXALIGN(sizeof(LocationIndex) * leftItemsCount);
	memcpy(rightChunkPtr, tmpItems, sizeof(LocationIndex) * rightItemsCount);

	VALGRIND_CHECK_MEM_IS_DEFINED(p, ORIOLEDB_BLCKSZ);

	/* Calculate shift of hikeys before the new hikey */
	chunkDescShift = MAXALIGN(offsetof(BTreePageHeader, chunkDesc) + sizeof(BTreePageChunkDesc) * (header->chunksCount + 1)) -
		MAXALIGN(offsetof(BTreePageHeader, chunkDesc) + sizeof(BTreePageChunkDesc) * header->chunksCount);
	/* Calculate shift of hikeys after the new hikey */
	hikeyShift = chunkDescShift + hikeySize;

	firstHikeyPtr = (Pointer) p + SHORT_GET_LOCATION(header->chunkDesc[0].hikeyShortLocation);
	hikeyPtr = (Pointer) p + SHORT_GET_LOCATION(header->chunkDesc[locator->chunkOffset].hikeyShortLocation);
	hikeyEndPtr = (Pointer) p + header->hikeysEnd;
	Assert(firstHikeyPtr >= p && hikeyPtr >= firstHikeyPtr && hikeyEndPtr >= hikeyPtr);

	/* Move hikeys */
	Assert(hikeyEndPtr + hikeyShift <= (Pointer) p + hikeysEnd);
	memmove(hikeyPtr + hikeyShift, hikeyPtr, hikeyEndPtr - hikeyPtr);
	memmove(firstHikeyPtr + chunkDescShift, firstHikeyPtr, hikeyPtr - firstHikeyPtr);

	VALGRIND_CHECK_MEM_IS_DEFINED(p, ORIOLEDB_BLCKSZ);

	/* Adjust chunk descs */
	for (i = 0; i <= locator->chunkOffset; i++)
		header->chunkDesc[i].hikeyShortLocation += LOCATION_GET_SHORT(chunkDescShift);

	if (Log_error_verbosity == PGERROR_TERSE && desc->oids.reloid == SYS_TREES_O_INDICES)
	{
		OInMemoryBlkno blockNumber = (uint64)(p - o_shared_buffers)/((uint64) ORIOLEDB_BLCKSZ);
		elog(WARNING, "blockNumber: %u; level: %d", blockNumber, PAGE_GET_LEVEL(p));
	}

	for (i = header->chunksCount; i > locator->chunkOffset; i--)
	{
		header->chunkDesc[i].hikeyShortLocation = header->chunkDesc[i - 1].hikeyShortLocation + LOCATION_GET_SHORT(hikeyShift);
		if (Log_error_verbosity == PGERROR_TERSE && desc->oids.reloid == SYS_TREES_O_INDICES)
			elog(WARNING, "hikeyShortLocation[%d]: %u", i, SHORT_GET_LOCATION(header->chunkDesc[i].hikeyShortLocation));
		header->chunkDesc[i].hikeyFlags = header->chunkDesc[i - 1].hikeyFlags;
		header->chunkDesc[i].offset = header->chunkDesc[i - 1].offset;
		header->chunkDesc[i].chunkKeysFixed = header->chunkDesc[i - 1].chunkKeysFixed;
		header->chunkDesc[i].shortLocation = header->chunkDesc[i - 1].shortLocation + LOCATION_GET_SHORT(dataShift);
	}

	i = locator->chunkOffset + 1;
	header->chunkDesc[i].hikeyShortLocation = header->chunkDesc[i - 1].hikeyShortLocation +
		LOCATION_GET_SHORT(hikeySize);
	if (Log_error_verbosity == PGERROR_TERSE && desc->oids.reloid == SYS_TREES_O_INDICES)
		elog(WARNING, "hikeyShortLocation[%d]: %u", i, SHORT_GET_LOCATION(header->chunkDesc[i].hikeyShortLocation));
	header->chunkDesc[i].offset = header->chunkDesc[i - 1].offset + leftItemsCount;
	header->chunkDesc[i].shortLocation = LOCATION_GET_SHORT(rightChunkPtr - (Pointer) p);
	header->chunkDesc[i].hikeyFlags = header->chunkDesc[i - 1].hikeyFlags;
	header->chunkDesc[i].chunkKeysFixed = rightChunkKeysFixed ? 1 : 0;
	header->chunkDesc[i - 1].chunkKeysFixed = leftChunkKeysFixed ? 1 : 0;
	header->chunksCount++;
	header->hikeysEnd += hikeyShift;
	header->dataSize += dataShift;

	VALGRIND_CHECK_MEM_IS_DEFINED(p, ORIOLEDB_BLCKSZ);

	page_chunk_fill_locator(p, i, locator);
}

#define MAXALIGN_WASTE(s) \
	((MAXIMUM_ALIGNOF - 1) - ((s) + (MAXIMUM_ALIGNOF - 1)) % (MAXIMUM_ALIGNOF))

static void
o_index_chunk_key_bin_print(BTreeDescr *desc, StringInfo buf, 
							OTuple tup, Pointer arg)
{
}

static void
o_index_chunk_tup_bin_print(BTreeDescr *desc, StringInfo buf, 
							OTuple tup, Pointer arg)
{
}

void
page_split_chunk_if_needed(BTreeDescr *desc, Page p, BTreePageItemLocator *locator)
{
	OffsetNumber i,
				chunkOffset;
	LocationIndex hikeysFreeSpace,
				dataFreeSpace;
	BTreePageHeader *header = (BTreePageHeader *) p;
	int			bestOffset = -1;
	float4		bestScore = 0.0f;
	LocationIndex bestHiKeySize = 0,
				bestHiKeySizeUnaligned = 0,
				hikeysEnd = BTREE_PAGE_HIKEYS_END(desc, p);
	OFixedKey	newHikey;

	VALGRIND_CHECK_MEM_IS_DEFINED(p, ORIOLEDB_BLCKSZ);
	VALGRIND_MAKE_MEM_DEFINED(p, ORIOLEDB_BLCKSZ);

	if (header->hikeysEnd >= hikeysEnd)
		return;

	chunkOffset = locator->chunkOffset;

	if ((float4) locator->chunkSize / (float4) (ORIOLEDB_BLCKSZ - hikeysEnd) <
		(float4) MAXALIGN(header->maxKeyLen) * 2.0f / (float4) (hikeysEnd - offsetof(BTreePageHeader, chunkDesc)))
		return;

	hikeysFreeSpace = hikeysEnd - header->hikeysEnd;
	hikeysFreeSpace -=
		(MAXALIGN(offsetof(BTreePageHeader, chunkDesc) + sizeof(BTreePageChunkDesc) * (header->chunksCount + 1)) -
		 MAXALIGN(offsetof(BTreePageHeader, chunkDesc) + sizeof(BTreePageChunkDesc) * header->chunksCount));
	dataFreeSpace = ORIOLEDB_BLCKSZ - header->dataSize;

	for (i = 1; i < locator->chunkItemsCount; i++)
	{
		LocationIndex hikeySize,
					hikeySizeUnaligned,
					dataSize,
					leftDataSize,
					rightDataSize;
		float4		score;

		locator->itemOffset = i;
		if (O_PAGE_IS(p, LEAF))
		{
			OTuple		tuple;

			tuple.data = BTREE_PAGE_LOCATOR_GET_ITEM(p, locator) + BTreeLeafTuphdrSize;
			tuple.formatFlags = BTREE_PAGE_GET_ITEM_FLAGS(p, locator);
			hikeySizeUnaligned = o_btree_len(desc, tuple, OTupleKeyLengthNoVersion);
			hikeySize = MAXALIGN(hikeySizeUnaligned);
		}
		else
		{
			hikeySize = BTREE_PAGE_GET_ITEM_SIZE(p, locator) -
				BTreeNonLeafTuphdrSize;
			hikeySizeUnaligned = hikeySize;
		}
		if (hikeySize > hikeysFreeSpace)
			continue;

		dataSize = MAXALIGN(i * sizeof(LocationIndex)) +
			MAXALIGN((locator->chunkItemsCount - i) * sizeof(LocationIndex)) -
			MAXALIGN(locator->chunkItemsCount * sizeof(LocationIndex));

		if (dataSize > dataFreeSpace)
			continue;

		leftDataSize = ITEM_GET_OFFSET(locator->chunk->items[locator->itemOffset]);
		rightDataSize = locator->chunkSize - leftDataSize;
		leftDataSize -= MAXALIGN(locator->chunkItemsCount * sizeof(LocationIndex));

		score = (float4) Min(leftDataSize, rightDataSize) / (float4) hikeySize;

		if (score > bestScore)
		{
			bestOffset = i;
			bestHiKeySize = hikeySize;
			bestHiKeySizeUnaligned = hikeySizeUnaligned;
			bestScore = score;
		}
	}

	if (bestOffset < 0)
		return;

	locator->itemOffset = bestOffset;
	if (O_PAGE_IS(p, LEAF))
	{
		OTuple		tuple;
		bool		allocated;

		tuple.data = BTREE_PAGE_LOCATOR_GET_ITEM(p, locator) + BTreeLeafTuphdrSize;
		tuple.formatFlags = BTREE_PAGE_GET_ITEM_FLAGS(p, locator);
		newHikey.tuple = o_btree_tuple_make_key(desc, tuple, newHikey.fixedData,
												false, &allocated);
		if (bestHiKeySize != bestHiKeySizeUnaligned)
			memset(newHikey.fixedData + bestHiKeySizeUnaligned,
				   0,
				   bestHiKeySize - bestHiKeySizeUnaligned);
		Assert(allocated == false);
		VALGRIND_CHECK_MEM_IS_DEFINED(newHikey.fixedData, bestHiKeySizeUnaligned);
		VALGRIND_CHECK_MEM_IS_DEFINED(newHikey.fixedData, bestHiKeySize);
	}
	else
	{
		OTuple		key;

		key.data = BTREE_PAGE_LOCATOR_GET_ITEM(p, locator) + BTreeNonLeafTuphdrSize;
		key.formatFlags = BTREE_PAGE_GET_ITEM_FLAGS(p, locator);
		copy_fixed_key(desc, &newHikey, key);
		VALGRIND_CHECK_MEM_IS_DEFINED(newHikey.fixedData, bestHiKeySize);
	}

	VALGRIND_CHECK_MEM_IS_DEFINED(p, ORIOLEDB_BLCKSZ);
	if (Log_error_verbosity == PGERROR_TERSE && desc->oids.reloid == SYS_TREES_O_INDICES)
	{
		extern Datum orioledb_sys_tree_structure(PG_FUNCTION_ARGS);
		Datum res;
		text  *options;
		uint32 saved_CritSectionCount = CritSectionCount;
		elog(WARNING, "CALLING page_split_chunk");
		CritSectionCount = 0;
		options = cstring_to_text("");
		res = DirectFunctionCall3(orioledb_sys_tree_structure, 
		              ObjectIdGetDatum(3),
		              PointerGetDatum(options),
		              Int32GetDatum(1));
		elog(WARNING, "TREE: %s", text_to_cstring(DatumGetTextP(res)));
    	// libunwind_backtrace();
		CritSectionCount = saved_CritSectionCount;
	}
	page_split_chunk(desc, p, locator, hikeysEnd, bestHiKeySize);

	VALGRIND_CHECK_MEM_IS_DEFINED(p, ORIOLEDB_BLCKSZ);

	memcpy(p + SHORT_GET_LOCATION(header->chunkDesc[chunkOffset].hikeyShortLocation),
		   newHikey.fixedData,
		   bestHiKeySize);
	header->chunkDesc[chunkOffset].hikeyFlags = newHikey.tuple.formatFlags;
	if (!(newHikey.tuple.formatFlags & O_TUPLE_FLAGS_FIXED_FORMAT))
		header->flags &= ~O_BTREE_FLAG_HIKEYS_FIXED;

	VALGRIND_CHECK_MEM_IS_DEFINED(p, ORIOLEDB_BLCKSZ);
	if (Log_error_verbosity == PGERROR_TERSE && desc->oids.reloid == SYS_TREES_O_INDICES)
	{
		extern Datum orioledb_sys_tree_structure(PG_FUNCTION_ARGS);
		extern void print_page_bin_structure(BTreeDescr *desc, OInMemoryBlkno blkno, int *NLRPageNumber, PrintFunc keyBinPrintFunc, PrintFunc tupleBinPrintFunc, Pointer printArg, bool print_bytes, int depthLeft, StringInfo outbuf);
		Datum res;
		text  *options;
		uint32 saved_CritSectionCount = CritSectionCount;
		StringInfo str = makeStringInfo();
		int			NLRPageNumber = 0;

		CritSectionCount = 0;
		options = cstring_to_text("");
		res = DirectFunctionCall3(orioledb_sys_tree_structure, 
		              ObjectIdGetDatum(3),
		              PointerGetDatum(options),
		              Int32GetDatum(PAGE_GET_LEVEL(p) == 0 ? 2 : 1));
		elog(WARNING, "TREE AFTER CHUNK SPLIT: %s", text_to_cstring(DatumGetTextP(res)));

		print_page_bin_structure(get_sys_tree(3), 
								 get_sys_tree(3)->rootInfo.rootPageBlkno, 
								 &NLRPageNumber,
								 o_index_chunk_key_bin_print,
								 o_index_chunk_tup_bin_print,
								 NULL,
								 true,
								 1,
								 str);
		elog(WARNING, "BINARY TREE AFTER CHUNK SPLIT: %s", str->data);
		pfree(str->data);
		pfree(str);
    	// libunwind_backtrace();
		CritSectionCount = saved_CritSectionCount;

	}
}

#ifdef NOT_USED
static void
check_page(BTreeDescr *desc, Page p)
{
	BTreePageItemLocator loc;
	OTuple		prev,
				tup;
	BTreeKeyType kind = O_PAGE_IS(p, LEAF) ? BTreeTuple : BTreeKey;
	BTreePageHeader *header = (BTreePageHeader *) p;

	O_TUPLE_SET_NULL(prev);

	BTREE_PAGE_LOCATOR_FIRST(p, &loc);

	if (!O_PAGE_IS(p, LEAF))
		BTREE_PAGE_LOCATOR_NEXT(p, &loc);

	while (BTREE_PAGE_LOCATOR_IS_VALID(p, &loc))
	{
		BTREE_PAGE_READ_TUPLE(tup, p, &loc);

		if (!O_TUPLE_IS_NULL(prev))
		{
			Assert(o_btree_cmp(desc, &prev, kind, &tup, kind) < 0);
		}

		if (loc.chunkOffset < header->chunksCount - 1 || !O_PAGE_IS(p, RIGHTMOST))
		{
			OTuple		chunkHikey;

			chunkHikey.data = p + SHORT_GET_LOCATION(header->chunkDesc[loc.chunkOffset].hikeyShortLocation);
			chunkHikey.formatFlags = header->chunkDesc[loc.chunkOffset].hikeyFlags;
			Assert(o_btree_cmp(desc, &tup, kind, &chunkHikey, BTreeKey) < 0);
		}

		prev = tup;
		BTREE_PAGE_LOCATOR_NEXT(p, &loc);
	}
}
#endif

static LocationIndex
item_get_key_size(BTreeDescr *desc, bool leaf, BTreePageItem *item)
{
	OTuple		tuple;

	if (leaf)
	{
		tuple.data = item->data + BTreeLeafTuphdrSize;
		tuple.formatFlags = item->flags;
		return MAXALIGN(o_btree_len(desc, tuple, OTupleKeyLengthNoVersion));
	}
	else
	{
		tuple.data = item->data + BTreeNonLeafTuphdrSize;
		tuple.formatFlags = item->flags;
		return MAXALIGN(o_btree_len(desc, tuple, OKeyLength));
	}
}

/*
 * Split the page containing the single chunk into multiple chunks.
 */
void
btree_page_reorg(BTreeDescr *desc, Page p, BTreePageItem *items,
				 OffsetNumber count, LocationIndex hikeySize, OTuple hikey)
{
	int			chunksCount;
	LocationIndex totalDataSize,
				itemHeaderSize = O_PAGE_IS(p, LEAF) ? BTreeLeafTuphdrSize : BTreeNonLeafTuphdrSize;
	BTreePageChunk *chunk;
	BTreePageHeader *header = (BTreePageHeader *) p;
	Pointer		ptr,
				hikeysPtr;
	bool		chunkFixedKeys[BTREE_PAGE_MAX_CHUNKS];
	bool		fixedKeys = true;
	OffsetNumber chunkOffsets[BTREE_PAGE_MAX_CHUNKS + 1];
	LocationIndex itemsArray[BTREE_PAGE_MAX_CHUNK_ITEMS];
	int			i,
				j;
	LocationIndex hikeysFreeSpace,
				hikeysFreeSpaceLeft;
	LocationIndex dataFreeSpace,
				dataFreeSpaceLeft,
				hikeysEnd;
	bool		isRightmost = O_PAGE_IS(p, RIGHTMOST);
	LocationIndex chunkDataSize;
	LocationIndex maxKeyLen;

	VALGRIND_CHECK_MEM_IS_DEFINED(p, ORIOLEDB_BLCKSZ);
	VALGRIND_MAKE_MEM_DEFINED(p, ORIOLEDB_BLCKSZ);

	hikeysEnd = Max(BTREE_PAGE_HIKEYS_END(desc, p), MAXALIGN(sizeof(BTreePageHeader)) + MAXALIGN(hikeySize));

	totalDataSize = 0;
	for (i = 0; i < count; i++)
		totalDataSize += items[i].size;

	hikeysFreeSpaceLeft = hikeysFreeSpace = hikeysEnd - (MAXALIGN(sizeof(BTreePageHeader)) + MAXALIGN(hikeySize));
	dataFreeSpaceLeft = dataFreeSpace = (ORIOLEDB_BLCKSZ - hikeysEnd) - totalDataSize - MAXALIGN(sizeof(LocationIndex) * count);

	/*
	 * Calculate the chunks count to fit both chunks area and data area.
	 */
	maxKeyLen = MAXALIGN(hikeySize);

	/* Calculate chunks boundaries */
	chunkOffsets[0] = 0;
	j = 1;
	chunkDataSize = 0;
	if (count >= 1)
	{
		chunkDataSize += items[0].size;
		if (O_PAGE_IS(p, LEAF) && !(items[0].flags & O_TUPLE_FLAGS_FIXED_FORMAT))
			fixedKeys = false;
	}
	if (O_PAGE_IS(p, LEAF) && count > 0)
		maxKeyLen = Max(maxKeyLen, item_get_key_size(desc, O_PAGE_IS(p, LEAF), &items[0]));

	for (i = 1; i < count; i++)
	{
		LocationIndex nextKeySize,
					hikeySizeDiff,
					dataSpaceDiff;
		float4		dataSizeRatio;

		nextKeySize = item_get_key_size(desc, O_PAGE_IS(p, LEAF), &items[i]);
		maxKeyLen = Max(maxKeyLen, nextKeySize);
		hikeySizeDiff = nextKeySize +
			(MAXALIGN(offsetof(BTreePageHeader, chunkDesc) + sizeof(BTreePageChunkDesc) * (j + 1)) -
			 MAXALIGN(offsetof(BTreePageHeader, chunkDesc) + sizeof(BTreePageChunkDesc) * j));
		dataSpaceDiff = MAXALIGN_WASTE(sizeof(LocationIndex) * (i - chunkOffsets[j - 1]));

		if (hikeySizeDiff > hikeysFreeSpaceLeft ||
			dataSpaceDiff > dataFreeSpaceLeft)
		{
			if (!(items[i].flags & O_TUPLE_FLAGS_FIXED_FORMAT))
				fixedKeys = false;
			chunkDataSize += items[i].size;
			continue;
		}

		dataSizeRatio = (float4) chunkDataSize / (float4) totalDataSize;
		if (dataSizeRatio >= (float4) (nextKeySize + sizeof(BTreePageChunkDesc)) / (float4) hikeysFreeSpace &&
			dataSizeRatio >= (float4) dataSpaceDiff / (float4) dataFreeSpace)
		{
			hikeysFreeSpaceLeft -= hikeySizeDiff;
			dataFreeSpaceLeft -= dataSpaceDiff;
			chunkOffsets[j] = i;
			chunkFixedKeys[j - 1] = fixedKeys;
			fixedKeys = true;
			chunkDataSize = 0;
			j++;
		}

		if (!(items[i].flags & O_TUPLE_FLAGS_FIXED_FORMAT))
			fixedKeys = false;
		chunkDataSize += items[i].size;
	}
	Assert(j <= BTREE_PAGE_MAX_CHUNKS);
	chunkOffsets[j] = count;
	chunkFixedKeys[j - 1] = fixedKeys;
	chunksCount = j;

	/* Calculate chunk items */
	ptr = (Pointer) p + hikeysEnd;
	for (j = 0; j < chunksCount; j++)
	{
		OffsetNumber chunkItemsCount;
		LocationIndex itemShift;

		chunkItemsCount = chunkOffsets[j + 1] - chunkOffsets[j];
		itemShift = MAXALIGN(sizeof(LocationIndex) * chunkItemsCount);

		for (i = chunkOffsets[j]; i < chunkOffsets[j + 1]; i++)
		{
			itemsArray[i] = ITEM_SET_FLAGS(itemShift, items[i].flags);
			itemShift += items[i].size;
		}

		ptr += itemShift;
	}

	header->maxKeyLen = maxKeyLen;
	header->dataSize = ptr - (Pointer) p;
	header->chunksCount = chunksCount;

	/*
	 * Place the chunks data.  We need to do this backwards to be sure we only
	 * move the data forwards and not override.
	 */
	for (j = chunksCount - 1; j >= 0; j--)
	{
		OffsetNumber chunkItemsCount;

		chunkItemsCount = chunkOffsets[j + 1] - chunkOffsets[j];

		for (i = chunkOffsets[j + 1] - 1; i >= chunkOffsets[j]; i--)
		{
			ptr -= items[i].size;

			if (items[i].data >= p && items[i].data < p + ORIOLEDB_BLCKSZ &&
				ptr > items[i].data)
				memmove(ptr, items[i].data, items[i].size);
		}

		ptr -= MAXALIGN(sizeof(LocationIndex) * chunkItemsCount);
	}

	/* Place chunks item arrays and fill chunk descs */
	Assert(ptr == (Pointer) p + hikeysEnd);
	hikeysPtr = (Pointer) p + MAXALIGN(offsetof(BTreePageHeader, chunkDesc) + sizeof(BTreePageChunkDesc) * chunksCount);
	fixedKeys = true;
	for (j = 0; j < chunksCount; j++)
	{
		OffsetNumber chunkItemsCount;

		chunkItemsCount = chunkOffsets[j + 1] - chunkOffsets[j];
		i = chunkOffsets[j];
		memmove(ptr, &itemsArray[i], sizeof(LocationIndex) * chunkItemsCount);
		chunk = (BTreePageChunk *) ptr;
		header->chunkDesc[j].shortLocation = LOCATION_GET_SHORT(ptr - (Pointer) p);
		header->chunkDesc[j].offset = chunkOffsets[j];
		header->chunkDesc[j].chunkKeysFixed = chunkFixedKeys[j];
		ptr += MAXALIGN(sizeof(LocationIndex) * chunkItemsCount);

		for (i = chunkOffsets[j]; i < chunkOffsets[j + 1]; i++)
		{
			if (!(items[i].data >= p && items[i].data < p + ORIOLEDB_BLCKSZ) ||
				ptr < items[i].data)
				memmove(ptr, items[i].data, items[i].size);
			ptr += items[i].size;
		}

		if (j > 0)
		{
			OTuple		chunkHikeyTuple;
			LocationIndex chunkHikeySize;

			chunkHikeyTuple.formatFlags = ITEM_GET_FLAGS(chunk->items[0]);
			chunkHikeyTuple.data = (Pointer) chunk + ITEM_GET_OFFSET(chunk->items[0]) + itemHeaderSize;
			if (O_PAGE_IS(p, LEAF))
			{
				bool		shouldFree;

				chunkHikeyTuple = o_btree_tuple_make_key(desc, chunkHikeyTuple, hikeysPtr, false, &shouldFree);
				Assert(chunkHikeyTuple.data == hikeysPtr);
				Assert(!shouldFree);
			}

			chunkHikeySize = MAXALIGN(o_btree_len(desc, chunkHikeyTuple, OKeyLength));
			if (!(chunkHikeyTuple.formatFlags & O_TUPLE_FLAGS_FIXED_FORMAT))
				fixedKeys = false;
			if (chunkHikeyTuple.data != hikeysPtr)
				memcpy(hikeysPtr, chunkHikeyTuple.data, chunkHikeySize);
			header->chunkDesc[j - 1].hikeyFlags = chunkHikeyTuple.formatFlags;
			header->chunkDesc[j - 1].hikeyShortLocation = LOCATION_GET_SHORT(hikeysPtr - (Pointer) p);
			hikeysPtr += chunkHikeySize;
			Assert((hikeysPtr - (Pointer) p) <= hikeysEnd);
		}
	}

	/* Place page hikey */
	if (!isRightmost)
	{
		if (!(hikey.formatFlags & O_TUPLE_FLAGS_FIXED_FORMAT))
			fixedKeys = false;
		memcpy(hikeysPtr, hikey.data, hikeySize);
		if (hikeySize != MAXALIGN(hikeySize))
			memset(hikeysPtr + hikeySize, 0, MAXALIGN(hikeySize) - hikeySize);
		header->chunkDesc[j - 1].hikeyFlags = hikey.formatFlags;
		header->chunkDesc[j - 1].hikeyShortLocation = LOCATION_GET_SHORT(hikeysPtr - (Pointer) p);
		hikeysPtr += MAXALIGN(hikeySize);
		Assert((hikeysPtr - (Pointer) p) <= hikeysEnd);
	}
	else
	{
		header->chunkDesc[j - 1].hikeyFlags = 0;
		header->chunkDesc[j - 1].hikeyShortLocation = LOCATION_GET_SHORT(hikeysPtr - (Pointer) p);
	}
	header->hikeysEnd = hikeysPtr - (Pointer) p;
	header->itemsCount = count;
	header->flags |= O_BTREE_FLAG_HIKEYS_FIXED;
	if (!fixedKeys)
		header->flags &= ~O_BTREE_FLAG_HIKEYS_FIXED;
	VALGRIND_CHECK_MEM_IS_DEFINED(p, ORIOLEDB_BLCKSZ);
}

void
split_page_by_chunks(BTreeDescr *desc, Page p)
{
	BTreePageItemLocator loc;
	BTreePageItem items[BTREE_PAGE_MAX_CHUNK_ITEMS];
	int			i = 0;
	OFixedKey	hikey;
	LocationIndex hikeySize;

	BTREE_PAGE_FOREACH_ITEMS(p, &loc)
	{
		items[i].data = BTREE_PAGE_LOCATOR_GET_ITEM(p, &loc);
		items[i].flags = BTREE_PAGE_GET_ITEM_FLAGS(p, &loc);
		items[i].size = BTREE_PAGE_GET_ITEM_SIZE(p, &loc);
		i++;
	}

	if (O_PAGE_IS(p, RIGHTMOST))
	{
		O_TUPLE_SET_NULL(hikey.tuple);
		hikeySize = 0;
	}
	else
	{
		copy_fixed_hikey(desc, &hikey, p);
		hikeySize = BTREE_PAGE_GET_HIKEY_SIZE(p);
	}

	btree_page_reorg(desc, p, items, i, hikeySize, hikey.tuple);
}

bool
page_locator_find_real_item(Page p, PartialPageState *partial,
							BTreePageItemLocator *locator)
{
	BTreePageHeader *header = (BTreePageHeader *) p;
	OffsetNumber offset;

	while (locator->itemOffset >= locator->chunkItemsCount)
	{
		if (locator->chunkOffset >= header->chunksCount - 1)
			return true;

		offset = locator->itemOffset - locator->chunkItemsCount;
		if (partial)
		{
			if (!partial_load_chunk(partial, p, locator->chunkOffset + 1, locator))
				return false;
		}
		else
		{
			page_chunk_fill_locator(p, locator->chunkOffset + 1, locator);
		}
		locator->itemOffset = offset;
	}
	return true;
}

OffsetNumber
page_locator_get_offset(Page p, BTreePageItemLocator *locator)
{
	BTreePageHeader *header = (BTreePageHeader *) p;

	return header->chunkDesc[locator->chunkOffset].offset + locator->itemOffset;
}
